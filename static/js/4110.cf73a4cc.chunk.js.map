{"version":3,"file":"static/js/4110.cf73a4cc.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/nonChromiumPlatformUtils.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-components/blob/master/LICENSE.md for details.\n * v1.0.0-beta.97\n */\nimport { e as rectToClientRect } from './floating-ui.js';\n\n/**\n * This module provides utils to fix positioning across shadow DOM in non-Chromium browsers\n *\n * It is based on floating-ui's distributable\n */\n/**\n * üëá the following are needed to fix shadow DOM positioning üëáÔ∏è\n *\n * @param element\n */\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return composedOffsetParent(element);\n}\n/**\n * Polyfills the old offsetParent behavior from before the spec was changed:\n * https://github.com/w3c/csswg-drafts/issues/159\n *\n * @param element\n */\nfunction composedOffsetParent(element) {\n  let { offsetParent } = element;\n  let ancestor = element;\n  let foundInsideSlot = false;\n  while (ancestor && ancestor !== offsetParent) {\n    const { assignedSlot } = ancestor;\n    if (assignedSlot) {\n      let newOffsetParent = assignedSlot.offsetParent;\n      if (getComputedStyle(assignedSlot).display === \"contents\") {\n        const hadStyleAttribute = assignedSlot.hasAttribute(\"style\");\n        const oldDisplay = assignedSlot.style.display;\n        assignedSlot.style.display = getComputedStyle(ancestor).display;\n        newOffsetParent = assignedSlot.offsetParent;\n        assignedSlot.style.display = oldDisplay;\n        if (!hadStyleAttribute) {\n          assignedSlot.removeAttribute(\"style\");\n        }\n      }\n      ancestor = assignedSlot;\n      if (offsetParent !== newOffsetParent) {\n        offsetParent = newOffsetParent;\n        foundInsideSlot = true;\n      }\n    }\n    else if (isShadowRoot(ancestor) && ancestor.host && foundInsideSlot) {\n      break;\n    }\n    ancestor = (isShadowRoot(ancestor) && ancestor.host) || ancestor.parentNode;\n  }\n  return offsetParent;\n}\nfunction getElementRects(_ref) {\n  const { reference, floating, strategy } = _ref;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n    floating: { ...getDimensions(floating), x: 0, y: 0 }\n  };\n}\n/**\n * ‚òùÔ∏è the following are needed to fix shadow DOM positioning ‚òùÔ∏è\n */\n/**\n * üëá the following are taken directly from floating-ui's ESM distributable to support the exports above üëáÔ∏è\n *\n * **Notes**:\n * unused functions are removed\n * ESLint is disabled\n * TS-warnings are suppressed\n */\n/* eslint-disable */\nfunction isWindow(value) {\n  return value && value.document && value.location && value.alert && value.setInterval;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isWindow(node) ? \"\" : node ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nfunction getUAString() {\n  // @ts-ignore\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  // Browsers without `ShadowRoot` support\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const { overflow, overflowX, overflowY, display } = getComputedStyle(element);\n  return (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display));\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return (css.transform !== \"none\" ||\n    css.perspective !== \"none\" ||\n    (isFirefox && css.willChange === \"filter\") ||\n    (isFirefox && (css.filter ? css.filter !== \"none\" : false)) ||\n    [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) ||\n    [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    // TS 4.1 compat\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }));\n}\nfunction isLayoutViewport() {\n  // Not Safari\n  return !/^((?!chrome|android).)*safari/i.test(getUAString()); // Feature detection for this fails in various ways\n  // ‚Ä¢ Always-visible scrollbar or not\n  // ‚Ä¢ Width of <html>, etc.\n  // const vV = win.visualViewport;\n  // return vV ? Math.abs(win.innerWidth / vV.scale - vV.width) < 0.5 : true;\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left +\n    (addVisualOffsets\n      ? (_win$visualViewport$o =\n        (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null\n        ? _win$visualViewport$o\n        : 0\n      : 0)) /\n    scaleX;\n  const y = (clientRect.top +\n    (addVisualOffsets\n      ? (_win$visualViewport$o2 =\n        (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null\n        ? _win$visualViewport$o2\n        : 0\n      : 0)) /\n    scaleY;\n  const width = clientRect.width / scaleX;\n  const height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // @ts-ignore\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction isScaled(element) {\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, // @ts-ignore - checked above (TS 4.1 compat)\n  isOffsetParentAnElement && isScaled(offsetParent), strategy === \"fixed\");\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || (!isOffsetParentAnElement && strategy !== \"fixed\")) {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      // @ts-ignore\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n    else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  return (\n  // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n  // @ts-ignore\n  node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || // DOM Element detected\n    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n  );\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    else {\n      const parent = currentNode.parentNode;\n      currentNode = isShadowRoot(parent) ? parent.host : parent;\n    }\n  }\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent &&\n    (getNodeName(offsetParent) === \"html\" ||\n      (getNodeName(offsetParent) === \"body\" &&\n        getComputedStyle(offsetParent).position === \"static\" &&\n        !isContainingBlock(offsetParent)))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  // @ts-ignore\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || (!layoutViewport && strategy === \"fixed\")) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody\n    ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n    : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody\n    ? updatedList // @ts-ignore: isBody tells us target will be an HTMLElement here\n    : updatedList.concat(getOverflowAncestors(target));\n}\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getNearestParentCapableOfEscapingClipping(element, clippingAncestors) {\n  let currentNode = element;\n  while (currentNode && !isLastTraversableNode(currentNode) && !clippingAncestors.includes(currentNode)) {\n    if (isElement(currentNode) && [\"absolute\", \"fixed\"].includes(getComputedStyle(currentNode).position)) {\n      break;\n    }\n    const parentNode = getParentNode(currentNode);\n    currentNode = isShadowRoot(parentNode) ? parentNode.host : parentNode;\n  }\n  return currentNode;\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingParent, strategy) {\n  if (clippingParent === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingAncestors(element) {\n  // @ts-ignore\n  const clippingAncestors = getOverflowAncestors(element);\n  const nearestEscapableParent = getNearestParentCapableOfEscapingClipping(element, clippingAncestors);\n  let clipperElement = null;\n  if (nearestEscapableParent && isHTMLElement(nearestEscapableParent)) {\n    const offsetParent = getOffsetParent(nearestEscapableParent);\n    if (isOverflowElement(nearestEscapableParent)) {\n      clipperElement = nearestEscapableParent;\n    }\n    else if (isHTMLElement(offsetParent)) {\n      clipperElement = offsetParent;\n    }\n  }\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n  return clippingAncestors.filter((clippingAncestors) => clipperElement &&\n    isElement(clippingAncestors) &&\n    contains(clippingAncestors, clipperElement) &&\n    getNodeName(clippingAncestors) !== \"body\");\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\nfunction getClippingRect(_ref) {\n  let { element, boundary, rootBoundary, strategy } = _ref;\n  const mainClippingAncestors = boundary === \"clippingAncestors\" ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nexport { getClippingRect, getElementRects, getOffsetParent };\n"],"names":["getTrueOffsetParent","element","isHTMLElement","getComputedStyle","position","offsetParent","ancestor","foundInsideSlot","assignedSlot","newOffsetParent","display","hadStyleAttribute","hasAttribute","oldDisplay","style","removeAttribute","isShadowRoot","host","parentNode","composedOffsetParent","getElementRects","_ref","reference","floating","strategy","getRectRelativeToOffsetParent","getOffsetParent","getDimensions","x","y","isWindow","value","document","location","alert","setInterval","getWindow","node","window","ownerDocument","defaultView","getNodeName","nodeName","toLowerCase","getUAString","uaData","navigator","userAgentData","brands","map","item","brand","version","join","userAgent","HTMLElement","isElement","Element","ShadowRoot","isOverflowElement","overflow","overflowX","overflowY","test","includes","isTableElement","isContainingBlock","isFirefox","css","transform","perspective","willChange","filter","some","contain","isLayoutViewport","isLastTraversableNode","min","Math","max","round","getBoundingClientRect","includeScale","isFixedStrategy","_win$visualViewport$o","_win$visualViewport","_win$visualViewport$o2","_win$visualViewport2","clientRect","scaleX","scaleY","offsetWidth","width","offsetHeight","height","win","addVisualOffsets","left","visualViewport","offsetLeft","top","offsetTop","right","bottom","getDocumentElement","Node","documentElement","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getWindowScrollBarX","isOffsetParentAnElement","rect","isScaled","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","currentNode","parent","getContainingBlock","getNearestOverflowAncestor","body","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","target","concat","updatedList","getClientRectFromClippingAncestor","clippingParent","rectToClientRect","html","clientWidth","clientHeight","layoutViewport","getViewportRect","getInnerBoundingClientRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getDocumentRect","getClippingAncestors","clippingAncestors","nearestEscapableParent","getNearestParentCapableOfEscapingClipping","clipperElement","child","rootNode","getRootNode","contains","next","getClippingRect","boundary","rootBoundary","firstClippingAncestor","clippingRect","reduce","accRect","clippingAncestor"],"sourceRoot":""}