{"version":3,"file":"static/js/18779.dcbf38de.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/chunks/math.js","../node_modules/@esri/calcite-components/dist/components/calcite-color-picker/customElement.js","../node_modules/lit-html/src/directives/keyed.ts","../node_modules/lit-html/src/directives/repeat.ts"],"sourcesContent":["/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\nv3.2.1 */\nconst clamp = (value, min, max) => Math.max(min, Math.min(value, max));\nconst decimalNumberRegex = new RegExp(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\nconst decimalPlaces = (value) => {\n  const match = (\"\" + value).match(decimalNumberRegex);\n  if (!match || parseInt(match[1]) === 0) {\n    return 0;\n  }\n  return Math.max(\n    0,\n    // Number of digits right of decimal point.\n    (match[1] ? match[1].length : 0) - // Adjust for scientific notation.\n    (match[2] ? +match[2] : 0)\n  );\n};\nfunction getDecimals(value) {\n  if (decimalPlaces(value) > 0 && value > 0) {\n    return parseFloat(`0.${value.toString().split(\".\")[1]}`);\n  }\n  return value;\n}\nfunction remap(value, fromMin, fromMax, toMin, toMax) {\n  return (value - fromMin) * (toMax - toMin) / (fromMax - fromMin) + toMin;\n}\nfunction closeToRangeEdge(value, range, threshold) {\n  return value < threshold ? -1 : value > range - threshold ? 1 : 0;\n}\nexport {\n  closeToRangeEdge as a,\n  clamp as c,\n  decimalPlaces as d,\n  getDecimals as g,\n  remap as r\n};\n","/*! All material copyright ESRI, All Rights Reserved, unless otherwise specified.\nSee https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\nv3.2.1 */\nimport { c as customElement } from \"../../chunks/runtime.js\";\nimport { ref } from \"lit-html/directives/ref.js\";\nimport { repeat } from \"lit-html/directives/repeat.js\";\nimport { keyed } from \"lit-html/directives/keyed.js\";\nimport Color from \"color\";\nimport { throttle } from \"lodash-es\";\nimport { html, nothing } from \"lit\";\nimport { LitElement, createEvent, safeClassMap, safeStyleMap } from \"@arcgis/lumina\";\nimport { i as isPrimaryPointerButton, h as focusFirstTabbable, g as getElementDir } from \"../../chunks/dom.js\";\nimport { u as updateHostInteraction, I as InteractiveContainer } from \"../../chunks/interactive.js\";\nimport { i as isActivationKey } from \"../../chunks/key.js\";\nimport { c as componentFocusable } from \"../../chunks/component.js\";\nimport { c as clamp, r as remap, a as closeToRangeEdge } from \"../../chunks/math.js\";\nimport { u as useT9n } from \"../../chunks/useT9n.js\";\nimport { c as createObserver } from \"../../chunks/observers.js\";\nimport { D as DEFAULT_COLOR, C as CSSColorMode, g as getSliderWidth, e as getColorFieldDimensions, S as STATIC_DIMENSIONS, n as normalizeHex, h as hexify, p as parseMode, f as DEFAULT_STORAGE_KEY_PREFIX, j as alphaCompatible, k as normalizeColor, l as colorEqual, O as OPACITY_LIMITS, R as RGB_LIMITS, H as HSV_LIMITS, m as CSS, o as opacityToAlpha, t as toAlphaMode, q as toNonAlphaMode, s as HUE_LIMIT_CONSTRAINED, u as normalizeAlpha, c as alphaToOpacity, v as SCOPE_SIZE } from \"../../chunks/utils4.js\";\nimport { css } from \"@lit/reactive-element/css-tag.js\";\nconst styles = css`:host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:inline-block;font-size:var(--calcite-font-size--2);line-height:1rem;font-weight:var(--calcite-font-weight-normal);inline-size:var(--calcite-internal-color-picker-min-width);min-inline-size:var(--calcite-internal-color-picker-min-width)}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}:host([scale=s]){--calcite-internal-color-picker-min-width: 200px;--calcite-color-picker-spacing: 8px}:host([scale=s]) .saved-colors{gap:.25rem;grid-template-columns:repeat(auto-fill,20px)}:host([scale=m]){--calcite-internal-color-picker-min-width: 240px;--calcite-color-picker-spacing: 12px}:host([scale=l]){--calcite-internal-color-picker-min-width: 304px;--calcite-color-picker-spacing: 16px;font-size:var(--calcite-font-size--1);line-height:1rem}:host([scale=l]) .section:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}:host([scale=l]) .saved-colors{grid-template-columns:repeat(auto-fill,32px)}:host([scale=l]) .control-section{display:flex;flex-direction:column;flex-wrap:wrap;align-items:baseline}:host([scale=l]) .color-hex-options{inline-size:100%;display:flex;flex-shrink:1;flex-direction:column;justify-content:space-around}:host([scale=l]) .color-mode-container{flex-shrink:3}.container{background-color:var(--calcite-color-foreground-1);display:flex;flex-direction:column;block-size:min-content;border:1px solid var(--calcite-color-border-1)}.control-and-scope{position:relative;display:flex;cursor:pointer;touch-action:none}.color-field,.control-and-scope{-webkit-user-select:none;user-select:none}.scope{pointer-events:none;position:absolute;z-index:var(--calcite-z-index);block-size:1px;inline-size:1px;border-radius:9999px;background-color:transparent;font-size:var(--calcite-font-size--1);outline-color:transparent}.scope:focus{outline:2px solid var(--calcite-color-focus, var(--calcite-ui-focus-color, var(--calcite-color-brand)));outline-offset:calc(2px*(1 - (2*clamp(0,var(--calcite-offset-invert-focus),1))));outline-offset:6px}.hex-and-channels-group{display:flex;inline-size:100%;flex-direction:column;flex-wrap:wrap}.section{padding-block:0 var(--calcite-color-picker-spacing);padding-inline:var(--calcite-color-picker-spacing)}.section:first-of-type{padding-block-start:var(--calcite-color-picker-spacing)}.sliders{display:flex;flex-direction:column;justify-content:space-between;margin-inline-start:var(--calcite-color-picker-spacing);gap:var(--calcite-spacing-xxs)}.preview-and-sliders{display:flex;align-items:center;padding:var(--calcite-color-picker-spacing)}.color-hex-options,.section--split{flex-grow:1}.header{display:flex;align-items:center;justify-content:space-between;color:var(--calcite-color-text-1)}.color-mode-container{padding-block-start:var(--calcite-color-picker-spacing)}.channels{display:flex}.channel{flex-grow:1}.channel[data-channel-index=\"3\"]{margin-inline-start:-1px;min-inline-size:81px}:host([scale=s]) .channel[data-channel-index=\"3\"]{min-inline-size:68px}:host([scale=l]) .channel[data-channel-index=\"3\"]{min-inline-size:88px}.saved-colors{display:grid;gap:.5rem;padding-block-start:var(--calcite-color-picker-spacing);grid-template-columns:repeat(auto-fill,24px)}.saved-colors-buttons{display:flex}.saved-color{outline-offset:0;outline-color:transparent;cursor:pointer}.saved-color:focus{outline:2px solid var(--calcite-color-brand);outline-offset:2px}.saved-color:hover{transition:outline-color var(--calcite-internal-animation-timing-fast) ease-in-out;outline:2px solid var(--calcite-color-border-2);outline-offset:2px}:host([hidden]){display:none}[hidden]{display:none}`;\nconst throttleFor60FpsInMs = 16;\nclass ColorPicker extends LitElement {\n  constructor() {\n    super();\n    this._color = DEFAULT_COLOR;\n    this.internalColorUpdateContext = null;\n    this.isActiveChannelInputEmpty = false;\n    this.mode = CSSColorMode.HEX;\n    this.resizeObserver = createObserver(\"resize\", (entries) => this.resizeCanvas(entries));\n    this.shiftKeyChannelAdjustment = 0;\n    this.upOrDownArrowKeyTracker = null;\n    this._valueWasSet = false;\n    this.messages = useT9n({ blocking: true });\n    this.captureColorFieldColor = (x, y, skipEqual = true) => {\n      const { width, height } = this.dynamicDimensions.colorField;\n      const saturation = Math.round(HSV_LIMITS.s / width * x);\n      const value = Math.round(HSV_LIMITS.v / height * (height - y));\n      this.internalColorSet(this.baseColorFieldColor.hsv().saturationv(saturation).value(value), skipEqual);\n    };\n    this.drawColorControls = throttle((type = \"all\") => {\n      if ((type === \"all\" || type === \"color-field\") && this.colorFieldRenderingContext) {\n        this.drawColorField();\n      }\n      if ((type === \"all\" || type === \"hue-slider\") && this.hueSliderRenderingContext) {\n        this.drawHueSlider();\n      }\n      if (this.alphaChannel && (type === \"all\" || type === \"opacity-slider\") && this.opacitySliderRenderingContext) {\n        this.drawOpacitySlider();\n      }\n    }, throttleFor60FpsInMs);\n    this.globalPointerMoveHandler = (event) => {\n      const { activeCanvasInfo, el } = this;\n      if (!el.isConnected || !activeCanvasInfo) {\n        return;\n      }\n      const { context, bounds } = activeCanvasInfo;\n      let samplingX;\n      let samplingY;\n      const { clientX, clientY } = event;\n      if (context.canvas.matches(\":hover\")) {\n        samplingX = clientX - bounds.x;\n        samplingY = clientY - bounds.y;\n      } else {\n        if (clientX < bounds.x + bounds.width && clientX > bounds.x) {\n          samplingX = clientX - bounds.x;\n        } else if (clientX < bounds.x) {\n          samplingX = 0;\n        } else {\n          samplingX = bounds.width;\n        }\n        if (clientY < bounds.y + bounds.height && clientY > bounds.y) {\n          samplingY = clientY - bounds.y;\n        } else if (clientY < bounds.y) {\n          samplingY = 0;\n        } else {\n          samplingY = bounds.height;\n        }\n      }\n      if (context === this.colorFieldRenderingContext) {\n        this.captureColorFieldColor(samplingX, samplingY, false);\n      } else if (context === this.hueSliderRenderingContext) {\n        this.captureHueSliderColor(samplingX);\n      } else if (context === this.opacitySliderRenderingContext) {\n        this.captureOpacitySliderValue(samplingX);\n      }\n    };\n    this.globalPointerUpHandler = (event) => {\n      if (!isPrimaryPointerButton(event)) {\n        return;\n      }\n      const previouslyDragging = this.activeCanvasInfo;\n      this.activeCanvasInfo = null;\n      this.drawColorControls();\n      if (previouslyDragging) {\n        this.calciteColorPickerChange.emit();\n      }\n    };\n    this.resizeCanvas = throttle((entries) => {\n      if (!this.hasUpdated) {\n        return;\n      }\n      const [first] = entries;\n      const availableWidth = Math.floor(first.contentBoxSize[0].inlineSize);\n      if (this.dynamicDimensions.colorField.width === availableWidth) {\n        return;\n      }\n      this.updateDynamicDimensions(availableWidth);\n      this.updateCanvasSize();\n      this.drawColorControls();\n    }, throttleFor60FpsInMs);\n    this.updateDynamicDimensions = (width) => {\n      const sliderDims = {\n        width: getSliderWidth(width, this.staticDimensions, this.alphaChannel),\n        height: this.staticDimensions.slider.height\n      };\n      this.dynamicDimensions = {\n        colorField: getColorFieldDimensions(width),\n        slider: sliderDims\n      };\n    };\n    this.channelMode = \"rgb\";\n    this.channels = this.toChannels(DEFAULT_COLOR);\n    this.staticDimensions = STATIC_DIMENSIONS.m;\n    this.savedColors = [];\n    this.allowEmpty = false;\n    this.alphaChannel = false;\n    this.channelsDisabled = false;\n    this.clearable = false;\n    this.disabled = false;\n    this.format = \"auto\";\n    this.hexDisabled = false;\n    this.savedDisabled = false;\n    this.scale = \"m\";\n    this.calciteColorPickerChange = createEvent({ cancelable: false });\n    this.calciteColorPickerInput = createEvent({ cancelable: false });\n    this.listen(\"keydown\", this.handleChannelKeyUpOrDown, { capture: true });\n    this.listen(\"keyup\", this.handleChannelKeyUpOrDown, { capture: true });\n  }\n  static {\n    this.properties = { channelMode: [16, {}, { state: true }], channels: [16, {}, { state: true }], colorFieldScopeLeft: [16, {}, { state: true }], colorFieldScopeTop: [16, {}, { state: true }], staticDimensions: [16, {}, { state: true }], hueScopeLeft: [16, {}, { state: true }], opacityScopeLeft: [16, {}, { state: true }], savedColors: [16, {}, { state: true }], scopeOrientation: [16, {}, { state: true }], allowEmpty: [7, {}, { reflect: true, type: Boolean }], alphaChannel: [5, {}, { type: Boolean }], channelsDisabled: [5, {}, { type: Boolean }], clearable: [7, {}, { reflect: true, type: Boolean }], color: [0, {}, { attribute: false }], disabled: [7, {}, { reflect: true, type: Boolean }], format: [3, {}, { reflect: true }], hexDisabled: [5, {}, { type: Boolean }], messageOverrides: [0, {}, { attribute: false }], numberingSystem: [3, {}, { reflect: true }], savedDisabled: [7, {}, { reflect: true, type: Boolean }], scale: [3, {}, { reflect: true }], storageId: [3, {}, { reflect: true }], value: 1 };\n  }\n  static {\n    this.styles = styles;\n  }\n  get color() {\n    return this._color;\n  }\n  set color(color) {\n    const oldColor = this._color;\n    this._color = color;\n    this.handleColorChange(color, oldColor);\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    const oldValue = this._value;\n    this._value = value;\n    this.handleValueChange(value, oldValue);\n    this._valueWasSet = true;\n  }\n  async setFocus() {\n    await componentFocusable(this);\n    focusFirstTabbable(this.el);\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.observeResize();\n  }\n  async load() {\n    if (!this._valueWasSet) {\n      this._value ??= normalizeHex(hexify(DEFAULT_COLOR, this.alphaChannel));\n    }\n    this.handleAllowEmptyOrClearableChange();\n    const { isClearable, color, format, value } = this;\n    const willSetNoColor = isClearable && !value;\n    const parsedMode = parseMode(value);\n    const valueIsCompatible = willSetNoColor || format === \"auto\" && parsedMode || format === parsedMode;\n    const initialColor = willSetNoColor ? null : valueIsCompatible ? Color(value) : color;\n    if (!valueIsCompatible) {\n      this.showIncompatibleColorWarning(value, format);\n    }\n    this.setMode(format, false);\n    this.internalColorSet(initialColor, false, \"initial\");\n    this.updateStaticDimensions(this.scale);\n    this.updateDynamicDimensions(STATIC_DIMENSIONS[this.scale].minWidth);\n    const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;\n    if (this.storageId && localStorage.getItem(storageKey)) {\n      this.savedColors = JSON.parse(localStorage.getItem(storageKey));\n    }\n  }\n  willUpdate(changes) {\n    if (changes.has(\"allowEmpty\") && (this.hasUpdated || this.allowEmpty !== false) || changes.has(\"clearable\") && (this.hasUpdated || this.clearable !== false)) {\n      this.handleAllowEmptyOrClearableChange();\n    }\n    if (changes.has(\"alphaChannel\") && (this.hasUpdated || this.alphaChannel !== false)) {\n      this.handleAlphaChannelChange(this.alphaChannel);\n    }\n    if (this.hasUpdated && (changes.has(\"alphaChannel\") && this.alphaChannel !== false || changes.has(\"staticDimensions\") && this.staticDimensions !== STATIC_DIMENSIONS.m)) {\n      this.handleAlphaChannelDimensionsChange();\n    }\n    if (changes.has(\"alphaChannel\") && (this.hasUpdated || this.alphaChannel !== false) || changes.has(\"format\") && (this.hasUpdated || this.format !== \"auto\")) {\n      this.handleFormatOrAlphaChannelChange();\n    }\n    if (changes.has(\"scale\") && (this.hasUpdated || this.scale !== \"m\")) {\n      this.handleScaleChange(this.scale);\n    }\n  }\n  updated() {\n    updateHostInteraction(this);\n  }\n  loaded() {\n    this.handleAlphaChannelDimensionsChange();\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    window.removeEventListener(\"pointermove\", this.globalPointerMoveHandler);\n    window.removeEventListener(\"pointerup\", this.globalPointerUpHandler);\n    this.resizeObserver?.disconnect();\n  }\n  get baseColorFieldColor() {\n    return this.color || this.previousColor || DEFAULT_COLOR;\n  }\n  get effectiveSliderWidth() {\n    return this.dynamicDimensions.slider.width;\n  }\n  observeResize() {\n    this.resizeObserver?.observe(this.el);\n  }\n  handleAllowEmptyOrClearableChange() {\n    this.isClearable = this.clearable || this.allowEmpty;\n  }\n  handleAlphaChannelChange(alphaChannel) {\n    const { format } = this;\n    if (alphaChannel && format !== \"auto\" && !alphaCompatible(format)) {\n      console.warn(`ignoring alphaChannel as the current format (${format}) does not support alpha`);\n      this.alphaChannel = false;\n    }\n  }\n  handleAlphaChannelDimensionsChange() {\n    this.drawColorControls();\n  }\n  handleColorChange(color, oldColor) {\n    this.drawColorControls();\n    this.updateChannelsFromColor(color);\n    this.previousColor = oldColor;\n  }\n  handleFormatOrAlphaChannelChange() {\n    this.setMode(this.format);\n    this.internalColorSet(this.color, false, \"internal\");\n  }\n  handleScaleChange(scale = \"m\") {\n    this.updateStaticDimensions(scale);\n    this.updateCanvasSize();\n    this.drawColorControls();\n  }\n  handleValueChange(value, oldValue) {\n    const { isClearable, format } = this;\n    const checkMode = !isClearable || value;\n    let modeChanged = false;\n    if (checkMode) {\n      const nextMode = parseMode(value);\n      if (!nextMode || format !== \"auto\" && nextMode !== format) {\n        this.showIncompatibleColorWarning(value, format);\n        this._value = oldValue;\n        return;\n      }\n      modeChanged = this.mode !== nextMode;\n      this.setMode(nextMode, this.internalColorUpdateContext === null);\n    }\n    const dragging = this.activeCanvasInfo;\n    if (this.internalColorUpdateContext === \"initial\") {\n      return;\n    }\n    if (this.internalColorUpdateContext === \"user-interaction\") {\n      this.calciteColorPickerInput.emit();\n      if (!dragging) {\n        this.calciteColorPickerChange.emit();\n      }\n      return;\n    }\n    const color = isClearable && !value ? null : Color(value != null && typeof value === \"object\" && alphaCompatible(this.mode) ? normalizeColor(value) : value);\n    const colorChanged = !colorEqual(color, this.color);\n    if (modeChanged || colorChanged) {\n      this.internalColorSet(color, this.alphaChannel && !(this.mode.endsWith(\"a\") || this.mode.endsWith(\"a-css\")) || this.internalColorUpdateContext === \"internal\", \"internal\");\n    }\n  }\n  handleTabActivate(event) {\n    this.channelMode = event.currentTarget.getAttribute(\"data-color-mode\");\n    this.updateChannelsFromColor(this.color);\n  }\n  handleColorFieldScopeKeyDown(event) {\n    const { key } = event;\n    const arrowKeyToXYOffset = {\n      ArrowUp: { x: 0, y: -10 },\n      ArrowRight: { x: 10, y: 0 },\n      ArrowDown: { x: 0, y: 10 },\n      ArrowLeft: { x: -10, y: 0 }\n    };\n    if (arrowKeyToXYOffset[key]) {\n      event.preventDefault();\n      this.scopeOrientation = key === \"ArrowDown\" || key === \"ArrowUp\" ? \"vertical\" : \"horizontal\";\n      this.captureColorFieldColor(this.colorFieldScopeLeft + arrowKeyToXYOffset[key].x || 0, this.colorFieldScopeTop + arrowKeyToXYOffset[key].y || 0, false);\n    }\n  }\n  handleHueScopeKeyDown(event) {\n    const modifier = event.shiftKey ? 10 : 1;\n    const { key } = event;\n    const arrowKeyToXOffset = {\n      ArrowUp: 1,\n      ArrowRight: 1,\n      ArrowDown: -1,\n      ArrowLeft: -1\n    };\n    if (arrowKeyToXOffset[key]) {\n      event.preventDefault();\n      const delta = arrowKeyToXOffset[key] * modifier;\n      const hue = this.baseColorFieldColor.hue();\n      const color = this.baseColorFieldColor.hue(hue + delta);\n      this.internalColorSet(color, false);\n    }\n  }\n  handleHexInputChange(event) {\n    event.stopPropagation();\n    const { isClearable, color } = this;\n    const input = event.target;\n    const hex = input.value;\n    if (isClearable && !hex) {\n      this.internalColorSet(null);\n      return;\n    }\n    const normalizedHex = color && normalizeHex(hexify(color, alphaCompatible(this.mode)));\n    if (hex !== normalizedHex) {\n      this.internalColorSet(Color(hex));\n    }\n  }\n  handleSavedColorSelect(event) {\n    const swatch = event.currentTarget;\n    this.internalColorSet(Color(swatch.color));\n  }\n  handleChannelInput(event) {\n    const input = event.currentTarget;\n    const channelIndex = Number(input.getAttribute(\"data-channel-index\"));\n    const isAlphaChannel = channelIndex === 3;\n    const limit = isAlphaChannel ? OPACITY_LIMITS.max : this.channelMode === \"rgb\" ? RGB_LIMITS[Object.keys(RGB_LIMITS)[channelIndex]] : HSV_LIMITS[Object.keys(HSV_LIMITS)[channelIndex]];\n    let inputValue;\n    if (!input.value) {\n      inputValue = \"\";\n      this.isActiveChannelInputEmpty = true;\n      this.upOrDownArrowKeyTracker = null;\n    } else {\n      const value = Number(input.value);\n      const adjustedValue = value + this.shiftKeyChannelAdjustment;\n      const clamped = clamp(adjustedValue, 0, limit);\n      inputValue = clamped.toString();\n    }\n    input.value = inputValue;\n    if (inputValue !== \"\" && this.shiftKeyChannelAdjustment !== 0) {\n      this.handleChannelChange(event);\n    } else if (inputValue !== \"\") {\n      this.handleChannelChange(event);\n    }\n  }\n  handleChannelBlur(event) {\n    const input = event.currentTarget;\n    const channelIndex = Number(input.getAttribute(\"data-channel-index\"));\n    const channels = [...this.channels];\n    const restoreValueDueToEmptyInput = !input.value && !this.isClearable;\n    if (restoreValueDueToEmptyInput) {\n      input.value = channels[channelIndex]?.toString();\n    }\n  }\n  handleChannelFocus(event) {\n    const input = event.currentTarget;\n    input.selectText();\n  }\n  handleChannelKeyUpOrDown(event) {\n    this.shiftKeyChannelAdjustment = 0;\n    const { key } = event;\n    if (key !== \"ArrowUp\" && key !== \"ArrowDown\" || !event.composedPath().some((node) => node.classList?.contains(CSS.channel))) {\n      return;\n    }\n    const { shiftKey } = event;\n    event.preventDefault();\n    if (!this.color) {\n      this.internalColorSet(this.previousColor);\n      event.stopPropagation();\n      return;\n    }\n    const complementaryBump = 9;\n    this.shiftKeyChannelAdjustment = key === \"ArrowUp\" && shiftKey ? complementaryBump : key === \"ArrowDown\" && shiftKey ? -9 : 0;\n    if (key === \"ArrowUp\") {\n      this.upOrDownArrowKeyTracker = \"up\";\n    }\n    if (key === \"ArrowDown\") {\n      this.upOrDownArrowKeyTracker = \"down\";\n    }\n  }\n  getChannelInputLimit(channelIndex) {\n    return this.channelMode === \"rgb\" ? RGB_LIMITS[Object.keys(RGB_LIMITS)[channelIndex]] : HSV_LIMITS[Object.keys(HSV_LIMITS)[channelIndex]];\n  }\n  handleChannelChange(event) {\n    const input = event.currentTarget;\n    const channelIndex = Number(input.getAttribute(\"data-channel-index\"));\n    const channels = [...this.channels];\n    const shouldClearChannels = this.isClearable && !input.value;\n    if (shouldClearChannels) {\n      this.channels = [null, null, null, null];\n      this.internalColorSet(null);\n      return;\n    }\n    const isAlphaChannel = channelIndex === 3;\n    if (this.isActiveChannelInputEmpty && this.upOrDownArrowKeyTracker) {\n      input.value = this.upOrDownArrowKeyTracker === \"up\" ? (channels[channelIndex] + 1 <= this.getChannelInputLimit(channelIndex) ? channels[channelIndex] + 1 : this.getChannelInputLimit(channelIndex)).toString() : (channels[channelIndex] - 1 >= 0 ? channels[channelIndex] - 1 : 0).toString();\n      this.isActiveChannelInputEmpty = false;\n      this.upOrDownArrowKeyTracker = null;\n    }\n    const value = input.value ? Number(input.value) : channels[channelIndex];\n    channels[channelIndex] = isAlphaChannel ? opacityToAlpha(value) : value;\n    this.updateColorFromChannels(channels);\n  }\n  handleSavedColorKeyDown(event) {\n    if (isActivationKey(event.key)) {\n      event.preventDefault();\n      this.handleSavedColorSelect(event);\n    }\n  }\n  handleColorFieldPointerDown(event) {\n    this.handleCanvasControlPointerDown(event, this.colorFieldRenderingContext, this.captureColorFieldColor, this.colorFieldScopeNode);\n  }\n  focusScope(focusEl) {\n    requestAnimationFrame(() => {\n      focusEl.focus();\n    });\n  }\n  handleHueSliderPointerDown(event) {\n    this.handleCanvasControlPointerDown(event, this.hueSliderRenderingContext, this.captureHueSliderColor, this.hueScopeNode);\n  }\n  handleOpacitySliderPointerDown(event) {\n    this.handleCanvasControlPointerDown(event, this.opacitySliderRenderingContext, this.captureOpacitySliderValue, this.opacityScopeNode);\n  }\n  handleCanvasControlPointerDown(event, renderingContext, captureValue, scopeNode) {\n    if (!isPrimaryPointerButton(event)) {\n      return;\n    }\n    window.addEventListener(\"pointermove\", this.globalPointerMoveHandler);\n    window.addEventListener(\"pointerup\", this.globalPointerUpHandler, {\n      once: true\n    });\n    this.activeCanvasInfo = {\n      context: renderingContext,\n      bounds: renderingContext.canvas.getBoundingClientRect()\n    };\n    captureValue.call(this, event.offsetX, event.offsetY);\n    this.focusScope(scopeNode);\n  }\n  storeColorFieldScope(node) {\n    this.colorFieldScopeNode = node;\n  }\n  storeHueScope(node) {\n    this.hueScopeNode = node;\n  }\n  handleKeyDown(event) {\n    if (event.key === \"Enter\") {\n      event.preventDefault();\n    }\n  }\n  showIncompatibleColorWarning(value, format) {\n    console.warn(`ignoring color value (${value}) as it is not compatible with the current format (${format})`);\n  }\n  setMode(format, warn = true) {\n    const mode = format === \"auto\" ? this.mode : format;\n    this.mode = this.ensureCompatibleMode(mode, warn);\n  }\n  ensureCompatibleMode(mode, warn) {\n    const { alphaChannel } = this;\n    const isAlphaCompatible = alphaCompatible(mode);\n    if (alphaChannel && !isAlphaCompatible) {\n      const alphaMode = toAlphaMode(mode);\n      if (warn) {\n        console.warn(`setting format to (${alphaMode}) as the provided one (${mode}) does not support alpha`);\n      }\n      return alphaMode;\n    }\n    if (!alphaChannel && isAlphaCompatible) {\n      const nonAlphaMode = toNonAlphaMode(mode);\n      if (warn) {\n        console.warn(`setting format to (${nonAlphaMode}) as the provided one (${mode}) does not support alpha`);\n      }\n      return nonAlphaMode;\n    }\n    return mode;\n  }\n  captureHueSliderColor(x) {\n    const hue = HUE_LIMIT_CONSTRAINED / this.effectiveSliderWidth * x;\n    this.internalColorSet(this.baseColorFieldColor.hue(hue), false);\n  }\n  captureOpacitySliderValue(x) {\n    const alpha = opacityToAlpha(OPACITY_LIMITS.max / this.effectiveSliderWidth * x);\n    this.internalColorSet(this.baseColorFieldColor.alpha(alpha), false);\n  }\n  internalColorSet(color, skipEqual = true, context = \"user-interaction\") {\n    if (skipEqual && colorEqual(color, this.color)) {\n      return;\n    }\n    this.internalColorUpdateContext = context;\n    this.color = color;\n    this.value = this.toValue(color);\n    this.internalColorUpdateContext = null;\n  }\n  toValue(color, format = this.mode) {\n    if (!color) {\n      return null;\n    }\n    const hexMode = \"hex\";\n    if (format.includes(hexMode)) {\n      const hasAlpha = format === CSSColorMode.HEXA;\n      return normalizeHex(hexify(color.round(), hasAlpha), hasAlpha);\n    }\n    if (format.includes(\"-css\")) {\n      const value = color[format.replace(\"-css\", \"\").replace(\"a\", \"\")]().round().string();\n      const needToInjectAlpha = (format.endsWith(\"a\") || format.endsWith(\"a-css\")) && color.alpha() === 1;\n      if (needToInjectAlpha) {\n        const model = value.slice(0, 3);\n        const values = value.slice(4, -1);\n        return `${model}a(${values}, ${color.alpha()})`;\n      }\n      return value;\n    }\n    const colorObject = (\n      /* Color() does not support hsva, hsla nor rgba, so we use the non-alpha mode */\n      color[toNonAlphaMode(format)]().round().object()\n    );\n    if (format.endsWith(\"a\")) {\n      return normalizeAlpha(colorObject);\n    }\n    return colorObject;\n  }\n  getSliderCapSpacing() {\n    const { staticDimensions: { slider: { height }, thumb: { radius } } } = this;\n    return radius * 2 - height;\n  }\n  updateStaticDimensions(scale = \"m\") {\n    this.staticDimensions = STATIC_DIMENSIONS[scale];\n  }\n  deleteColor() {\n    const colorToDelete = hexify(this.color, this.alphaChannel);\n    const inStorage = this.savedColors.indexOf(colorToDelete) > -1;\n    if (!inStorage) {\n      return;\n    }\n    const savedColors = this.savedColors.filter((color) => color !== colorToDelete);\n    this.savedColors = savedColors;\n    const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;\n    if (this.storageId) {\n      localStorage.setItem(storageKey, JSON.stringify(savedColors));\n    }\n  }\n  saveColor() {\n    const colorToSave = hexify(this.color, this.alphaChannel);\n    const alreadySaved = this.savedColors.indexOf(colorToSave) > -1;\n    if (alreadySaved) {\n      return;\n    }\n    const savedColors = [...this.savedColors, colorToSave];\n    this.savedColors = savedColors;\n    const storageKey = `${DEFAULT_STORAGE_KEY_PREFIX}${this.storageId}`;\n    if (this.storageId) {\n      localStorage.setItem(storageKey, JSON.stringify(savedColors));\n    }\n  }\n  drawColorField() {\n    const context = this.colorFieldRenderingContext;\n    const { width, height } = this.dynamicDimensions.colorField;\n    context.fillStyle = this.baseColorFieldColor.hsv().saturationv(100).value(100).alpha(1).string();\n    context.fillRect(0, 0, width, height);\n    const whiteGradient = context.createLinearGradient(0, 0, width, 0);\n    whiteGradient.addColorStop(0, \"rgba(255,255,255,1)\");\n    whiteGradient.addColorStop(1, \"rgba(255,255,255,0)\");\n    context.fillStyle = whiteGradient;\n    context.fillRect(0, 0, width, height);\n    const blackGradient = context.createLinearGradient(0, 0, 0, height);\n    blackGradient.addColorStop(0, \"rgba(0,0,0,0)\");\n    blackGradient.addColorStop(1, \"rgba(0,0,0,1)\");\n    context.fillStyle = blackGradient;\n    context.fillRect(0, 0, width, height);\n    this.drawActiveColorFieldColor();\n  }\n  setCanvasContextSize(canvas, { height, width }) {\n    if (!canvas) {\n      return;\n    }\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    canvas.width = width * devicePixelRatio;\n    canvas.height = height * devicePixelRatio;\n    canvas.style.height = `${height}px`;\n    canvas.style.width = `${width}px`;\n    const context = canvas.getContext(\"2d\");\n    context.scale(devicePixelRatio, devicePixelRatio);\n  }\n  initColorField(canvas) {\n    if (!canvas) {\n      return;\n    }\n    this.colorFieldRenderingContext = canvas.getContext(\"2d\");\n    this.updateCanvasSize(\"color-field\");\n    this.drawColorControls();\n  }\n  initHueSlider(canvas) {\n    if (!canvas) {\n      return;\n    }\n    this.hueSliderRenderingContext = canvas.getContext(\"2d\");\n    this.updateCanvasSize(\"hue-slider\");\n    this.drawHueSlider();\n  }\n  initOpacitySlider(canvas) {\n    if (!canvas) {\n      return;\n    }\n    this.opacitySliderRenderingContext = canvas.getContext(\"2d\");\n    this.updateCanvasSize(\"opacity-slider\");\n    this.drawOpacitySlider();\n  }\n  updateCanvasSize(context = \"all\") {\n    const { dynamicDimensions, staticDimensions } = this;\n    if (context === \"all\" || context === \"color-field\") {\n      this.setCanvasContextSize(this.colorFieldRenderingContext?.canvas, dynamicDimensions.colorField);\n    }\n    const adjustedSliderDimensions = {\n      width: this.effectiveSliderWidth,\n      height: staticDimensions.slider.height + (staticDimensions.thumb.radius - dynamicDimensions.slider.height / 2) * 2\n    };\n    if (context === \"all\" || context === \"hue-slider\") {\n      this.setCanvasContextSize(this.hueSliderRenderingContext?.canvas, adjustedSliderDimensions);\n    }\n    if (context === \"all\" || context === \"opacity-slider\") {\n      this.setCanvasContextSize(this.opacitySliderRenderingContext?.canvas, adjustedSliderDimensions);\n    }\n  }\n  drawActiveColorFieldColor() {\n    const { color } = this;\n    if (!color) {\n      return;\n    }\n    const hsvColor = color.hsv();\n    const { staticDimensions: { thumb: { radius } } } = this;\n    const { width, height } = this.dynamicDimensions.colorField;\n    const x = hsvColor.saturationv() / (HSV_LIMITS.s / width);\n    const y = height - hsvColor.value() / (HSV_LIMITS.v / height);\n    requestAnimationFrame(() => {\n      this.colorFieldScopeLeft = x;\n      this.colorFieldScopeTop = y;\n    });\n    this.drawThumb(this.colorFieldRenderingContext, radius, x, y, hsvColor, false);\n  }\n  drawThumb(context, radius, x, y, color, applyAlpha) {\n    const startAngle = 0;\n    const endAngle = 2 * Math.PI;\n    const outlineWidth = 1;\n    context.beginPath();\n    context.arc(x, y, radius, startAngle, endAngle);\n    context.fillStyle = \"#fff\";\n    context.fill();\n    context.strokeStyle = \"rgba(0,0,0,0.3)\";\n    context.lineWidth = outlineWidth;\n    context.stroke();\n    if (applyAlpha && color.alpha() < 1) {\n      const pattern = context.createPattern(this.getCheckeredBackgroundPattern(), \"repeat\");\n      context.beginPath();\n      context.arc(x, y, radius - 3, startAngle, endAngle);\n      context.fillStyle = pattern;\n      context.fill();\n    }\n    context.globalCompositeOperation = \"source-atop\";\n    context.beginPath();\n    context.arc(x, y, radius - 3, startAngle, endAngle);\n    const alpha = applyAlpha ? color.alpha() : 1;\n    context.fillStyle = color.rgb().alpha(alpha).string();\n    context.fill();\n    context.globalCompositeOperation = \"source-over\";\n  }\n  drawActiveHueSliderColor() {\n    const { color } = this;\n    if (!color) {\n      return;\n    }\n    const hsvColor = color.hsv().saturationv(100).value(100);\n    const { staticDimensions: { thumb: { radius } } } = this;\n    const width = this.effectiveSliderWidth;\n    const x = hsvColor.hue() / (HUE_LIMIT_CONSTRAINED / width);\n    const y = radius;\n    const sliderBoundX = this.getSliderBoundX(x, width, radius);\n    requestAnimationFrame(() => {\n      this.hueScopeLeft = sliderBoundX;\n    });\n    this.drawThumb(this.hueSliderRenderingContext, radius, sliderBoundX, y, hsvColor, false);\n  }\n  drawHueSlider() {\n    const context = this.hueSliderRenderingContext;\n    const { staticDimensions: { slider: { height }, thumb: { radius: thumbRadius } } } = this;\n    const x = 0;\n    const y = thumbRadius - height / 2;\n    const width = this.effectiveSliderWidth;\n    const gradient = context.createLinearGradient(0, 0, width, 0);\n    const hueSliderColorStopKeywords = [\n      \"red\",\n      \"yellow\",\n      \"lime\",\n      \"cyan\",\n      \"blue\",\n      \"magenta\",\n      \"#ff0004\"\n    ];\n    const offset = 1 / (hueSliderColorStopKeywords.length - 1);\n    let currentOffset = 0;\n    hueSliderColorStopKeywords.forEach((keyword) => {\n      gradient.addColorStop(currentOffset, Color(keyword).string());\n      currentOffset += offset;\n    });\n    context.clearRect(0, 0, width, height + this.getSliderCapSpacing() * 2);\n    this.drawSliderPath(context, height, width, x, y);\n    context.fillStyle = gradient;\n    context.fill();\n    context.strokeStyle = \"rgba(0,0,0,0.3)\";\n    context.lineWidth = 1;\n    context.stroke();\n    this.drawActiveHueSliderColor();\n  }\n  drawOpacitySlider() {\n    const context = this.opacitySliderRenderingContext;\n    const { baseColorFieldColor: previousColor, staticDimensions: { slider: { height }, thumb: { radius: thumbRadius } } } = this;\n    const x = 0;\n    const y = thumbRadius - height / 2;\n    const width = this.effectiveSliderWidth;\n    context.clearRect(0, 0, width, height + this.getSliderCapSpacing() * 2);\n    const gradient = context.createLinearGradient(0, y, width, 0);\n    const startColor = previousColor.rgb().alpha(0);\n    const midColor = previousColor.rgb().alpha(0.5);\n    const endColor = previousColor.rgb().alpha(1);\n    gradient.addColorStop(0, startColor.string());\n    gradient.addColorStop(0.5, midColor.string());\n    gradient.addColorStop(1, endColor.string());\n    this.drawSliderPath(context, height, width, x, y);\n    const pattern = context.createPattern(this.getCheckeredBackgroundPattern(), \"repeat\");\n    context.fillStyle = pattern;\n    context.fill();\n    context.fillStyle = gradient;\n    context.fill();\n    context.strokeStyle = \"rgba(0,0,0,0.3)\";\n    context.lineWidth = 1;\n    context.stroke();\n    this.drawActiveOpacitySliderColor();\n  }\n  drawSliderPath(context, height, width, x, y) {\n    const radius = height / 2 + 1;\n    context.beginPath();\n    context.moveTo(x + radius, y);\n    context.lineTo(x + width - radius, y);\n    context.quadraticCurveTo(x + width, y, x + width, y + radius);\n    context.lineTo(x + width, y + height - radius);\n    context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n    context.lineTo(x + radius, y + height);\n    context.quadraticCurveTo(x, y + height, x, y + height - radius);\n    context.lineTo(x, y + radius);\n    context.quadraticCurveTo(x, y, x + radius, y);\n    context.closePath();\n  }\n  getCheckeredBackgroundPattern() {\n    if (this.checkerPattern) {\n      return this.checkerPattern;\n    }\n    const pattern = document.createElement(\"canvas\");\n    pattern.width = 10;\n    pattern.height = 10;\n    const patternContext = pattern.getContext(\"2d\");\n    patternContext.fillStyle = \"#ccc\";\n    patternContext.fillRect(0, 0, 10, 10);\n    patternContext.fillStyle = \"#fff\";\n    patternContext.fillRect(0, 0, 5, 5);\n    patternContext.fillRect(5, 5, 5, 5);\n    this.checkerPattern = pattern;\n    return pattern;\n  }\n  drawActiveOpacitySliderColor() {\n    const { color } = this;\n    if (!color) {\n      return;\n    }\n    const hsvColor = color;\n    const { staticDimensions: { thumb: { radius } } } = this;\n    const width = this.effectiveSliderWidth;\n    const x = alphaToOpacity(hsvColor.alpha()) / (OPACITY_LIMITS.max / width);\n    const y = radius;\n    const sliderBoundX = this.getSliderBoundX(x, width, radius);\n    requestAnimationFrame(() => {\n      this.opacityScopeLeft = sliderBoundX;\n    });\n    this.drawThumb(this.opacitySliderRenderingContext, radius, sliderBoundX, y, hsvColor, true);\n  }\n  getSliderBoundX(x, width, radius) {\n    const closeToEdge = closeToRangeEdge(x, width, radius);\n    return closeToEdge === 0 ? x : closeToEdge === -1 ? remap(x, 0, width, radius, radius * 2) : remap(x, 0, width, width - radius * 2, width - radius);\n  }\n  storeOpacityScope(node) {\n    this.opacityScopeNode = node;\n  }\n  handleOpacityScopeKeyDown(event) {\n    const modifier = event.shiftKey ? 10 : 1;\n    const { key } = event;\n    const arrowKeyToXOffset = {\n      ArrowUp: 0.01,\n      ArrowRight: 0.01,\n      ArrowDown: -0.01,\n      ArrowLeft: -0.01\n    };\n    if (arrowKeyToXOffset[key]) {\n      event.preventDefault();\n      const delta = arrowKeyToXOffset[key] * modifier;\n      const alpha = this.baseColorFieldColor.alpha();\n      const color = this.baseColorFieldColor.alpha(alpha + delta);\n      this.internalColorSet(color, false);\n    }\n  }\n  updateColorFromChannels(channels) {\n    this.internalColorSet(Color(channels, this.channelMode));\n  }\n  updateChannelsFromColor(color) {\n    this.channels = color ? this.toChannels(color) : [null, null, null, null];\n  }\n  toChannels(color) {\n    const { channelMode } = this;\n    const channels = color[channelMode]().array().map((value, index) => {\n      const isAlpha = index === 3;\n      return isAlpha ? value : Math.floor(value);\n    });\n    if (channels.length === 3) {\n      channels.push(1);\n    }\n    return channels;\n  }\n  getAdjustedScopePosition(left, top) {\n    return [left - SCOPE_SIZE / 2, top - SCOPE_SIZE / 2];\n  }\n  render() {\n    const { channelsDisabled, color, colorFieldScopeLeft, colorFieldScopeTop, staticDimensions: { thumb: { radius: thumbRadius } }, hexDisabled, hueScopeLeft, messages, alphaChannel, opacityScopeLeft, savedColors, savedDisabled, scale, scopeOrientation } = this;\n    const sliderWidth = this.effectiveSliderWidth;\n    const selectedColorInHex = color ? hexify(color, alphaChannel) : null;\n    const hueTop = thumbRadius;\n    const hueLeft = hueScopeLeft ?? sliderWidth * DEFAULT_COLOR.hue() / HSV_LIMITS.h;\n    const opacityTop = thumbRadius;\n    const opacityLeft = opacityScopeLeft ?? sliderWidth * alphaToOpacity(DEFAULT_COLOR.alpha()) / OPACITY_LIMITS.max;\n    const noColor = color === void 0;\n    const vertical = scopeOrientation === \"vertical\";\n    const [adjustedColorFieldScopeLeft, adjustedColorFieldScopeTop] = this.getAdjustedScopePosition(colorFieldScopeLeft, colorFieldScopeTop);\n    const [adjustedHueScopeLeft, adjustedHueScopeTop] = this.getAdjustedScopePosition(hueLeft, hueTop);\n    const [adjustedOpacityScopeLeft, adjustedOpacityScopeTop] = this.getAdjustedScopePosition(opacityLeft, opacityTop);\n    return InteractiveContainer({ disabled: this.disabled, children: html`<div class=${safeClassMap(CSS.container)}><div class=${safeClassMap(CSS.controlAndScope)}><canvas class=${safeClassMap(CSS.colorField)} @pointerdown=${this.handleColorFieldPointerDown} ${ref(this.initColorField)}></canvas><div .ariaLabel=${vertical ? messages.value : messages.saturation} .ariaValueMax=${vertical ? HSV_LIMITS.v : HSV_LIMITS.s} aria-valuemin=0 .ariaValueNow=${(vertical ? color?.saturationv() : color?.value()) || \"0\"} class=${safeClassMap({ [CSS.scope]: true, [CSS.colorFieldScope]: true })} @keydown=${this.handleColorFieldScopeKeyDown} role=slider style=${safeStyleMap({\n      top: `${adjustedColorFieldScopeTop || 0}px`,\n      left: `${adjustedColorFieldScopeLeft || 0}px`\n    })} tabindex=0 ${ref(this.storeColorFieldScope)}></div></div><div class=${safeClassMap(CSS.previewAndSliders)}><calcite-color-picker-swatch class=${safeClassMap(CSS.preview)} .color=${selectedColorInHex} .scale=${this.alphaChannel ? \"l\" : this.scale}></calcite-color-picker-swatch><div class=${safeClassMap(CSS.sliders)}><div class=${safeClassMap(CSS.controlAndScope)}><canvas class=${safeClassMap({ [CSS.slider]: true, [CSS.hueSlider]: true })} @pointerdown=${this.handleHueSliderPointerDown} ${ref(this.initHueSlider)}></canvas><div .ariaLabel=${messages.hue} .ariaValueMax=${HSV_LIMITS.h} aria-valuemin=0 .ariaValueNow=${color?.round().hue() || DEFAULT_COLOR.round().hue()} class=${safeClassMap({ [CSS.scope]: true, [CSS.hueScope]: true })} @keydown=${this.handleHueScopeKeyDown} role=slider style=${safeStyleMap({\n      top: `${adjustedHueScopeTop}px`,\n      left: `${adjustedHueScopeLeft}px`\n    })} tabindex=0 ${ref(this.storeHueScope)}></div></div>${alphaChannel ? html`<div class=${safeClassMap(CSS.controlAndScope)}><canvas class=${safeClassMap({ [CSS.slider]: true, [CSS.opacitySlider]: true })} @pointerdown=${this.handleOpacitySliderPointerDown} ${ref(this.initOpacitySlider)}></canvas><div .ariaLabel=${messages.opacity} .ariaValueMax=${OPACITY_LIMITS.max} .ariaValueMin=${OPACITY_LIMITS.min} .ariaValueNow=${(color || DEFAULT_COLOR).round().alpha()} class=${safeClassMap({ [CSS.scope]: true, [CSS.opacityScope]: true })} @keydown=${this.handleOpacityScopeKeyDown} role=slider style=${safeStyleMap({\n      top: `${adjustedOpacityScopeTop}px`,\n      left: `${adjustedOpacityScopeLeft}px`\n    })} tabindex=0 ${ref(this.storeOpacityScope)}></div></div>` : null}</div></div>${hexDisabled && channelsDisabled ? null : html`<div class=${safeClassMap({\n      [CSS.controlSection]: true,\n      [CSS.section]: true\n    })}><div class=${safeClassMap(CSS.hexAndChannelsGroup)}>${hexDisabled ? null : html`<div class=${safeClassMap(CSS.hexOptions)}><calcite-color-picker-hex-input .allowEmpty=${this.isClearable} .alphaChannel=${alphaChannel} class=${safeClassMap(CSS.control)} .messages=${messages} .numberingSystem=${this.numberingSystem} @calciteColorPickerHexInputChange=${this.handleHexInputChange} .scale=${scale} .value=${selectedColorInHex}></calcite-color-picker-hex-input></div>`}${channelsDisabled ? null : html`<calcite-tabs class=${safeClassMap({\n      [CSS.colorModeContainer]: true,\n      [CSS.splitSection]: true\n    })} .scale=${scale === \"l\" ? \"m\" : \"s\"}><calcite-tab-nav slot=title-group>${this.renderChannelsTabTitle(\"rgb\")}${this.renderChannelsTabTitle(\"hsv\")}</calcite-tab-nav>${this.renderChannelsTab(\"rgb\")}${this.renderChannelsTab(\"hsv\")}</calcite-tabs>`}</div></div>`}${savedDisabled ? null : html`<div class=${safeClassMap({ [CSS.savedColorsSection]: true, [CSS.section]: true })}><div class=${safeClassMap(CSS.header)}><label>${messages.saved}</label><div class=${safeClassMap(CSS.savedColorsButtons)}><calcite-button appearance=transparent class=${safeClassMap(CSS.deleteColor)} .disabled=${noColor} icon-start=minus kind=neutral .label=${messages.deleteColor} @click=${this.deleteColor} .scale=${scale} type=button></calcite-button><calcite-button appearance=transparent class=${safeClassMap(CSS.saveColor)} .disabled=${noColor} icon-start=plus kind=neutral .label=${messages.saveColor} @click=${this.saveColor} .scale=${scale} type=button></calcite-button></div></div>${savedColors.length > 0 ? html`<div class=${safeClassMap(CSS.savedColors)}>${repeat(savedColors, (color2) => color2, (color2) => html`<calcite-color-picker-swatch class=${safeClassMap(CSS.savedColor)} .color=${color2} @click=${this.handleSavedColorSelect} @keydown=${this.handleSavedColorKeyDown} .scale=${scale} tabindex=0></calcite-color-picker-swatch>`)}</div>` : null}</div>`}</div>` });\n  }\n  renderChannelsTabTitle(channelMode) {\n    const { channelMode: activeChannelMode, messages } = this;\n    const selected = channelMode === activeChannelMode;\n    const label = channelMode === \"rgb\" ? messages.rgb : messages.hsv;\n    return keyed(channelMode, html`<calcite-tab-title class=${safeClassMap(CSS.colorMode)} data-color-mode=${channelMode ?? nothing} @calciteTabsActivate=${this.handleTabActivate} .selected=${selected}>${label}</calcite-tab-title>`);\n  }\n  renderChannelsTab(channelMode) {\n    const { isClearable, channelMode: activeChannelMode, channels, messages, alphaChannel } = this;\n    const selected = channelMode === activeChannelMode;\n    const isRgb = channelMode === \"rgb\";\n    const channelAriaLabels = isRgb ? [messages.red, messages.green, messages.blue] : [messages.hue, messages.saturation, messages.value];\n    const direction = getElementDir(this.el);\n    const channelsToRender = alphaChannel ? channels : channels.slice(0, 3);\n    return keyed(channelMode, html`<calcite-tab class=${safeClassMap(CSS.control)} .selected=${selected}><div class=${safeClassMap(CSS.channels)} dir=ltr>${channelsToRender.map((channelValue, index) => {\n      const isAlphaChannel = index === 3;\n      if (isAlphaChannel) {\n        channelValue = isClearable && !channelValue ? channelValue : alphaToOpacity(channelValue);\n      }\n      return this.renderChannel(channelValue, index, channelAriaLabels[index], direction, isAlphaChannel ? \"%\" : \"\");\n    })}</div></calcite-tab>`);\n  }\n  renderChannel(value, index, ariaLabel, direction, suffix) {\n    return keyed(index, html`<calcite-input-number class=${safeClassMap(CSS.channel)} data-channel-index=${index ?? nothing} dir=${direction ?? nothing} .label=${ariaLabel} lang=${this.messages._lang ?? nothing} number-button-type=none .numberingSystem=${this.numberingSystem} @keydown=${this.handleKeyDown} @calciteInputNumberChange=${this.handleChannelChange} @calciteInputNumberInput=${this.handleChannelInput} @calciteInternalInputNumberBlur=${this.handleChannelBlur} @calciteInternalInputNumberFocus=${this.handleChannelFocus} .scale=${this.scale === \"l\" ? \"m\" : \"s\"} style=${safeStyleMap({\n      marginLeft: index > 0 && !(this.scale === \"s\" && this.alphaChannel && index === 3) ? \"-1px\" : \"\"\n    })} .suffixText=${suffix} .value=${value?.toString()}></calcite-input-number>`);\n  }\n}\ncustomElement(\"calcite-color-picker\", ColorPicker);\nexport {\n  ColorPicker\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  ChildPart,\n  DirectiveParameters,\n} from '../directive.js';\nimport {setCommittedValue} from '../directive-helpers.js';\n\nclass Keyed extends Directive {\n  key: unknown = nothing;\n\n  render(k: unknown, v: unknown) {\n    this.key = k;\n    return v;\n  }\n\n  override update(part: ChildPart, [k, v]: DirectiveParameters<this>) {\n    if (k !== this.key) {\n      // Clear the part before returning a value. The one-arg form of\n      // setCommittedValue sets the value to a sentinel which forces a\n      // commit the next render.\n      setCommittedValue(part);\n      this.key = k;\n    }\n    return v;\n  }\n}\n\n/**\n * Associates a renderable value with a unique key. When the key changes, the\n * previous DOM is removed and disposed before rendering the next value, even\n * if the value - such as a template - is the same.\n *\n * This is useful for forcing re-renders of stateful components, or working\n * with code that expects new data to generate new HTML elements, such as some\n * animation techniques.\n */\nexport const keyed = directive(Keyed);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {Keyed};\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n"],"names":["clamp","value","min","max","Math","decimalNumberRegex","RegExp","decimalPlaces","match","parseInt","length","getDecimals","parseFloat","toString","split","remap","fromMin","fromMax","toMin","toMax","closeToRangeEdge","range","threshold","styles","css","ColorPicker","LitElement","constructor","super","this","_color","DEFAULT_COLOR","internalColorUpdateContext","isActiveChannelInputEmpty","mode","CSSColorMode","HEX","resizeObserver","createObserver","entries","resizeCanvas","shiftKeyChannelAdjustment","upOrDownArrowKeyTracker","_valueWasSet","messages","useT9n","blocking","captureColorFieldColor","x","y","skipEqual","width","height","dynamicDimensions","colorField","saturation","round","HSV_LIMITS","s","v","internalColorSet","baseColorFieldColor","hsv","saturationv","drawColorControls","throttle","type","colorFieldRenderingContext","drawColorField","hueSliderRenderingContext","drawHueSlider","alphaChannel","opacitySliderRenderingContext","drawOpacitySlider","globalPointerMoveHandler","event","activeCanvasInfo","el","isConnected","context","bounds","samplingX","samplingY","clientX","clientY","canvas","matches","captureHueSliderColor","captureOpacitySliderValue","globalPointerUpHandler","isPrimaryPointerButton","previouslyDragging","calciteColorPickerChange","emit","hasUpdated","first","availableWidth","floor","contentBoxSize","inlineSize","updateDynamicDimensions","updateCanvasSize","sliderDims","getSliderWidth","staticDimensions","slider","getColorFieldDimensions","channelMode","channels","toChannels","STATIC_DIMENSIONS","m","savedColors","allowEmpty","channelsDisabled","clearable","disabled","format","hexDisabled","savedDisabled","scale","createEvent","cancelable","calciteColorPickerInput","listen","handleChannelKeyUpOrDown","capture","properties","state","colorFieldScopeLeft","colorFieldScopeTop","hueScopeLeft","opacityScopeLeft","scopeOrientation","reflect","Boolean","color","attribute","messageOverrides","numberingSystem","storageId","oldColor","handleColorChange","_value","oldValue","handleValueChange","setFocus","componentFocusable","focusFirstTabbable","connectedCallback","observeResize","load","normalizeHex","hexify","handleAllowEmptyOrClearableChange","isClearable","willSetNoColor","parsedMode","parseMode","valueIsCompatible","initialColor","Color","showIncompatibleColorWarning","setMode","updateStaticDimensions","minWidth","storageKey","DEFAULT_STORAGE_KEY_PREFIX","localStorage","getItem","JSON","parse","willUpdate","changes","has","handleAlphaChannelChange","handleAlphaChannelDimensionsChange","handleFormatOrAlphaChannelChange","handleScaleChange","updated","updateHostInteraction","loaded","disconnectedCallback","window","removeEventListener","disconnect","previousColor","effectiveSliderWidth","observe","alphaCompatible","console","warn","updateChannelsFromColor","modeChanged","nextMode","dragging","normalizeColor","colorChanged","colorEqual","endsWith","handleTabActivate","currentTarget","getAttribute","handleColorFieldScopeKeyDown","key","arrowKeyToXYOffset","ArrowUp","ArrowRight","ArrowDown","ArrowLeft","preventDefault","handleHueScopeKeyDown","modifier","shiftKey","arrowKeyToXOffset","delta","hue","handleHexInputChange","stopPropagation","hex","target","handleSavedColorSelect","swatch","handleChannelInput","input","channelIndex","Number","limit","OPACITY_LIMITS","RGB_LIMITS","Object","keys","inputValue","adjustedValue","handleChannelChange","handleChannelBlur","handleChannelFocus","selectText","composedPath","some","node","classList","contains","CSS","channel","getChannelInputLimit","isAlphaChannel","opacityToAlpha","updateColorFromChannels","handleSavedColorKeyDown","isActivationKey","handleColorFieldPointerDown","handleCanvasControlPointerDown","colorFieldScopeNode","focusScope","focusEl","requestAnimationFrame","focus","handleHueSliderPointerDown","hueScopeNode","handleOpacitySliderPointerDown","opacityScopeNode","renderingContext","captureValue","scopeNode","addEventListener","once","getBoundingClientRect","call","offsetX","offsetY","storeColorFieldScope","storeHueScope","handleKeyDown","ensureCompatibleMode","isAlphaCompatible","alphaMode","toAlphaMode","nonAlphaMode","toNonAlphaMode","HUE_LIMIT_CONSTRAINED","alpha","toValue","includes","hasAlpha","HEXA","replace","string","slice","colorObject","object","normalizeAlpha","getSliderCapSpacing","thumb","radius","deleteColor","colorToDelete","indexOf","filter","setItem","stringify","saveColor","colorToSave","fillStyle","fillRect","whiteGradient","createLinearGradient","addColorStop","blackGradient","drawActiveColorFieldColor","setCanvasContextSize","devicePixelRatio","style","getContext","initColorField","initHueSlider","initOpacitySlider","adjustedSliderDimensions","hsvColor","drawThumb","applyAlpha","endAngle","PI","beginPath","arc","fill","strokeStyle","lineWidth","stroke","pattern","createPattern","getCheckeredBackgroundPattern","globalCompositeOperation","rgb","drawActiveHueSliderColor","sliderBoundX","getSliderBoundX","thumbRadius","gradient","hueSliderColorStopKeywords","offset","currentOffset","forEach","keyword","clearRect","drawSliderPath","startColor","midColor","endColor","drawActiveOpacitySliderColor","moveTo","lineTo","quadraticCurveTo","closePath","checkerPattern","document","createElement","patternContext","alphaToOpacity","closeToEdge","storeOpacityScope","handleOpacityScopeKeyDown","array","map","index","push","getAdjustedScopePosition","left","top","SCOPE_SIZE","render","sliderWidth","selectedColorInHex","hueTop","hueLeft","h","opacityTop","opacityLeft","noColor","vertical","adjustedColorFieldScopeLeft","adjustedColorFieldScopeTop","adjustedHueScopeLeft","adjustedHueScopeTop","adjustedOpacityScopeLeft","adjustedOpacityScopeTop","InteractiveContainer","children","html","safeClassMap","container","controlAndScope","ref","scope","colorFieldScope","safeStyleMap","previewAndSliders","preview","sliders","hueSlider","hueScope","opacitySlider","opacity","opacityScope","controlSection","section","hexAndChannelsGroup","hexOptions","control","colorModeContainer","splitSection","renderChannelsTabTitle","renderChannelsTab","savedColorsSection","header","saved","savedColorsButtons","repeat","color2","savedColor","activeChannelMode","selected","label","keyed","colorMode","nothing","channelAriaLabels","red","green","blue","direction","getElementDir","channelsToRender","channelValue","renderChannel","ariaLabel","suffix","_lang","marginLeft","customElement","i","t","e","arguments","r","update","u","generateMap","Map","l","set","c","CHILD","Error","dt","o","values","d","p","a","Array","isArray","ut","j","k","w","get","n","f"],"sourceRoot":""}