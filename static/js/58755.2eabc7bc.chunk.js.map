{"version":3,"file":"static/js/58755.2eabc7bc.chunk.js","mappings":"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","sources":["../node_modules/timezone-groups/dist/groupByOffset/index.mjs","../node_modules/timezone-groups/dist/utils/region.mjs","../node_modules/timezone-groups/dist/utils/time-zones.mjs"],"sourcesContent":["import { timeZones } from '../utils/time-zones.mjs';\nimport { extractRegion, global } from '../utils/region.mjs';\nimport '../chunks/index-p4VH55K1.mjs';\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    groupDateRange,\n    startDate,\n};\n\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine) => {\n    const processedDates = new Map();\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const { label } = tzItem;\n        const continent = extractRegion(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: continent !== global,\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => extractRegion(label) !== global);\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupByOffset(options) {\n    const { groupDateRange, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = timeZones.map((tz) => ({ label: tz }));\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        tzMetadatumI.visited = true;\n        const newGroup = {\n            labelIdx: [],\n            tzs: [{ label }],\n        };\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    return grouping\n        .map((group) => {\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        return {\n            labelTzIdx: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n}\n\nexport { groupByOffset };\n","import { g as getCountryForTimezone, a as getTimezone } from '../chunks/index-p4VH55K1.mjs';\n\nconst global = 'Global';\n/**\n * Check if a timezone is global (no country associated).\n */\nfunction isGlobal(tz) {\n    return getTimezone(tz).countries.length === 0;\n}\n/**\n * Extract the region from a timezone.\n */\nfunction extractRegion(tz) {\n    if (isGlobal(tz)) {\n        return global;\n    }\n    const separatorIndex = tz.indexOf('/');\n    return separatorIndex === -1 ? tz : tz.slice(0, separatorIndex);\n}\n/**\n * Gets the country code for a timezone.\n */\nfunction getCountry(timeZone) {\n    return getCountryForTimezone(timeZone)?.id ?? timeZone;\n}\n\nexport { extractRegion, getCountry, global };\n","import { b as getAllTimezones, a as getTimezone } from '../chunks/index-p4VH55K1.mjs';\n\n/**\n * Handling these deprecated timezones locally until `countries-and-timezones` is updated with the latest IANA time zone db\n *\n * @see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\n * @see https://github.com/eggert/tz/commit/782d082623aaa130178d944bdbfbb563d2e1adfa\n * @see https://github.com/eggert/tz/commit/a0b09c0230089252acf2eb0f1ba922e99f7f4a03\n */\nconst deprecatedTimeZonesToAlias = {\n    /* eslint-disable @typescript-eslint/naming-convention */\n    CET: 'Europe/Brussels',\n    CST6CDT: 'America/Chicago',\n    EET: 'Europe/Athens',\n    EST: 'America/Panama',\n    EST5EDT: 'America/New_York',\n    HST: 'Pacific/Honolulu',\n    MET: 'Europe/Brussels',\n    MST: 'America/Phoenix',\n    MST7MDT: 'America/Denver',\n    PST8PDT: 'America/Los_Angeles',\n    WET: 'Europe/Lisbon',\n    /* eslint-enable @typescript-eslint/naming-convention */\n};\n/**\n * List of all supported, canonical, timezones.\n */\nconst timeZones = (() => {\n    const futureDeprecatedTimeZones = Object.keys(deprecatedTimeZonesToAlias);\n    return Object.keys(getAllTimezones()).filter((tz) => !futureDeprecatedTimeZones.includes(tz));\n})();\n/**\n * Normalize an IANA timezone name to its canonical equivalent.\n */\nfunction normalize(tz) {\n    const localDeprecatedTimeZone = deprecatedTimeZonesToAlias[tz];\n    if (localDeprecatedTimeZone) {\n        return localDeprecatedTimeZone;\n    }\n    const tzData = getTimezone(tz);\n    return tzData?.aliasOf ?? tz;\n}\n\nexport { normalize, timeZones };\n"],"names":["defaultGroupingOptions","groupDateRange","startDate","Date","toISOString","generateTimeZoneMetadata","timeZoneItems","numberDays","dateEngine","processedDates","Map","theDates","_getDates","dateArray","date","create","i","increase","push","formatToIsoDateString","map","tzItem","label","continent","extractRegion","dates","key","utc","get","isoToTimeZone","set","isRegularContinent","global","compareDateArrs","array1","array2","length","every","value","index","same","getGroupLabelTimeZoneIndices","rawTZs","max","shrinkedTzs","filter","items","maxItems","totalItems","numberItemsToSelect","Math","min","stepSize","Array","from","_","round","equallyDistributedSampling","tz","indexOf","async","groupByOffset","options","grouping","Error","timeZones","timeZoneMetadata","tzMetadatumI","visited","newGroup","labelIdx","tzs","tzMetadatumJ","labelJ","continentJ","isRegularContinentJ","datesJ","group","sort","a","b","localeCompare","labelTzIdx","getTimezone","countries","isGlobal","separatorIndex","slice","getCountry","timeZone","getCountryForTimezone","id","deprecatedTimeZonesToAlias","CET","CST6CDT","EET","EST","EST5EDT","HST","MET","MST","MST7MDT","PST8PDT","WET","futureDeprecatedTimeZones","Object","keys","getAllTimezones","includes","normalize","localDeprecatedTimeZone","tzData","aliasOf"],"sourceRoot":""}