{"version":3,"file":"static/js/47091.8ea8f988.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/esm/index-6d52eadc.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.9.2\n */\nconst supportedTimeZones = (() => {\n    const platformTimeZones = Intl.supportedValuesOf('timeZone');\n    // not all browsers include these time zones, so we add them to ensure consistent groups\n    const etcTimeZones = [\n        \"Etc/GMT+1\",\n        \"Etc/GMT+10\",\n        \"Etc/GMT+11\",\n        \"Etc/GMT+12\",\n        \"Etc/GMT+2\",\n        \"Etc/GMT+3\",\n        \"Etc/GMT+4\",\n        \"Etc/GMT+5\",\n        \"Etc/GMT+6\",\n        \"Etc/GMT+7\",\n        \"Etc/GMT+8\",\n        \"Etc/GMT+9\",\n        \"Etc/GMT-1\",\n        \"Etc/GMT-10\",\n        \"Etc/GMT-11\",\n        \"Etc/GMT-12\",\n        \"Etc/GMT-13\",\n        \"Etc/GMT-14\",\n        \"Etc/GMT-2\",\n        \"Etc/GMT-3\",\n        \"Etc/GMT-4\",\n        \"Etc/GMT-5\",\n        \"Etc/GMT-6\",\n        \"Etc/GMT-7\",\n        \"Etc/GMT-8\",\n        \"Etc/GMT-9\"\n    ];\n    return [...new Set([...platformTimeZones, ...etcTimeZones])];\n})();\n\nconst now = new Date();\nconst startDate = now.toISOString();\nconst daysInYear = 365;\nconst groupDateRange = daysInYear;\nconst defaultGroupingOptions = {\n    startDate,\n    groupDateRange,\n    debug: false,\n};\n\nconst continentAllowList = new Set([\n    'Europe',\n    'Asia',\n    'America',\n    'America/Argentina',\n    'Africa',\n    'Australia',\n    'Pacific',\n    'Atlantic',\n    'Antarctica',\n    'Arctic',\n    'Indian',\n]);\nconst _getDates = (startDate, numberDays, dateEngine) => {\n    const dateArray = [];\n    let date = dateEngine.create(startDate);\n    for (let i = 0; i <= numberDays; i++) {\n        date = dateEngine.increase(date);\n        dateArray.push(dateEngine.formatToIsoDateString(date));\n    }\n    return dateArray;\n};\nconst _extractContinent = (label) => {\n    if (label.includes('Istanbul')) {\n        return 'Europe';\n    }\n    const lastIndex = label.lastIndexOf('/');\n    return lastIndex === -1 ? label : label.slice(0, lastIndex);\n};\nconst _isRegularContinent = (continent) => continentAllowList.has(continent);\nconst generateTimeZoneMetadata = (timeZoneItems, startDate, numberDays, dateEngine, debug = false) => {\n    const processedDates = new Map();\n    if (debug) {\n        console.log(`Initializing data starting ${startDate} with ${numberDays} days in the future, comparing ${timeZoneItems.length} timezones`);\n    }\n    const theDates = _getDates(startDate, numberDays, dateEngine);\n    return timeZoneItems.map((tzItem) => {\n        const label = tzItem.label;\n        const continent = _extractContinent(label);\n        const dates = theDates.map((date) => {\n            const key = `${date}-${label}`;\n            let utc = processedDates.get(key);\n            if (utc) {\n                return utc;\n            }\n            utc = dateEngine.isoToTimeZone(date, label);\n            processedDates.set(key, utc);\n            return utc;\n        });\n        return {\n            ...tzItem,\n            continent,\n            isRegularContinent: _isRegularContinent(continent),\n            dates,\n        };\n    });\n};\nconst compareDateArrs = (array1, array2, dateEngine) => array1.length === array2.length &&\n    array1.every((value, index) => dateEngine.same(value, array2[index]));\nconst getGroupLabelTimeZoneIndices = (rawTZs, max = 5) => {\n    const shrinkedTzs = rawTZs.filter(({ label }) => _isRegularContinent(_extractContinent(label)));\n    if (shrinkedTzs.length === 0) {\n        return [0];\n    }\n    const validLabels = shrinkedTzs.map((tz) => rawTZs.indexOf(tz));\n    return equallyDistributedSampling(validLabels, max);\n};\nfunction equallyDistributedSampling(items, maxItems = 5) {\n    const totalItems = items.length;\n    if (totalItems <= maxItems) {\n        return items;\n    }\n    const numberItemsToSelect = Math.min(totalItems - 2, maxItems - 2);\n    const stepSize = (totalItems - 1) / (numberItemsToSelect + 1);\n    return [\n        items[0],\n        ...Array.from({ length: numberItemsToSelect }, (_, i) => items[Math.round((i + 1) * stepSize)]),\n        items[totalItems - 1],\n    ];\n}\n\nasync function groupTimeZones(options) {\n    const { debug, groupDateRange, hooks, startDate, dateEngine } = {\n        ...defaultGroupingOptions,\n        ...options,\n    };\n    const grouping = [];\n    if (!dateEngine) {\n        throw new Error('dateEngine is required');\n    }\n    const timeZoneItems = supportedTimeZones.map((tz) => ({ label: tz }));\n    hooks?.onBeforeTimeZoneMetadataCreate?.(timeZoneItems);\n    const timeZoneMetadata = generateTimeZoneMetadata(timeZoneItems, startDate, groupDateRange, dateEngine, debug);\n    hooks?.onTimeZoneMetadataCreate?.(timeZoneMetadata);\n    // We traverse the mappedDB and see if we find matches by comparing each set\n    // of transformed date for that specific TZ.\n    for (const tzMetadatumI of timeZoneMetadata) {\n        const { label, continent, dates } = tzMetadatumI;\n        // ignore if we visited this element already\n        if (tzMetadatumI.visited) {\n            continue;\n        }\n        // Mark element as already visited\n        tzMetadatumI.visited = true;\n        // The grouped timezone that we want as a result\n        const newGroup = {\n            labelTzIndices: undefined,\n            tzs: [{ label }],\n        };\n        hooks?.onGroupCreate?.(newGroup, tzMetadatumI);\n        for (const tzMetadatumJ of timeZoneMetadata.filter((_) => !_.visited)) {\n            const { label: labelJ, continent: continentJ, isRegularContinent: isRegularContinentJ, dates: datesJ, } = tzMetadatumJ;\n            // We define a matching TZ by:\n            // 1) if both continents match (avoid grouping Antarctica with anything else)\n            // 2) if the transformed dates match in both TZs\n            if ((continent === continentJ || !isRegularContinentJ) &&\n                compareDateArrs(dates, datesJ, dateEngine)) {\n                const tzItem = { label: labelJ };\n                newGroup.tzs.push(tzItem);\n                hooks?.onGroupTimeZoneAdd?.(newGroup, tzItem, tzMetadatumJ);\n                // Mark element as already visited\n                tzMetadatumJ.visited = true;\n            }\n        }\n        grouping.push(newGroup);\n        hooks?.onGroupAdd?.(newGroup);\n    }\n    // Now that we have a group, we want an easy way to find a fitting label for the group\n    // which is defined as the list of the most-common 7 cities, shown in alphabetical order\n    const finalGrouping = grouping\n        .map((group) => {\n        hooks?.onBeforeFinalGroupCreate?.(group);\n        group.tzs = group.tzs.sort((a, b) => a.label.localeCompare(b.label));\n        const finalGrouping = {\n            labelTzIndices: getGroupLabelTimeZoneIndices(group.tzs, 7),\n            tzs: group.tzs.map((_) => _.label),\n        };\n        hooks?.onFinalGroupCreate?.(finalGrouping, group);\n        return finalGrouping;\n    })\n        .sort((a, b) => b.tzs.length - a.tzs.length);\n    if (debug) {\n        const missingTzs = supportedTimeZones\n            .map((tz) => (finalGrouping.some((y) => y.tzs.includes(tz)) ? null : tz))\n            .filter(Boolean);\n        if (missingTzs.length > 0) {\n            throw new Error(`There are ${missingTzs.length} missing timezones: ${missingTzs.toString()}`);\n        }\n    }\n    return hooks?.onFinalGroupingCreate\n        ? hooks.onFinalGroupingCreate(finalGrouping)\n        : finalGrouping;\n}\n\nexport { groupTimeZones };\n"],"names":["supportedTimeZones","platformTimeZones","Intl","supportedValuesOf","Set","defaultGroupingOptions","startDate","Date","toISOString","groupDateRange","debug","continentAllowList","_getDates","numberDays","dateEngine","dateArray","date","create","i","increase","push","formatToIsoDateString","_extractContinent","label","includes","lastIndex","lastIndexOf","slice","_isRegularContinent","continent","has","compareDateArrs","array1","array2","length","every","value","index","same","getGroupLabelTimeZoneIndices","rawTZs","max","shrinkedTzs","filter","validLabels","map","tz","indexOf","equallyDistributedSampling","items","maxItems","totalItems","numberItemsToSelect","Math","min","stepSize","Array","from","_","round","async","groupTimeZones","options","hooks","grouping","Error","timeZoneItems","onBeforeTimeZoneMetadataCreate","timeZoneMetadata","processedDates","Map","console","log","theDates","tzItem","dates","key","utc","get","isoToTimeZone","set","isRegularContinent","generateTimeZoneMetadata","onTimeZoneMetadataCreate","tzMetadatumI","visited","newGroup","labelTzIndices","undefined","tzs","onGroupCreate","tzMetadatumJ","labelJ","continentJ","isRegularContinentJ","datesJ","onGroupTimeZoneAdd","onGroupAdd","finalGrouping","group","onBeforeFinalGroupCreate","sort","a","b","localeCompare","onFinalGroupCreate","missingTzs","some","y","Boolean","toString","onFinalGroupingCreate"],"sourceRoot":""}