"use strict";(globalThis.webpackChunkmy_app=globalThis.webpackChunkmy_app||[]).push([[7861],{6951:(e,t,n)=>{n.d(t,{Y7:()=>I,HS:()=>T,mm:()=>A,A:()=>N,k2:()=>S,ZA:()=>x,E8:()=>w,hF:()=>v,C5:()=>g,uK:()=>_,Pi:()=>b});var r=n(35143),i=(n(81806),n(76460)),s=n(88685),o=n(60984);function c(e,t,n){const r=t.split("\n");for(const i of r)if(i.trim().length){{let t="";null!=n&&(t+=`/*id:${n??"000"}*/   `),e.body+=t.padEnd(14)}e.body+=" ".repeat(e.indent)+i+"\n"}}class a{write(e){for(const t of e.rootOutputNodes())e.shouldPruneOutputNode(t)||(t.variableName=this._write(e,t.node));return e}_createVarName(e,t){let n="";return"boolean"!=typeof t&&"number"!=typeof t&&t.debugInfo.name&&(n=`${t.debugInfo.name}_`),`${n}v${e.varCount++}`}_write(e,t,n=!1){if("number"==typeof t)return t.toString();if("boolean"==typeof t)return t.toString();let r=e.getEmit(t);if(r)return r;switch(t.shaderType){case"scope-node":r=this._writeScopeNode(e,t);break;case"primitive-node":r=this._writePrimitiveNode(e,t,n);break;case"function-node":r=this._writeFunctionNode(e,t);break;case"property-access-node":r=this._writePropertyAccessNode(e,t);break;case"property-access-2d-node":r=this._writePropertyAccess2DNode(e,t);break;case"text-node":r=t.text;break;case"block-node":r=this._writeBlockNode(e,t);break;case"condition-node":r=this._writeConditionNode(e,t)}return e.setEmit(t,r),r}_writeScopeNode(e,t){const n=new t.child.constructor;n.setDebugName(t.debugInfo.name);const r=this._write(e,n,!0);return c(e,`{ /*ScopeStart: ${t.uid} ${t.debugInfo.name}*/`),e.indent+=2,c(e,`${r} = ${this._write(e,t.child)};`),e.indent-=2,c(e,`} /*ScopeEnd: ${t.uid} ${t.debugInfo.name}*/`),r}_writeConditionNode(e,t){const n=new t.ifTrue.constructor,r=this._write(e,n,!0);c(e,`if (${this._write(e,t.condition)}) {`),e.indent+=2;const i=e.createSubgraphContext(),s=this._write(i,t.ifTrue);if(e.body+=i.body,s&&c(e,`${r} = ${s};`),e.indent-=2,c(e,"}"),t.ifFalse){c(e,"else {"),e.indent+=2;const n=e.createSubgraphContext(),i=this._write(n,t.ifFalse);e.body+=n.body,i&&c(e,`${r} = ${i};`),e.indent-=2,c(e,"}")}return r}_writeBlockNode(e,t){const{captureList:n,generator:r,returnType:i}=t,s={};for(const c in n){if(!n[c])continue;const t=this._write(e,n[c]);s[c]=t}const o=new i,a=this._write(e,o,!0);if(s.out=a,t.subgraph){const n=e.createSubgraphContext(),r=this._write(n,t.subgraph.child),i=n.body;s.subgraph={varName:r,body:i}}const u=r(s);return c(e,"{\n"),e.indent+=2,c(e,u),e.indent-=2,c(e,"}\n"),a}_writePropertyAccessNode(e,t){const n=this._write(e,t.target);return"string"==typeof t.property&&t.property.includes("[")?`${n}${t.property}`:"string"!=typeof t.property?`${n}[${this._write(e,t.property)}]`:`${n}.${t.property}`}_writePropertyAccess2DNode(e,t){return`${this._write(e,t.target)}[${this._write(e,t.x)}][${this._write(e,t.y)}]`}_writeFunctionNode(e,t){const n=t.returnType.type;if(t.isInfix){const[r,i]=t.children.map((t=>this._write(e,t))),s=this._createVarName(e,t);return c(e,`${n.padEnd(5)} ${s} = ${r} ${t.token} ${i};`,t.uid),s}const r=t.children.map((t=>this._write(e,t))).join(", "),i=this._createVarName(e,t);return c(e,`${n.padEnd(5)} ${i} = ${t.token}(${r});`,t.uid),i}_writePrimitiveNode(e,t,n=!1){const r=e.getInput(t);if(r)return r.isUsed=!0,r.variableName;const i=1===t.children.length&&t.children[0]?.type===t.type;if(!t.isMutable&&(t.isImplicit||i))return this._write(e,t.children[0]);const s=this._createVarName(e,t);if(n)return c(e,`${t.type.padEnd(5)} ${s};`,t.uid),s;const o=!t.debugInfo.name&&!t.isMutable;if(o&&"float"===t.type&&"number"==typeof t.children[0])return Number.isInteger(t.children[0])?t.children[0].toFixed(1):t.children[0].toString();if(o&&"int"===t.type&&"number"==typeof t.children[0]&&Number.isInteger(t.children[0]))return t.children[0].toString();const a=t.children.map((t=>this._write(e,t))).join(", ");return"array"===t.type?(c(e,`${t.type.padEnd(5)} ${s} = [${a}];`,t.uid),s):o?`${t.type}(${a})`:(c(e,`${t.type.padEnd(5)} ${s} = ${t.type}(${a});`,t.uid),s)}}var u=n(22881);class h{constructor(e,t,n){this.variableName=e,this.variableInputType=t,this.node=n,this.type="shader-input",this.isUsed=!1}clone(){return new h(this.variableName,this.variableInputType,(0,u.vA)(this.node))}}class d{constructor(e,t,n){this.outVariableName=e,this.outVariableType=t,this.node=n,this.type="shader-output"}clone(){const e=new d(this.outVariableName,this.outVariableType,(0,u.vA)(this.node));return e.variableName=this.variableName,e}}class l{static createVertex(e,t,n,r,i,s){const o=[];for(const a in e){const t=e[a],r=n.get(a);r?o.push(new h(r,"builtin",t)):o.push(new h("a_"+a,"in",t))}for(const a of r){const e=a.uniformHydrated;o.push(new h(a.uniformName,"uniform",e))}const c=[];for(const a in t){const e=t[a];"glPosition"===a?c.push(new d("gl_Position","builtin",e)):"glPointSize"===a?c.push(new d("gl_PointSize","builtin",e)):c.push(new d("v_"+a,"out",e))}return new l(o,c,i,s)}static createFragment(e,t,n,r,i,s){const o=[],c=Array.from(i.rootOutputNodes());for(const u in e){const t=e[u],r=n.get(u);if(r){o.push(new h(r,"builtin",t));continue}const i=c.find((e=>e.node===t));i&&o.push(new h(i.outVariableName,"in",t))}for(const u of r){const e=u.uniformHydrated;o.push(new h(u.uniformName,"uniform",e))}const a=[];for(const u in t){const e=t[u],r=n.get(u);"discard"===u?a.push(new d(null,"discard",e)):r?a.push(new d(r,"builtin",e)):a.push(new d(u,"out",e))}return new l(o,a,s)}constructor(e,t,n,r){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const i of e)this._inputShaderTypesByNodeUid.set(i.node.uid,i);this._outputShaderTypes=t,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map((e=>"v_"+e.propertyKey))),this._usedInFragmentShader=r}shouldPruneOutputNode(e){return!!this._usedInFragmentShader&&"builtin"!==e.outVariableType&&!this._transformFeedbackNames.has(e.outVariableName)&&!this._usedInFragmentShader.has(e.node.uid)}setEmit(e,t){this._nodeEmitMap.set(e.uid,t)}getEmit(e){return this._nodeEmitMap.get(e.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(e){return this._inputShaderTypesByNodeUid.get(e.uid)}*rootOutputNodes(){for(const e of this._outputShaderTypes)yield e}*nodes(){const e=[];for(const t of this._outputShaderTypes.values())e.push(t.node);for(;e.length;){const t=e.pop();"number"!=typeof t&&"boolean"!=typeof t&&e.push(...t.children.filter(Boolean)),yield t}}*nodesOfTypeOrFunction(){for(const e of this.nodes())"number"!=typeof e&&"boolean"!=typeof e&&(yield e)}createSubgraphContext(){const e=this.clone();return e.body="",e.indent=this.indent+2,e._nodeEmitMap=new Map(this._nodeEmitMap),e}clone(){const e=new l([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return e._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,e.indent=this.indent,e.body=this.body,e.varCount=this.varCount,e._nodeEmitMap=this._nodeEmitMap,e}insertVertexShader(e){e.vertex.code.add(""),this._insertInputs(e,"vertex"),e.vertex.code.add(""),e.vertex.code.add("// OUTPUTS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this.rootOutputNodes()){const n="builtin"===t.outVariableType;this.shouldPruneOutputNode(t)||(n?e.vertex.code.add(`// ${t.outVariableType.padEnd(7)} ${t.node.type.padEnd(9)} ${t.outVariableName};`):e.vertex.code.add(`${t.outVariableType.padEnd(10)} ${t.node.type.padEnd(9)} ${t.outVariableName};`))}e.vertex.code.add(""),e.vertex.code.add("void main() {"),e.vertex.code.add("  "+this.body.split("\n").join("\n  "));for(const t of this.rootOutputNodes())this.shouldPruneOutputNode(t)||e.vertex.code.add(`  ${t.outVariableName} = ${t.variableName};`);e.vertex.code.add("}")}insertFragmentShader(e){this._insertInputs(e,"fragment"),e.fragment.code.add(""),e.fragment.code.add("// OUTPUTS: "),e.fragment.code.add("// --------------------------------------------------------- ");let t=0;for(const n of this.rootOutputNodes())"builtin"===n.outVariableType?e.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):e.outputs.add(n.outVariableName,n.node.type,t++);e.fragment.code.add(""),e.fragment.code.add("void main() {"),e.fragment.code.add("  "+this.body.split("\n").join("\n  "));for(const n of this.rootOutputNodes())"discard"===n.outVariableType?(e.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),e.fragment.code.add(`  if (${n.variableName}) {`),e.fragment.code.add("    discard;"),e.fragment.code.add("  }"),e.fragment.code.add("  ")):e.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);e.fragment.code.add("}")}_insertInputs(e,t){e[t].code.add("// INPUTS: "),e[t].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())n.isUsed&&"builtin"!==n.variableInputType&&("array"===n.node.type?e[t].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`):"array-2d"===n.node.type?e[t].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):e[t].code.add(`${n.variableInputType.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`))}}var p=n(99943),f=n(2687);function y(e){return new e}function m(e,t,n){const r=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:r.slice()}),e.constructor[t].push(n)}function g(e,t){return(n,r)=>{m(n,"locations",{typeCtor:t,propertyKey:r,parameterIndex:null,index:e})}}const v=e=>(t,n,r)=>{m(t,"inputs",{inputCtor:e,propertyKey:n,parameterIndex:r})},b=e=>(t,n)=>{m(t,"uniforms",{typeCtor:e,propertyKey:n})},_=e=>(t,n)=>{m(t,"options",{typeCtor:e,propertyKey:n})},w=(e,t)=>{m(e,"defines",{propertyKey:t})};const $=(e,t)=>(n,r)=>{n.constructor.builtins.push({builtin:e,propertyKey:r,typeCtor:t})};class x{}x.builtins=[],(0,r._)([$("gl_VertexID",o.Ai)],x.prototype,"glVertexID",void 0);class I{}class T{}T.builtins=[],(0,r._)([$("gl_FragCoord",o.Zb)],T.prototype,"glFragCoord",void 0),(0,r._)([$("gl_PointCoord",o.ZY)],T.prototype,"glPointCoord",void 0);class A{}(0,r._)([(e=>(t,n)=>{m(t,"builtins",{builtin:e,propertyKey:n})})("gl_FragDepth")],A.prototype,"glFragDepth",void 0);class S{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class N{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast((e=>"vertex"===e.propertyKey&&0===e.parameterIndex));if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast((e=>"vertex"===e.propertyKey&&1===e.parameterIndex))}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast((e=>"fragment"===e.propertyKey));if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const e=new Map,t=new Set;for(const n of this.locations)t.has(n.index)?i.A.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${n.propertyKey} to ${n.index}. Index already in use`,{locationsMap:e}):(e.set(n.propertyKey,n.index),t.add(n.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map((([e,t])=>`${e}.${t}`)).join("."),n=(0,s.Wm)(t),r=this.computeAttributes;this._locationInfo={hash:n,stringHash:t,locations:e,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,n,r){try{const{vertex:i,fragment:s,uniformBindings:o}=this._generateShaders(e,t,n,r);return new p.K(i,s,this.renamedLocationsMap,this.locationInfo,o,this.transformFeedbackBindings)}catch(i){return new p.K("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find((t=>t.propertyKey===e));if(t)return{type:"option",className:t.typeCtor};const n=this._uniforms.find((t=>t.propertyKey===e));if(!n)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:n.typeCtor}}getShaderKey(e,t,n,r){const i=Object.keys(e).map((t=>`${t}.${e[t]}`)).join("."),s=Object.keys(n).map((e=>`${e}.${n[e]}`)).join("."),o=Object.keys(r).map((e=>`${e}.${r[e]}`)).join("."),c=Object.keys(t).filter((e=>this.optionPropertyKeys.has(e)&&t[e])).join(".");return`${this.constructor.name}.${i}.${s}.${o}.${c}`}_generateShaders(e,t,n,r){const i=[];this._setDefines(n),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(r),o=this._injectPackPrecisionFactor(s,e),c=this._hydrateComputeInput(),h=c&&this._injectComputePackPrecisionFactor(c,e),d=this.vertex(o,h),p=this._hydrateFragmentInput(d),f=this.fragment(p),y=new Set;for(const a in f){const e=f[a];(0,u.rz)(y,e)}const m=this._getVertexInputBuiltins(),g=l.createVertex({...s,...c},d,m,i,this.transformFeedbackBindings,y);(new a).write(g);const v=this._getFragmentInputBuiltins(f);v.set("glPointCoord","gl_PointCoord");const b=l.createFragment(p,f,v,i,g,this.transformFeedbackBindings);(new a).write(b);const _=this._createShaderBuilder(g,b),w=_.generate("vertex"),$=_.generate("fragment");return this.logShader&&(console.log(w),console.log($)),{vertex:w,fragment:$,uniformBindings:i}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const n of this._options)t[n.propertyKey]?this[n.propertyKey]=this._hydrateUniformGroup(e,n):this[n.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const n=new(0,t.typeCtor);for(const r of n._uniforms??[]){const i=y(r.typeCtor),s=`u_${t.propertyKey}_${r.propertyKey}`,o=i.type,c=[t.propertyKey,r.propertyKey].join(".");if("type"in r.typeCtor&&"array"===r.typeCtor.type){const t=i;e.push({shaderModulePath:c,uniformName:s,uniformType:o,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:i})}else if("type"in r.typeCtor&&"array-2d"===r.typeCtor.type){const t=i;e.push({shaderModulePath:c,uniformName:s,uniformType:o,uniformArrayLength:t.size,uniformArrayElementType:t.elementType.type,uniformHydrated:i})}else e.push({shaderModulePath:c,uniformName:s,uniformType:o,uniformHydrated:i});n[r.propertyKey]=i}return n}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,n=t.locations.reduce(((t,n)=>!1===e[n.propertyKey]?t:{...t,[n.propertyKey]:y(n.typeCtor)}),{});for(const{propertyKey:r,typeCtor:i}of t.builtins){const e=y(i);n[r]=e}return n}_hydrateComputeInput(){return null==this.computeInput?null:this.computeInput.inputCtor.locations.reduce(((e,t)=>({...e,[t.propertyKey]:y(t.typeCtor)})),{})}_injectPackPrecisionFactor(e,t){const n={};for(const r in e){const i=e[r],s=t[r];if(s){if("float"!==i.type&&"vec2"!==i.type&&"vec3"!==i.type&&"vec4"!==i.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);n[r]=i.divide(new o.nt(s))}else n[r]=i}return n}_injectComputePackPrecisionFactor(e,t){const n={},r=new Map;for(const i in this.computeAttributes)for(const e of this.computeAttributes[i]??[])r.set(e,i);for(const i in e){const s=e[i],c=r.get(i);if(!c)continue;const a=t[c];if(a){if("float"!==s.type&&"vec2"!==s.type&&"vec3"!==s.type&&"vec4"!==s.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);n[i]=s.divide(new o.nt(a))}else n[i]=s}return n}_hydrateFragmentInput(e){const t={};for(const n in e)t[n]=e[n];for(const{propertyKey:n,typeCtor:r}of T.builtins){const e=y(r);t[n]=e}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:n,propertyKey:r}of e.builtins)t.set(r,n);return t}_getFragmentInputBuiltins(e){const t=e.constructor,n=new Map;for(const r of t.builtins??[])n.set(r.propertyKey,r.builtin);return n}_createShaderBuilder(e,t){const n=new f.N5;return this._insertDebugInfo(n),e.insertVertexShader(n),t.insertFragmentShader(n),n}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}}},22881:(e,t,n)=>{function r(e,t){const n=[];for(n.push(t);n.length;){const t=n.pop();if("object"==typeof t&&!e.has(t.uid)){e.add(t.uid);for(const e of t.children)n.push(e)}}}n.d(t,{XL:()=>h,aw:()=>l,ff:()=>u,rR:()=>d,rz:()=>r,vA:()=>s,vL:()=>o,zg:()=>a});class i{constructor(){this.uid=i.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(e){return e=function(e){return e.split(" ").map(((e,t)=>t>0?e.charAt(0).toUpperCase()+e.slice(1):e)).join("")}(e),this._debugName=e,this.isImplicit&&this.children[0]instanceof i&&this.children[0].setDebugName(e),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(e){e._debugName=this._debugName,e._isMutable=this._isMutable,e.isImplicit=this.isImplicit,e.uid=this.uid}}function s(e){return"object"==typeof e?e.clone():e}i.NodeCount=0;class o extends i{constructor(){super(...arguments),this.shaderType="primitive-node"}}class c extends i{constructor(e){super(),this.child=e,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const e=new c(s(this.child));return this.cloneInto(e),e}}class a extends i{constructor(e,t,n){super(),this.property=e,this.target=t,this.returnType=n,this.shaderType="property-access-node"}get children(){const e=[this.target];return"string"!=typeof this.property&&e.push(this.property),e}clone(){const e=new a(this.property,s(this.target),this.returnType);return this.cloneInto(e),e}}class u extends i{constructor(e,t,n,r){super(),this.x=e,this.y=t,this.target=n,this.returnType=r,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const e=new u(this.x,this.y,s(this.target),this.returnType);return this.cloneInto(e),e}}class h extends i{constructor(e,t,n){super(),this.condition=e,this.ifTrue=t,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const e=s(this.ifTrue),t=this.ifFalse?s(this.ifFalse):null,n=new h(this.condition,e,t);return this.cloneInto(n),n}}class d extends i{constructor(e,t,n,r){super(),this.captureList=e,this.returnType=t,this.generator=r,this.shaderType="block-node",n&&(this.subgraph=new c(n))}get children(){return Object.keys(this.captureList).map((e=>this.captureList[e])).concat(this.subgraph??[])}clone(){const e={};for(const n in this.captureList)e[n]=s(this.captureList[n]);const t=new d(e,this.returnType,this.subgraph?s(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(t),t}}class l extends i{constructor(e,t,n,r,i,s=!1){super(),this.token=e,this._children=t,this.isInfix=n,this.isPropertyAccess=r,this.returnType=i,this.isTernary=s,this.shaderType="function-node"}get children(){return this._children}clone(){const e=new l(this.token,this._children.map(s),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(e),e}}},60984:(e,t,n)=>{n.d(t,{$5:()=>ge,$I:()=>R,AU:()=>Be,Ai:()=>O,Bw:()=>Pe,F8:()=>Ve,Gb:()=>le,Io:()=>Fe,LC:()=>ye,LI:()=>De,MM:()=>ve,My:()=>$,Ny:()=>V,Om:()=>Me,PM:()=>Ge,RI:()=>Ee,RZ:()=>Re,S8:()=>Oe,Sj:()=>pe,T9:()=>Ce,TF:()=>ze,Tk:()=>oe,U:()=>z,US:()=>He,Uo:()=>we,Wh:()=>H,Xe:()=>me,ZY:()=>A,Zb:()=>N,Zc:()=>Z,aX:()=>be,eB:()=>S,eR:()=>X,fV:()=>q,gn:()=>Ne,j1:()=>ce,jc:()=>ke,jh:()=>Ue,jk:()=>Le,ln:()=>W,lw:()=>ae,mk:()=>Ae,n7:()=>je,nf:()=>fe,nt:()=>T,om:()=>se,or:()=>_e,qE:()=>Se,rY:()=>Te,tn:()=>$e,w0:()=>Y,x:()=>P,z7:()=>I,ze:()=>ie,zi:()=>Ke});var r,i,s,o,c,a,u,h,d,l,p,f,y,m,g=n(35143),v=n(22881);function b(e){return new Proxy(e,{get(t,n){if("constructor"===n)return new Proxy(t.constructor,{construct:(e,t,n)=>b(new e(...t))});if(n in t)return t[n];if("string"==typeof n){const t=function(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const n of t)if(n.includes(e))return n.map((e=>G[e]));throw new Error("Unable to find type family")}(e.type);return J(e,n,t[n.length-1])}}})}function _(e){return new Proxy(e,{construct:(e,t,n)=>b(new e(...t))})}class w extends Error{}let $=r=class extends v.vL{constructor(e,t){super(),this.elementType=e,this.size=t,this.children=[],this.type="array"}clone(){const e=new r(this.elementType,this.size);return super.cloneInto(e),e}get(e,t){const n=new O(e),r=null!=t?new O(t):null;return null!=r?Q(this,n,r,function(e){switch(e.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return P;case"float":case"vec2":case"vec3":case"vec4":return T;case"int":case"ivec2":case"ivec3":case"ivec4":return O;case"uint":case"uvec2":case"uvec3":case"uvec4":return F;default:throw new Error("Unable to handle type")}}(this.elementType.constructor)):J(this,n,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(e,t,n){return function(e,t,n=0,r=e.size){const i=new O(n).setMutable().setDebugName("FindIndexIterator"),s=t(e.get(i)).setDebugName("FindIndexPredicate"),o=se({iter:i},O,s,(({out:e,iter:t,subgraph:n})=>`\n${e} = -1;\n\nfor (; ${t} < ${r}; ${t}++) {\n\n${n.body}\n\n  if (${n.varName}) {\n    ${e} = ${t};\n    break;\n  }\n\n}\n`)).setDebugName("FindIndexBlock");return o}(this,e,t,n)}glslFindIndex(e,t,n){return function(e,t,n=0,r=e.size){const i=se({array:e},O,null,(({out:e,array:i})=>`\n${e} = -1;\nfor (int i = ${n}; i < ${r}; i++) {\n  bool condition;\n  ${t({array:i,i:"i",out:"condition"})}\n  if (condition) {\n    ${e} = i;\n    break;\n  }\n}\n`)).setDebugName("GlslFindIndexBlock");return i}(this,e,t,n)}static ofType(e,t){const n={construct:(n,i)=>new r(new e,t)};return new Proxy(r,n)}};$.type="array",$=r=(0,g._)([function(e){return new Proxy(e,{construct:(e,t,n)=>function(e){return new Proxy(e,{get(t,n){if(n in t)return t[n];if("string"==typeof n){const t=parseInt(n,10);if(!isNaN(t))return J(e,`[${t}]`,e.elementType.constructor)}}})}(new e(...t))})}],$);class x extends v.vL{constructor(e,t,n,r=!1){super(),this.elementType=e,this.xSize=t,this.ySize=n,this.isRowMajor=r,this.children=[],this.type="array-2d"}clone(){const e=new x(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(e),e}get size(){return this.xSize*this.ySize}get(e,t){return this.isRowMajor?this._getRowMajor(e,t):this._getColumnMajor(e,t)}_getColumnMajor(e,t){const n=new O(e);return J(this,new O(t).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(e,t){const n=new O(e),r=new O(t);return J(this,n.add(r.multiply(this.ySize)),this.elementType.constructor)}static ofType(e,t,n,r=!1){return new Proxy($,{construct:(i,s)=>new x(new e,t,n,r)})}}x.type="array-2d";class I extends v.vL{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const e=new I;return e.children=this.children.map(v.vA),super.cloneInto(e),e}}I.type="sampler2D";class T extends v.vL{constructor(e){super(),this.type="float",this.children=[e]}clone(){const e=new T((0,v.vA)(this.children[0]));return super.cloneInto(e),e}multiply(e){return ae(this,"number"==typeof e?U(e,T):e)}divide(e){return ue(this,"number"==typeof e?U(e,T):e)}add(e){return he(this,"number"==typeof e?U(e,T):e)}subtract(e){return de(this,"number"==typeof e?U(e,T):e)}}T.type="float";let A=i=class extends v.vL{constructor(e,t){super(),this.type="vec2",this.children=[e,t].filter((e=>null!=e))}clone(){const e=new i((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]));return super.cloneInto(e),e}get 0(){return J(this,"[0]",T)}get 1(){return J(this,"[1]",T)}get 2(){throw new w}get 3(){throw new w}multiply(e){return ae(this,"number"==typeof e?U(e,T):e)}divide(e){return ue(this,"number"==typeof e?U(e,T):e)}add(e){return he(this,"number"==typeof e?U(e,T):e)}subtract(e){return de(this,"number"==typeof e?U(e,T):e)}};A.type="vec2",A=i=(0,g._)([_],A);let S=s=class extends v.vL{constructor(e,t,n){super(),this.type="vec3",this.children=[e,t,n].filter((e=>null!=e))}get 0(){return J(this,"[0]",T)}get 1(){return J(this,"[1]",T)}get 2(){return J(this,"[2]",T)}get 3(){throw new w}clone(){const e=new s((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]));return super.cloneInto(e),e}multiply(e){return ae(this,"number"==typeof e?U(e,T):e)}divide(e){return ue(this,"number"==typeof e?U(e,T):e)}add(e){return he(this,"number"==typeof e?U(e,T):e)}subtract(e){return de(this,"number"==typeof e?U(e,T):e)}};S.type="vec3",S=s=(0,g._)([_],S);let N=o=class extends v.vL{constructor(e,t,n,r){super(),this.type="vec4",this.children=[e,t,n,r].filter((e=>null!=e))}clone(){const e=new o((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]));return super.cloneInto(e),e}get 0(){return J(this,"[0]",T)}get 1(){return J(this,"[1]",T)}get 2(){return J(this,"[2]",T)}get 3(){return J(this,"[3]",T)}multiply(e){return ae(this,"number"==typeof e?U(e,T):e)}divide(e){return ue(this,"number"==typeof e?U(e,T):e)}add(e){return he(this,"number"==typeof e?U(e,T):e)}subtract(e){return de(this,"number"==typeof e?U(e,T):e)}};N.type="vec4",N=o=(0,g._)([_],N);let F=c=class extends v.vL{constructor(e){super(),this.type="uint",this.children=[e]}clone(){const e=new c((0,v.vA)(this.children[0]));return super.cloneInto(e),e}};F.type="uint",F=c=(0,g._)([_],F);let M=a=class extends v.vL{constructor(e,t){super(),this.type="uvec2",this.children=[e,t].filter((e=>null!=e))}clone(){const e=new a((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]));return super.cloneInto(e),e}};M.type="uvec2",M=a=(0,g._)([_],M);let E=u=class extends v.vL{constructor(e,t,n){super(),this.type="uvec3",this.children=[e,t,n].filter((e=>null!=e))}clone(){const e=new u((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]));return super.cloneInto(e),e}};E.type="uvec3",E=u=(0,g._)([_],E);let k=h=class extends v.vL{constructor(e,t,n,r){super(),this.type="uvec4",this.children=[e,t,n,r].filter((e=>null!=e))}clone(){const e=new h((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]));return super.cloneInto(e),e}};k.type="uvec4",k=h=(0,g._)([_],k);class P extends v.vL{constructor(e){super(),this.type="bool",this.children=[e]}and(e){return we(this,e)}or(e){return _e(this,e)}clone(){const e=new P((0,v.vA)(this.children[0]));return super.cloneInto(e),e}}P.type="bool";let C=d=class extends v.vL{constructor(e,t){super(),this.type="bvec2",this.children=[e,t].filter((e=>null!=e))}all(){return xe(this)}any(){return Ie(this)}clone(){const e=new d((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]));return super.cloneInto(e),e}};C.type="bvec2",C=d=(0,g._)([_],C);let L=l=class extends v.vL{constructor(e,t,n){super(),this.type="bvec3",this.children=[e,t,n].filter((e=>null!=e))}all(){return xe(this)}any(){return Ie(this)}clone(){const e=new l((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]));return super.cloneInto(e),e}};function U(e,t){return"number"==typeof e?new t(e):e}L.type="bvec3",L=l=(0,g._)([_],L);let K=p=class extends v.vL{constructor(e,t,n,r){super(),this.type="bvec4",this.children=[e,t,n,r].filter((e=>null!=e))}all(){return xe(this)}any(){return Ie(this)}clone(){const e=new p((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]));return super.cloneInto(e),e}};K.type="bvec4",K=p=(0,g._)([_],K);class O extends v.vL{constructor(e){super(),this.type="int",this.children=[e]}multiply(e){return ae(this,U(e,O))}add(e){return he(this,U(e,O))}subtract(e){return de(this,U(e,O))}divide(e){return ue(this,U(e,O))}clone(){const e=new O((0,v.vA)(this.children[0]));return super.cloneInto(e),e}}O.type="int";let B=f=class extends v.vL{constructor(e,t){super(),this.type="ivec2",this.children=[e,t].filter((e=>null!=e))}clone(){const e=new f((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]));return super.cloneInto(e),e}};B.type="ivec2",B=f=(0,g._)([_],B);let j=y=class extends v.vL{constructor(e,t,n){super(),this.type="ivec3",this.children=[e,t,n].filter((e=>null!=e))}clone(){const e=new y((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]));return super.cloneInto(e),e}};j.type="ivec3",j=y=(0,g._)([_],j);let D=m=class extends v.vL{constructor(e,t,n,r){super(),this.type="ivec4",this.children=[e,t,n,r].filter((e=>null!=e))}clone(){const e=new m((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]));return super.cloneInto(e),e}};D.type="ivec4",D=m=(0,g._)([_],D);class V extends v.vL{constructor(e,t,n,r){super(),this.type="mat2",this.children=[e,t,n,r]}clone(){const e=new V((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]));return super.cloneInto(e),e}get(e,t){return Q(this,new O(e),new O(t),T)}multiply(e){return ae(this,e)}}V.type="mat2";class z extends v.vL{static identity(){return new z(1,0,0,0,1,0,0,0,1)}static fromRotation(e){const t=Ve(e),n=Ne(e);return new z(n,t,0,ie(t),n,0,0,0,1)}constructor(e,t,n,r,i,s,o,c,a){super(),this.type="mat3",this.children=[e,t,n,r,i,s,o,c,a]}add(e){return he(this,e)}multiply(e){return ae(this,e)}get(e,t){return Q(this,new O(e),new O(t),T)}clone(){const e=new z((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]),(0,v.vA)(this.children[4]),(0,v.vA)(this.children[5]),(0,v.vA)(this.children[6]),(0,v.vA)(this.children[7]),(0,v.vA)(this.children[8]));return super.cloneInto(e),e}}z.type="mat3";class R extends v.vL{static identity(){return new R(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(e,t,n,r,i,s,o,c,a,u,h,d,l,p,f,y){super(),this.type="mat4",this.children=[e,t,n,r,i,s,o,c,a,u,h,d,l,p,f,y]}static fromColumns(e,t,n,r){return new R(e.x,e.y,e.z,e.w,t.x,t.y,t.z,t.w,n.x,n.y,n.z,n.w,r.x,r.y,r.z,r.w)}multiply(e){return ae(this,e)}get(e,t){return Q(this,new O(e),new O(t),T)}clone(){const e=new R((0,v.vA)(this.children[0]),(0,v.vA)(this.children[1]),(0,v.vA)(this.children[2]),(0,v.vA)(this.children[3]),(0,v.vA)(this.children[4]),(0,v.vA)(this.children[5]),(0,v.vA)(this.children[6]),(0,v.vA)(this.children[7]),(0,v.vA)(this.children[8]),(0,v.vA)(this.children[9]),(0,v.vA)(this.children[10]),(0,v.vA)(this.children[11]),(0,v.vA)(this.children[12]),(0,v.vA)(this.children[13]),(0,v.vA)(this.children[14]),(0,v.vA)(this.children[15]));return super.cloneInto(e),e}}R.type="mat4";const G={float:T,vec2:A,vec3:S,vec4:N,int:O,ivec2:B,ivec3:j,ivec4:D,uint:F,uvec2:M,uvec3:E,uvec4:k,bool:P,bvec2:C,bvec3:L,bvec4:K},H=(...e)=>new O(...e),q=(...e)=>new T(...e),Z=(...e)=>new A(...e),X=(...e)=>new S(...e),W=(...e)=>new N(...e),Y=(...e)=>new z(...e);function J(e,t,n){const r=new n(new v.zg(t,e,n));return r.isImplicit=!0,r}function Q(e,t,n,r){const i=new r(new v.ff(t,n,e,r));return i.isImplicit=!0,i}function ee(e,t,n,r=null){if(r){const i=new r,s=new r(new v.aw(e,[t,n],!0,!1,i));return s.isImplicit=!0,s}if("float"===t.type||"int"===t.type){const r=new n.constructor(new v.aw(e,[t,n],!0,!1,n.constructor));return r.isImplicit=!0,r}if(("mat2"===t.type||"mat3"===t.type||"mat4"===t.type)&&"float"!==n.type){const r=new n.constructor(new v.aw(e,[t,n],!0,!1,n.constructor));return r.isImplicit=!0,r}const i=new t.constructor(new v.aw(e,[t,n],!0,!1,t.constructor));return i.isImplicit=!0,i}function te(e,t,n=t.constructor){const r=new n(new v.aw(e,[t],!1,!1,n));return r.isImplicit=!0,r}function ne(e,t,n,r=t.constructor){const i=new r(new v.aw(e,[t,n],!1,!1,r));return i.isImplicit=!0,i}function re(e,t,n,r,i=t.constructor){const s=new i(new v.aw(e,[t,n,r],!1,!1,i));return s.isImplicit=!0,s}function ie(e){return ae(e,q(-1))}function se(e,t,n,r){return new t(new v.rR(e,t,n,r))}function oe(e,t,n){const r="function"==typeof t?t():t,i="function"==typeof n?n():n,s=new r.constructor(new v.XL(e,r,i));return s.isImplicit=!0,s}function ce(...e){const t=e.map((([e,t])=>"function"==typeof t?[e,t()]:[e,t])),n=t[0][1].constructor,r=t.findIndex((e=>!0===e[0]));if(-1===r)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,r),s=t[r][1],o=new n(i.reduceRight(((e,t)=>oe(t[0],t[1],e)),s));return o.isImplicit=!0,o}function ae(e,t){return ee("*",e,t)}function ue(e,t){return ee("/",e,t)}function he(e,t){return ee("+",e,t)}function de(e,t){return ee("-",e,t)}function le(e,t){return ee("%",e,t)}function pe(e,t){return ee(">>",e,t)}function fe(e,t){return ee("&",e,t)}function ye(e,t){return ee("==",e,t,P)}function me(e,t){return ee("<",e,t,P)}function ge(e,t){return ee("<=",e,t,P)}function ve(e,t){return ee(">",e,t,P)}function be(e,t){return ee(">=",e,t,P)}function _e(...e){return e.length<=1?e[0]:e.slice(1).reduce(((e,t)=>function(e,t){return ee("||",e,t,P)}(e,t)),e[0])}function we(...e){return e.length<=1?e[0]:e.slice(1).reduce(((e,t)=>function(e,t){return ee("&&",e,t,P)}(e,t)),e[0])}function $e(e){return te("abs",e)}function xe(e){return te("all",e,P)}function Ie(e){return te("any",e,P)}function Te(e,t){return null==t?te("atan",e):ne("atan",e,t,e.constructor)}function Ae(e){return te("ceil",e)}function Se(e,t,n){return re("clamp",e,t,n,e.constructor)}function Ne(e){return te("cos",e)}function Fe(e,t){return ne("distance",e,t,T)}function Me(e,t){return ne("dot",e,t,T)}function Ee(e){return te("floor",e)}function ke(e){return te("fract",e)}function Pe(e){return te("length",e,T)}function Ce(e,t){return ne("max",e,t)}function Le(e,t){return ne("min",e,t)}function Ue(e,t,n){return re("mix",e,t,n)}function Ke(e,t){return ne("mod",e,t)}function Oe(e){return te("normalize",e)}function Be(e){return"bool"===e.type?te("!",e):te("not",e)}function je(e,t){return ne("pow",e,t)}function De(e){return te("round",e)}function Ve(e){return te("sin",e)}function ze(e,t,n){return re("smoothstep",e,t,n)}function Re(e){return te("sqrt",e)}function Ge(e,t){return ne("step",e,t,t.constructor)}function He(e,t){return ne("texture",e,t,N)}},32743:(e,t,n)=>{var r;n.d(t,{N:()=>r}),function(e){e[e.AnimatedMarker=0]="AnimatedMarker",e[e.Blend=1]="Blend",e[e.ComplexFill=2]="ComplexFill",e[e.ComplexOutlineFill=3]="ComplexOutlineFill",e[e.DotDensity=4]="DotDensity",e[e.Fill=5]="Fill",e[e.GradientFill=6]="GradientFill",e[e.GradientStroke=7]="GradientStroke",e[e.Grid=8]="Grid",e[e.Heatmap=9]="Heatmap",e[e.Label=10]="Label",e[e.Line=11]="Line",e[e.Magnifier=12]="Magnifier",e[e.Marker=13]="Marker",e[e.OutlineFill=14]="OutlineFill",e[e.Overlay=15]="Overlay",e[e.PatternFill=16]="PatternFill",e[e.PatternOutlineFill=17]="PatternOutlineFill",e[e.PieChart=18]="PieChart",e[e.Test=19]="Test",e[e.Text=20]="Text",e[e.TexturedLine=21]="TexturedLine",e[e.Bitmap=22]="Bitmap"}(r||(r={}))},99943:(e,t,n)=>{n.d(t,{K:()=>u});var r=n(50076),i=n(76460),s=n(48611),o=(n(81806),n(47249),n(61678),n(93345),n(12331),n(44488)),c=(n(89179),n(18316),n(86340));function a(e,t,n){const s=t.length;if(s!==n){const o=new r.A("Invalid Uniform",`Invalid length, expected ${n} but got ${s}`,{uniformName:e,values:t});i.A.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram").errorOnce(o)}}class u{constructor(e,t,n,r,i,s){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=e,this.fragmentShader=t,this._locations=n,this._locationInfo=r,this._uniformBindings=i,this._transformFeedbackBindings=s}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(e){this._uniforms=e}cleanupTemporaryTextures(){for(const e of this._temporaryTextures)e.dispose();this._temporaryTextures=[]}bind(e){const t=this._uniforms;if(!this._program){const t=new Map;for(const[e,r]of this._locations)t.set(e,r);const n=[];for(const e of this._transformFeedbackBindings??[]){const{index:t,propertyKey:r}=e;n[t]=`v_${r}`}this._program=new o.B(e,this.vertexShader,this.fragmentShader,t,new Map,n)}const n=this._program;e.useProgram(n);for(const r of this._uniformBindings){const{shaderModulePath:i,uniformName:o,uniformType:u,uniformArrayLength:h}=r,d=(0,s.wc)(i,t);if(null==d){if("sampler2D"===u)continue;throw new Error(`Failed to find uniform value for ${i}`)}switch("array"===u||"array-2d"===u?r.uniformArrayElementType:u){case"sampler2D":{const{unit:t,texture:r}=d;if(n.setUniform1i(o,t),"type"in r)e.bindTexture(r,t);else{const n=(0,c.sZ)(e,r.descriptor,r.data);e.bindTexture(n,t)}break}case"int":if(!h){n.setUniform1i(o,d);break}a(r.uniformName,d,h),n.setUniform1iv(o,d);break;case"float":if(!h){n.setUniform1f(o,d);break}a(r.uniformName,d,h),n.setUniform1fv(o,d);break;case"vec2":if(!h){n.setUniform2f(o,d[0],d[1]);break}a(r.uniformName,d,h),n.setUniform2fv(o,d.flat());break;case"vec3":if(!h){n.setUniform3f(o,d[0],d[1],d[2]);break}a(r.uniformName,d,h),n.setUniform3fv(o,d.flat());break;case"vec4":if(!h){n.setUniform4f(o,d[0],d[1],d[2],d[3]);break}a(r.uniformName,d,h),n.setUniform4fv(o,d.flat());break;case"mat3":n.setUniformMatrix3fv(o,d);break;case"mat4":n.setUniformMatrix4fv(o,d);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}}},69728:(e,t,n)=>{var r;n.d(t,{c:()=>r}),function(e){e[e.Bind=0]="Bind",e[e.Pass=1]="Pass",e[e.Draw=2]="Draw"}(r||(r={}))},2687:(e,t,n)=>{n.d(t,{N5:()=>a});var r=n(50076),i=(n(81806),n(76460)),s=n(69728);const o=()=>i.A.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class c{constructor(){this._includedModules=new Map}include(e,t){this._includedModules.has(e)?this._includedModules.get(e):(this._includedModules.set(e,t),e(this.builder,t))}}class a extends c{constructor(){super(...arguments),this.vertex=new l,this.fragment=new l,this.attributes=new p,this.varyings=new f,this.extensions=new y,this.outputs=new m}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e,t=!1){const n=this.extensions.generateSource(e),r=this.attributes.generateSource(e),i=this.varyings.generateSource(e),s="vertex"===e?this.vertex:this.fragment,o=s.uniforms.generateSource(),c=s.code.generateSource(),a=s.main.generateSource(t),u="vertex"===e?b:v,h=s.constants.generateSource(),d=this.outputs.generateSource(e);return`#version 300 es\n${n.join("\n")}\n${u}\n${h.join("\n")}\n${o.join("\n")}\n${r.join("\n")}\n${i.join("\n")}\n${d.join("\n")}\n${c.join("\n")}\n${a.join("\n")}`}generateBind(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const n=e.bind[s.c.Bind];n&&t.set(e.name,n)})),this.fragment.uniforms.entries.forEach((e=>{const n=e.bind[s.c.Bind];n&&t.set(e.name,n)}));const n=Array.from(t.values()),r=n.length;return t=>{for(let i=0;i<r;++i)n[i](e,t)}}generateBindPass(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const n=e.bind[s.c.Pass];n&&t.set(e.name,n)})),this.fragment.uniforms.entries.forEach((e=>{const n=e.bind[s.c.Pass];n&&t.set(e.name,n)}));const n=Array.from(t.values()),r=n.length;return(t,i)=>{for(let s=0;s<r;++s)n[s](e,t,i)}}generateBindDraw(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const n=e.bind[s.c.Draw];n&&t.set(e.name,n)})),this.fragment.uniforms.entries.forEach((e=>{const n=e.bind[s.c.Draw];n&&t.set(e.name,n)}));const n=Array.from(t.values()),r=n.length;return(t,i,s)=>{for(let o=0;o<r;++o)n[o](e,s,t,i)}}}class u{constructor(e){this._stage=e,this._entries=new Map}add(...e){for(const t of e)this._add(t);return this._stage}get(e){return this._entries.get(e)}_add(e){if(null!=e){if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new r.A(`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}else o().error(`Trying to add null Uniform from ${(new Error).stack}.`)}generateSource(){return Array.from(this._entries.values()).map((e=>null!=e.arraySize?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`))}get entries(){return Array.from(this._entries.values())}}class h{constructor(e){this._stage=e,this._bodies=new Array}add(e){return this._bodies.push(e),this._stage}generateSource(e){if(this._bodies.length>0)return[`void main() {\n ${this._bodies.join("\n")||""} \n}`];if(e)throw new r.A("Shader does not contain main function body.");return[]}}class d{constructor(e){this._stage=e,this._entries=new Array}add(e){return this._entries.push(e),this._stage}generateSource(){return this._entries}}class l extends c{constructor(){super(...arguments),this.uniforms=new u(this),this.main=new h(this),this.code=new d(this),this.constants=new g(this)}get builder(){return this}}class p{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`in ${e[1]} ${e[0]};`))}}class f{constructor(){this._entries=new Map}add(e,t){this._entries.has(e)?o().warn(`Ignoring duplicate varying ${t} ${e}`):this._entries.set(e,t)}generateSource(e){const t=new Array;return this._entries.forEach(((n,r)=>t.push("vertex"===e?`out ${n} ${r};`:`in ${n} ${r};`))),t}}class y{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?y.ALLOWLIST_VERTEX:y.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}y.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],y.ALLOWLIST_VERTEX=[];class m{constructor(){this._entries=new Map}add(e,t,n=0){const r=this._entries.get(n);r?.name!==e||r?.type!==t?this._entries.set(n,{name:e,type:t}):o().warn(`Fragment shader output location ${n} occupied`)}generateSource(e){if("vertex"===e)return[];0===this._entries.size&&this._entries.set(0,{name:m.DEFAULT_NAME,type:m.DEFAULT_TYPE});const t=new Array;return this._entries.forEach(((e,n)=>t.push(`layout(location = ${n}) out ${e.type} ${e.name};`))),t}}m.DEFAULT_TYPE="vec4",m.DEFAULT_NAME="fragColor";class g{constructor(e){this._stage=e,this._entries=new Set}add(e,t,n){let r="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":r=g._numberToFloatStr(n);break;case"int":r=g._numberToIntStr(n);break;case"bool":r=n.toString();break;case"vec2":r=`vec2(${g._numberToFloatStr(n[0])},                            ${g._numberToFloatStr(n[1])})`;break;case"vec3":r=`vec3(${g._numberToFloatStr(n[0])},                            ${g._numberToFloatStr(n[1])},                            ${g._numberToFloatStr(n[2])})`;break;case"vec4":r=`vec4(${g._numberToFloatStr(n[0])},                            ${g._numberToFloatStr(n[1])},                            ${g._numberToFloatStr(n[2])},                            ${g._numberToFloatStr(n[3])})`;break;case"ivec2":r=`ivec2(${g._numberToIntStr(n[0])},                             ${g._numberToIntStr(n[1])})`;break;case"ivec3":r=`ivec3(${g._numberToIntStr(n[0])},                             ${g._numberToIntStr(n[1])},                             ${g._numberToIntStr(n[2])})`;break;case"ivec4":r=`ivec4(${g._numberToIntStr(n[0])},                             ${g._numberToIntStr(n[1])},                             ${g._numberToIntStr(n[2])},                             ${g._numberToIntStr(n[3])})`;break;case"mat2":case"mat3":case"mat4":r=`${t}(${Array.prototype.map.call(n,(e=>g._numberToFloatStr(e))).join(", ")})`}return this._entries.add(`const ${t} ${e} = ${r};`),this._stage}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const v="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp int;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump int;\n  precision mediump sampler2D;\n#endif",b="precision highp float;\nprecision highp sampler2D;"}}]);
//# sourceMappingURL=7861.57eb6fe2.chunk.js.map