"use strict";(globalThis.webpackChunkmy_app=globalThis.webpackChunkmy_app||[]).push([[11811],{19061:(t,e,i)=>{i.d(e,{H:()=>H,b:()=>I,c:()=>z});var r=i(19555),o=i(72745),s=i(55855),n=i(14556),a=i(34981),l=i(26917),c=i(90080),h=i(98720),p=i(40318),u=i(38280),d=i(62374),f=i(20469),v=i(66763),_=i(80883),g=i(81449),m=i(69817),w=i(3799),y=i(95756),x=i(51596),T=i(20123),M=i(58350),C=i(23148),O=i(21390),S=i(86955),P=i(4653),b=i(70367),D=i(72001),A=i(66470),E=i(2687),R=i(75569);function I(t){const e=new E.N5,i=t.signedDistanceFieldEnabled;e.include(p.Q,t),e.vertex.include(l.rA,t);const{occlusionPass:o,output:I,oitPass:H}=t;if(o)return e.include(u.I,t),e;const{vertex:V,fragment:L}=e;e.include(m.Y6),e.include(v.A,t),e.include(c.g,t),e.include(d.y),L.include(g.W),L.include(_.a),e.varyings.add("vcolor","vec4"),e.varyings.add("vtc","vec2"),e.varyings.add("vsize","vec2");const N=I===a.V.Highlight,B=N&&t.occlusionTestEnabled;B&&e.varyings.add("voccluded","float"),V.uniforms.add(new x.I("viewport",(t=>t.camera.fullViewport)),new y.G("screenOffset",((t,e)=>(0,r.hZ)(j,2*t.screenOffset[0]*e.camera.pixelRatio,2*t.screenOffset[1]*e.camera.pixelRatio))),new y.G("anchorPosition",(t=>z(t))),new M.E("materialColor",(t=>t.color)),new O.m("materialRotation",(t=>t.rotation))),(0,w.Nz)(V),i&&(V.uniforms.add(new M.E("outlineColor",(t=>t.outlineColor))),L.uniforms.add(new M.E("outlineColor",(t=>F(t)?t.outlineColor:s.uY)),new O.m("outlineSize",(t=>F(t)?t.outlineSize:0)))),t.horizonCullingEnabled&&V.uniforms.add(new T.V("pointDistanceSphere",((t,e)=>{const i=e.camera.eye,r=t.origin;return(0,s.fA)(r[0]-i[0],r[1]-i[1],r[2]-i[2],n.$O.radius)}))),t.pixelSnappingEnabled&&V.include(h.K),t.hasScreenSizePerspective&&((0,m.pM)(V),(0,m.OH)(V)),t.debugDrawLabelBorder&&e.varyings.add("debugBorderCoords","vec4"),e.attributes.add(A.r.UV0,"vec2"),e.attributes.add(A.r.COLOR,"vec4"),e.attributes.add(A.r.SIZE,"vec2"),e.attributes.add(A.r.ROTATION,"float"),e.attributes.add(A.r.FEATUREATTRIBUTE,"vec4"),V.code.add(t.horizonCullingEnabled?S.H`bool behindHorizon(vec3 posModel) {
vec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;
vec3 camToPos = pointDistanceSphere.xyz + posModel;
float earthRadius = pointDistanceSphere.w;
float a = dot(camToPos, camToPos);
float b = dot(camToPos, camToEarthCenter);
float c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;
return  b > 0.0 && b < a && b * b  > a * c;
}`:S.H`bool behindHorizon(vec3 posModel) { return false; }`),V.main.add(S.H`
      ProjectHUDAux projectAux;
      vec4 posProj = projectPositionHUD(projectAux);
      forwardObjectAndLayerIdColor();

      if (rejectBySlice(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      if (behindHorizon(projectAux.posModel)) {
        // Project outside of clip plane
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
        return;
      }

      vec2 inputSize;
      ${(0,S.If)(t.hasScreenSizePerspective,S.H`
          inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);
          vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);`,S.H`
          inputSize = size;
          vec2 screenOffsetScaled = screenOffset;`)}
      ${(0,S.If)(t.vvSize,S.H`inputSize *= vvScale(featureAttribute).xx;`)}

      vec2 combinedSize = inputSize * pixelRatio;
      vec4 quadOffset = vec4(0.0);

      ${(0,S.If)(t.occlusionTestEnabled,S.H`
      bool visible = testHUDVisibility(posProj);
      if (!visible) {
        vtc = vec2(0.0);
        ${(0,S.If)(t.debugDrawLabelBorder,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);")}
        return;
      }`)}
      ${(0,S.If)(B,S.H`voccluded = visible ? 0.0 : 1.0;`)}
    `);const Z=S.H`
      vec2 uv01 = floor(uv0);
      vec2 uv = uv0 - uv01;
      quadOffset.xy = (uv01 - anchorPosition) * 2.0 * combinedSize;

      ${(0,S.If)(t.hasRotation,S.H`
          float angle = radians(materialRotation + rotation);
          float cosAngle = cos(angle);
          float sinAngle = sin(angle);
          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);

          quadOffset.xy = rotate * quadOffset.xy;
        `)}

      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;
  `,U=t.pixelSnappingEnabled?i?S.H`posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;`:S.H`posProj += quadOffset;
if (inputSize.x == size.x) {
posProj = alignToPixelOrigin(posProj, viewport.zw);
}`:S.H`posProj += quadOffset;`;V.main.add(S.H`
    ${Z}
    ${t.vvColor?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;"}

    ${(0,S.If)(I===a.V.ObjectAndLayerIdColor,S.H`vcolor.a = 1.0;`)}

    bool alphaDiscard = vcolor.a < ${S.H.float(R.Q)};
    ${(0,S.If)(i,`alphaDiscard = alphaDiscard && outlineColor.a < ${S.H.float(R.Q)};`)}
    if (alphaDiscard) {
      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent
      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
      return;
    } else {
      ${U}
      gl_Position = posProj;
    }

    vtc = uv;

    ${(0,S.If)(t.debugDrawLabelBorder,S.H`debugBorderCoords = vec4(uv01, 1.5 / combinedSize);`)}
    vsize = inputSize;
  `),L.uniforms.add(new b.N("tex",(t=>t.texture))),t.occludedFragmentFade&&(L.uniforms.add(new P.x("depthMap",(t=>t.mainDepth))),L.uniforms.add(new C.U("occludedOpacity",(t=>t.hudOccludedFragmentOpacity))));const W=t.debugDrawLabelBorder?S.H`(isBorder > 0.0 ? 0.0 : ${S.H.float(R.Q)})`:S.H.float(R.Q),$=S.H`
    ${(0,S.If)(t.debugDrawLabelBorder,S.H`float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));`)}

    ${(0,S.If)(t.sampleSignedDistanceFieldTexelCenter,S.H`
      float txSize = float(textureSize(tex, 0).x);
      float texelSize = 1.0 / txSize;

      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel
      vec2 scaleFactor = (vsize - txSize) * texelSize;
      vec2 samplePos = vtc + (vec2(1.0, -1.0) * texelSize) * scaleFactor;`,S.H`vec2 samplePos = vtc;`)}

    ${i?S.H`
      vec4 fillPixelColor = vcolor;

      // Get distance and map it into [-0.5, 0.5]
      float d = rgbaTofloat(texture(tex, samplePos)) - 0.5;

      // Distance in output units (i.e. pixels)
      float dist = d * vsize.x;

      // Create smooth transition from the icon into its outline
      float fillAlphaFactor = clamp(0.5 - dist, 0.0, 1.0);
      fillPixelColor.a *= fillAlphaFactor;

      if (outlineSize > 0.25) {
        vec4 outlinePixelColor = outlineColor;
        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);

        // Create smooth transition around outline
        float outlineAlphaFactor = clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);
        outlinePixelColor.a *= outlineAlphaFactor;

        if (
          outlineAlphaFactor + fillAlphaFactor < ${W} ||
          fillPixelColor.a + outlinePixelColor.a < ${S.H.float(R.Q)}
        ) {
          discard;
        }

        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)
        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);
        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +
          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);

        ${(0,S.If)(!N,S.H`fragColor = vec4(compositeColor, compositeAlpha);`)}
      } else {
        if (fillAlphaFactor < ${W}) {
          discard;
        }

        ${(0,S.If)(!N,S.H`fragColor = premultiplyAlpha(fillPixelColor);`)}
      }

      // visualize SDF:
      // fragColor = vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);
      `:S.H`
          vec4 texColor = texture(tex, vtc, -0.5);
          if (texColor.a < ${W}) {
            discard;
          }
          ${(0,S.If)(!N,S.H`fragColor = texColor * premultiplyAlpha(vcolor);`)}
          `}

    ${(0,S.If)(t.occludedFragmentFade&&!N,S.H`
        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;
        if (zSample < gl_FragCoord.z) {
          fragColor *= occludedOpacity;
        }
        `)}

    ${(0,S.If)(!N&&t.debugDrawLabelBorder,S.H`fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);`)}
  `;switch(I){case a.V.Color:case a.V.ColorEmission:e.outputs.add("fragColor","vec4",0),I===a.V.ColorEmission&&e.outputs.add("fragEmission","vec4",1),H===D.Y.ColorAlpha&&e.outputs.add("fragAlpha","float",I===a.V.ColorEmission?2:1),L.main.add(S.H`
        ${$}
        ${(0,S.If)(H===D.Y.FrontFace,S.H`fragColor.rgb /= fragColor.a;`)}
        ${(0,S.If)(I===a.V.ColorEmission,S.H`fragEmission = vec4(0.0);`)}
        ${(0,S.If)(H===D.Y.ColorAlpha,S.H`fragAlpha = fragColor.a;`)}`);break;case a.V.ObjectAndLayerIdColor:L.main.add(S.H`
        ${$}
        outputObjectAndLayerIdColor();`);break;case a.V.Highlight:e.include(f.Q,t),L.main.add(S.H`
        ${$}
        outputHighlight(${(0,S.If)(B,S.H`voccluded == 1.0`,S.H`false`)});`)}return e}function F(t){return t.outlineColor[3]>0&&t.outlineSize>0}function z(t){return t.textureIsSignedDistanceField?(e=t.anchorPosition,i=t.distanceFieldBoundingBox,o=j,(0,r.hZ)(o,e[0]*(i[2]-i[0])+i[0],e[1]*(i[3]-i[1])+i[1])):(0,r.C)(j,t.anchorPosition),j;var e,i,o}const j=(0,o.vt)(),H=Object.freeze(Object.defineProperty({__proto__:null,build:I,calculateAnchorPosition:z},Symbol.toStringTag,{value:"Module"}))},60216:(t,e,i)=>{i.d(e,{E:()=>s});var r=i(9392),o=(i(9624),i(14487));function s(t,e,i){return!!(0,o.F)(t,e,n,i.spatialReference)&&(i.x=n[0],i.y=n[1],i.z=n[2],!0)}const n=(0,r.vt)()},57481:(t,e,i)=>{i.d(e,{U:()=>s});var r=i(93345),o=i(21812);function s(t,e=0){const i=t.stride;return Array.from(t.fields.keys()).map((r=>{const s=t.fields.get(r),a=s.constructor.ElementCount,l=n(s.constructor.ElementType),c=s.offset,h=s.optional?.glNormalized??!1;return new o._(r,a,l,c,i,h,e)}))}function n(t){const e=a[t];if(e)return e;throw new Error("BufferType not supported in WebGL")}const a={u8:r.pe.UNSIGNED_BYTE,u16:r.pe.UNSIGNED_SHORT,u32:r.pe.UNSIGNED_INT,i8:r.pe.BYTE,i16:r.pe.SHORT,i32:r.pe.INT,f32:r.pe.FLOAT}},38280:(t,e,i)=>{i.d(e,{I:()=>n});var r=i(98720),o=i(94192),s=i(86955);function n(t,e){const{vertex:i,fragment:n}=t;t.include(o.Z,e),i.include(r.K),i.main.add(s.H`vec4 posProjCenter;
if (dot(position, position) > 0.0) {
ProjectHUDAux projectAux;
vec4 posProj = projectPositionHUD(projectAux);
posProjCenter = alignToPixelCenter(posProj, viewport.zw);
forwardViewPosDepth(projectAux.posView);
vec3 vpos = projectAux.posModel;
if (rejectBySlice(vpos)) {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
} else {
posProjCenter = vec4(1e038, 1e038, 1e038, 1.0);
}
gl_Position = posProjCenter;
gl_PointSize = 1.0;`),n.main.add(s.H`fragColor = vec4(1);
if(discardByTerrainDepth()) {
fragColor.g = 0.5;
}`)}},60586:(t,e,i)=>{i.d(e,{Cc:()=>l,RW:()=>a});var r=i(91967),o=i(34981);const s={required:[]};o.V.Depth;class n extends r.A{precompile(t){return!!this.acquireTechniques(t)}consumes(){return s}get usedMemory(){return 0}get isDecoration(){return!1}get running(){return!1}modify(t){}get numGeometries(){return 0}get hasOccludees(){return!1}get hasEmissions(){return!1}forEachGeometry(t){}queryRenderOccludedState(t){return!1}}class a extends n{}class l extends n{}},69008:(t,e,i)=>{i.d(e,{Z:()=>o});var r=i(36911);class o extends r.Z{}},12536:(t,e,i)=>{i.d(e,{R:()=>G});var r=i(15941),o=i(63919),s=i(44680),n=i(34761),a=i(13191),l=i(19555),c=i(72745),h=i(20664),p=i(9392),u=i(55855);function d(t){return function(t){return t instanceof Float32Array&&t.length>=16}(t)||function(t){return Array.isArray(t)&&t.length>=16}(t)}var f=i(2413),v=i(88105),_=i(63048),g=i(22955),m=i(48549),w=i(34981),y=i(40318),x=i(61785),T=i(75803),M=i(45463),C=i(77730),O=i(12028),S=i(86994),P=i(66470);class b{constructor(){this.scale=0,this.factor=0,this.minScaleFactor=0}}var D=i(52757),A=i(99362),E=i(19061),R=i(16506),I=i(59246),F=i(72001),z=i(60322),j=i(93345),H=i(57162);class V extends I.w{constructor(t,e){super(t,e,new R.$(E.H,(()=>i.e(60271).then(i.bind(i,60271))))),this.primitiveType=e.occlusionPass?j.WR.POINTS:j.WR.TRIANGLES}initializePipeline(t){const{oitPass:e,hasPolygonOffset:i,draped:r,output:o,depthTestEnabled:s,occlusionPass:n}=t,a=e===F.Y.NONE,l=e===F.Y.ColorAlpha,c=o===w.V.Highlight,h=s&&!r&&!l&&!n&&!c;return(0,H.Ey)({blending:(0,w.RN)(o)?a?H.Os:(0,z.ez)(e):null,depthTest:s&&!r?{func:j.MT.LEQUAL}:null,depthWrite:h?H.Uy:null,drawBuffers:(0,z.m6)(e,o),colorWrite:H.kn,polygonOffset:i?L:null})}}const L={factor:0,units:-4};var N=i(35143),B=i(97808),Z=i(42717),U=i(6485),W=i(94570);class $ extends W.E{constructor(t){super(),this.spherical=t,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.vvSize=!1,this.vvColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.objectAndLayerIdColorInstanced=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.textureCoordinateType=B.I.None,this.emissionSource=Z.ZX.None,this.discardInvisibleFragments=!0,this.hasVvInstancing=!1}}(0,N._)([(0,U.W)()],$.prototype,"screenCenterOffsetUnitsEnabled",void 0),(0,N._)([(0,U.W)()],$.prototype,"occlusionTestEnabled",void 0),(0,N._)([(0,U.W)()],$.prototype,"signedDistanceFieldEnabled",void 0),(0,N._)([(0,U.W)()],$.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),(0,N._)([(0,U.W)()],$.prototype,"vvSize",void 0),(0,N._)([(0,U.W)()],$.prototype,"vvColor",void 0),(0,N._)([(0,U.W)()],$.prototype,"hasVerticalOffset",void 0),(0,N._)([(0,U.W)()],$.prototype,"hasScreenSizePerspective",void 0),(0,N._)([(0,U.W)()],$.prototype,"hasRotation",void 0),(0,N._)([(0,U.W)()],$.prototype,"debugDrawLabelBorder",void 0),(0,N._)([(0,U.W)()],$.prototype,"hasPolygonOffset",void 0),(0,N._)([(0,U.W)()],$.prototype,"depthTestEnabled",void 0),(0,N._)([(0,U.W)()],$.prototype,"pixelSnappingEnabled",void 0),(0,N._)([(0,U.W)()],$.prototype,"draped",void 0),(0,N._)([(0,U.W)()],$.prototype,"terrainDepthTest",void 0),(0,N._)([(0,U.W)()],$.prototype,"cullAboveTerrain",void 0),(0,N._)([(0,U.W)()],$.prototype,"occlusionPass",void 0),(0,N._)([(0,U.W)()],$.prototype,"occludedFragmentFade",void 0),(0,N._)([(0,U.W)()],$.prototype,"objectAndLayerIdColorInstanced",void 0),(0,N._)([(0,U.W)()],$.prototype,"horizonCullingEnabled",void 0),(0,N._)([(0,U.W)()],$.prototype,"isFocused",void 0);var q=i(75569);class G extends M.im{constructor(t,e){super(t,_t),this.produces=new Map([[C.N.HUD_MATERIAL,t=>(0,w.Mb)(t)&&!this.parameters.drawAsLabel],[C.N.LABEL_MATERIAL,t=>(0,w.Mb)(t)&&this.parameters.drawAsLabel],[C.N.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[C.N.DRAPED_MATERIAL,t=>this.parameters.draped&&(0,w.Mb)(t)]]),this._visible=!0,this._configuration=new $(e)}getConfiguration(t,e){return this._configuration.output=t,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=e.slot===C.N.OCCLUSION_PIXELS,this._configuration.occludedFragmentFade=this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||e.slot===C.N.OCCLUSION_PIXELS,(0,w.RN)(t)&&(this._configuration.debugDrawLabelBorder=!!g.b.LABELS_SHOW_BORDER),this._configuration.oitPass=e.oitPass,this._configuration.terrainDepthTest=e.terrainDepthTest,this._configuration.cullAboveTerrain=e.cullAboveTerrain,this._configuration}intersect(t,e,i,r,s,a){const{options:{selectionMode:l,hud:c,excludeLabels:u},point:d,camera:f}=i,{parameters:v}=this;if(!l||!c||u&&v.isLabel||!t.visible||!d)return;const{scaleX:_,scaleY:g}=this._getScreenScale(t,f.pixelRatio);(0,o.z0)(st,e),t.attributes.has(P.r.FEATUREATTRIBUTE)&&function(t){const e=t[0],i=t[1],r=t[2],o=t[3],s=t[4],n=t[5],a=t[6],l=t[7],c=t[8],h=1/Math.sqrt(e*e+i*i+r*r),p=1/Math.sqrt(o*o+s*s+n*n),u=1/Math.sqrt(a*a+l*l+c*c);t[0]=e*h,t[1]=i*h,t[2]=r*h,t[3]=o*p,t[4]=s*p,t[5]=n*p,t[6]=a*u,t[7]=l*u,t[8]=c*u}(st);const m=t.attributes.get(P.r.POSITION),w=t.attributes.get(P.r.SIZE),y=t.attributes.get(P.r.NORMAL),x=t.attributes.get(P.r.ROTATION),T=t.attributes.get(P.r.CENTEROFFSETANDDISTANCE);(0,S.vA)(m.size>=3);const M=(0,E.c)(v),C="screen"===this.parameters.centerOffsetUnits;for(let o=0;o<m.data.length/m.size;o++){const t=o*m.size;(0,h.i)(J,m.data[t],m.data[t+1],m.data[t+2]),(0,h.t)(J,J,e),(0,h.t)(J,J,f.viewMatrix);const r=o*T.size;if((0,h.i)(lt,T.data[r],T.data[r+1],T.data[r+2]),!C&&(J[0]+=lt[0],J[1]+=lt[1],0!==lt[2])){const t=lt[2];(0,h.n)(lt,J),(0,h.d)(J,J,(0,h.h)(lt,lt,t))}const s=o*y.size;if((0,h.i)(K,y.data[s],y.data[s+1],y.data[s+2]),k(K,st,f,pt),this._applyVerticalOffsetTransformationView(J,pt,f,Q),f.applyProjection(J,tt),tt[0]>-1){C&&(lt[0]||lt[1])&&(tt[0]+=lt[0]*f.pixelRatio,0!==lt[1]&&(tt[1]+=(0,O.m0)(lt[1],Q.factorAlignment)*f.pixelRatio),f.unapplyProjection(tt,J)),tt[0]+=this.parameters.screenOffset[0]*f.pixelRatio,tt[1]+=this.parameters.screenOffset[1]*f.pixelRatio,tt[0]=Math.floor(tt[0]),tt[1]=Math.floor(tt[1]);const t=o*w.size;ft[0]=w.data[t],ft[1]=w.data[t+1],(0,O.MD)(ft,Q.factor,ft);const e=ut*f.pixelRatio;let r=0;v.textureIsSignedDistanceField&&(r=Math.min(v.outlineSize,.5*ft[0])*f.pixelRatio/2),ft[0]*=_,ft[1]*=g;const s=o*x.size,l=v.rotation+x.data[s];if(X(d,tt[0],tt[1],ft,e,r,l,v,M)){const t=i.ray;if((0,h.t)(it,J,(0,n.B8)(at,f.viewMatrix)),tt[0]=d[0],tt[1]=d[1],f.unprojectFromRenderScreen(tt,J)){const e=(0,p.vt)();(0,h.c)(e,t.direction);const i=1/(0,h.l)(e);(0,h.h)(e,e,i),a((0,h.j)(t.origin,J)*i,e,-1,!0,1,it)}}}}}intersectDraped(t,e,i,r,o,s){const n=t.attributes.get(P.r.POSITION),a=t.attributes.get(P.r.SIZE),l=t.attributes.get(P.r.ROTATION),c=this.parameters,h=(0,E.c)(c),{scaleX:p,scaleY:u}=this._getScreenScale(t,t.screenToWorldRatio),d=dt*t.screenToWorldRatio;for(let f=0;f<n.data.length/n.size;f++){const e=f*n.size,i=n.data[e],v=n.data[e+1],_=f*a.size;ft[0]=a.data[_],ft[1]=a.data[_+1];let g=0;c.textureIsSignedDistanceField&&(g=Math.min(c.outlineSize,.5*ft[0])*t.screenToWorldRatio/2),ft[0]*=p,ft[1]*=u;const m=f*l.size,w=c.rotation+l.data[m];X(r,i,v,ft,d,g,w,c,h)&&o(s.dist,s.normal,-1,!1)}}createBufferWriter(){return new wt}_updateScaleInfo(t,e,i){const r=this.parameters;null!=r.screenSizePerspective?(0,O.cJ)(i,e,r.screenSizePerspective,t.factor):(t.factor.scale=1,t.factor.factor=0,t.factor.minScaleFactor=0),null!=r.screenSizePerspectiveAlignment?(0,O.cJ)(i,e,r.screenSizePerspectiveAlignment,t.factorAlignment):(t.factorAlignment.factor=t.factor.factor,t.factorAlignment.scale=t.factor.scale,t.factorAlignment.minScaleFactor=t.factor.minScaleFactor)}applyShaderOffsetsView(t,e,i,r,o,s,n){const a=k(e,i,o,pt);return this._applyVerticalGroundOffsetView(t,a,o,n),this._applyVerticalOffsetTransformationView(n,a,o,s),this._applyPolygonOffsetView(n,a,r[3],o,n),this._applyCenterOffsetView(n,r,n),n}applyShaderOffsetsNDC(t,e,i,r,o){return this._applyCenterOffsetNDC(t,e,i,r),null!=o&&(0,h.c)(o,r),this._applyPolygonOffsetNDC(r,e,i,r),r}_applyPolygonOffsetView(t,e,i,o,s){const n=o.aboveGround?1:-1;let a=Math.sign(i);0===a&&(a=n);const l=n*a;if(this.parameters.shaderPolygonOffset<=0)return(0,h.c)(s,t);const c=(0,r.qE)(Math.abs(e.cosAngle),.01,1),p=1-Math.sqrt(1-c*c)/c/o.viewport[2];return(0,h.h)(s,t,l>0?p:1/p),s}_applyVerticalGroundOffsetView(t,e,i,r){const o=(0,h.l)(t),s=i.aboveGround?1:-1,n=i.computeRenderPixelSizeAtDist(o)*y.R,a=(0,h.h)(J,e.normal,s*n);return(0,h.g)(r,t,a),r}_applyVerticalOffsetTransformationView(t,e,i,r){const o=this.parameters;if(!o.verticalOffset?.screenLength){if(o.screenSizePerspective||o.screenSizePerspectiveAlignment){const i=(0,h.l)(t);this._updateScaleInfo(r,i,e.cosAngle)}else r.factor.scale=1,r.factorAlignment.scale=1;return t}const s=(0,h.l)(t),n=o.screenSizePerspectiveAlignment??o.screenSizePerspective,a=(0,A.kE)(i,s,o.verticalOffset,e.cosAngle,n);return this._updateScaleInfo(r,s,e.cosAngle),(0,h.h)(e.normal,e.normal,a),(0,h.g)(t,t,e.normal)}_applyCenterOffsetView(t,e,i){const r="screen"!==this.parameters.centerOffsetUnits;return i!==t&&(0,h.c)(i,t),r&&(i[0]+=e[0],i[1]+=e[1],e[2]&&((0,h.n)(K,i),(0,h.g)(i,i,(0,h.h)(K,K,e[2])))),i}_applyCenterOffsetNDC(t,e,i,r){const o="screen"!==this.parameters.centerOffsetUnits;return r!==t&&(0,h.c)(r,t),o||(r[0]+=e[0]/i.fullWidth*2,r[1]+=e[1]/i.fullHeight*2),r}_applyPolygonOffsetNDC(t,e,i,r){const o=this.parameters.shaderPolygonOffset;if(t!==r&&(0,h.c)(r,t),o){const t=i.aboveGround?1:-1,s=t*Math.sign(e[3]);r[2]-=(s||t)*o}return r}set visible(t){this._visible=t}get visible(){const{color:t,outlineSize:e,outlineColor:i}=this.parameters,r=t[3]>=q.Q||e>=q.Q&&i[3]>=q.Q;return this._visible&&r}createGLMaterial(t){return new Y(t)}calculateRelativeScreenBounds(t,e,i=(0,f.vt)()){return function(t,e,i,r){r[0]=t.anchorPosition[0]*-e[0]+t.screenOffset[0]*i,r[1]=t.anchorPosition[1]*-e[1]+t.screenOffset[1]*i}(this.parameters,t,e,i),i[2]=i[0]+t[0],i[3]=i[1]+t[1],i}_getScreenScale(t,e){const i=t.attributes.get(P.r.FEATUREATTRIBUTE);if(null==i)return{scaleX:e,scaleY:e};const r=(0,u.ci)(i.data,ht);return(0,_.VC)(ct,this.parameters,r),{scaleX:ct[0]*e,scaleY:ct[1]*e}}}class Y extends T.m8{constructor(t){super({...t,...t.material.parameters})}beginSlot(t){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(V,t)}}function k(t,e,i,r){return d(e)&&(e=(0,o.z0)(nt,e)),(0,h.q)(r.normal,t,e),(0,h.t)(r.normal,r.normal,i.viewInverseTransposeMatrix),r.cosAngle=(0,h.f)(et,vt),r}function X(t,e,i,o,s,n,a,c,h){let p=e-s-o[0]*h[0],u=p+o[0]+2*s,d=i-s-o[1]*h[1],f=d+o[1]+2*s;const v=c.distanceFieldBoundingBox;return c.textureIsSignedDistanceField&&null!=v&&(p+=o[0]*v[0],d+=o[1]*v[1],u-=o[0]*(1-v[2]),f-=o[1]*(1-v[3]),p-=n,u+=n,d-=n,f+=n),(0,l.hZ)(ot,e,i),(0,l.e$)(rt,t,ot,(0,r.kU)(a)),rt[0]>p&&rt[0]<u&&rt[1]>d&&rt[1]<f}const Q=new class{constructor(){this.factor=new b,this.factorAlignment=new b}},J=(0,p.vt)(),K=(0,p.vt)(),tt=(0,u.vt)(),et=(0,p.vt)(),it=(0,p.vt)(),rt=(0,c.vt)(),ot=(0,c.vt)(),st=(0,s.vt)(),nt=(0,s.vt)(),at=(0,a.vt)(),lt=(0,p.vt)(),ct=(0,p.vt)(),ht=(0,u.vt)(),pt={normal:et,cosAngle:0},ut=1,dt=2,ft=[0,0],vt=(0,p.fA)(0,0,1);class _t extends T.NV{constructor(){super(...arguments),this.renderOccluded=M.m$.Occlude,this.isDecoration=!1,this.color=(0,u.CN)(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=(0,c.fA)(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=(0,u.CN)(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=(0,u.vt)(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusEffect="none",this.draped=!1,this.isLabel=!1}}const gt=(0,m.BP)().vec3f(P.r.POSITION).vec3f(P.r.NORMAL).vec2f(P.r.UV0).vec4u8(P.r.COLOR).vec2f(P.r.SIZE).f32(P.r.ROTATION).vec4f(P.r.CENTEROFFSETANDDISTANCE).vec4f(P.r.FEATUREATTRIBUTE),mt=gt.clone().vec4u8(P.r.OBJECTANDLAYERIDCOLOR);class wt{constructor(){this.vertexBufferLayout=(0,x.E)()?mt:gt}elementCount(t){return 6*t.get(P.r.POSITION).indices.length}write(t,e,i,r,o,s){(0,D.Hk)(i.get(P.r.POSITION),t,o.position,s,6),(0,D.p1)(i.get(P.r.NORMAL),e,o.normal,s,6);const n=i.get(P.r.UV0)?.data;let a=0,l=0,c=1,h=1;n&&n.length>=4&&(a=n[0],l=n[1],c=n[2],h=n[3]),c=Math.min(1.99999,c+1),h=Math.min(1.99999,h+1);let p=i.get(P.r.POSITION).indices.length,u=s;const d=o.uv0;for(let v=0;v<p;++v)d.set(u,0,a),d.set(u,1,l),u++,d.set(u,0,c),d.set(u,1,l),u++,d.set(u,0,c),d.set(u,1,h),u++,d.set(u,0,c),d.set(u,1,h),u++,d.set(u,0,a),d.set(u,1,h),u++,d.set(u,0,a),d.set(u,1,l),u++;(0,D.tb)(i.get(P.r.COLOR),4,o.color,s,6);const{data:f,indices:_}=i.get(P.r.SIZE);p=_.length;const g=o.size;u=s;for(let v=0;v<p;++v){const t=f[2*_[v]],e=f[2*_[v]+1];for(let i=0;i<6;++i)g.set(u,0,t),g.set(u,1,e),u++}if((0,D.uO)(i.get(P.r.ROTATION),o.rotation,s,6),i.get(P.r.CENTEROFFSETANDDISTANCE)?(0,D.Ut)(i.get(P.r.CENTEROFFSETANDDISTANCE),o.centerOffsetAndDistance,s,6):(0,D.Pq)(o.centerOffsetAndDistance,s,6*p),i.get(P.r.FEATUREATTRIBUTE)?(0,D.Ut)(i.get(P.r.FEATUREATTRIBUTE),o.featureAttribute,s,6):(0,D.Pq)(o.featureAttribute,s,6*p),null!=r){const t=i.get(P.r.POSITION)?.indices;if(t){const e=t.length,i=o.getField(P.r.OBJECTANDLAYERIDCOLOR,v.XP);(0,D.tH)(r,i,e,s,6)}}}}},57583:(t,e,i)=>{i.d(e,{A:()=>S});var r=i(35143),o=i(91967),s=i(76460),n=i(15941),a=i(76931),l=i(46053),c=(i(81806),i(47249),i(85842)),h=i(34761),p=i(13191),u=i(19555),d=i(72745),f=i(20664),v=i(9392),_=i(43047),g=i(55855),m=i(4763),w=i(95925),y=i(96190),x=i(64465);var T,M,C;i(30015);!function(t){t[t.Default=0]="Default",t[t.Screenshot=1]="Screenshot",t[t.ObjectAndLayerID=2]="ObjectAndLayerID"}(T||(T={})),function(t){t[t.TOP=0]="TOP",t[t.RIGHT=1]="RIGHT",t[t.BOTTOM=2]="BOTTOM",t[t.LEFT=3]="LEFT"}(M||(M={}));let O=C=class extends o.A{constructor(t){super(t),this._ray=(0,w.vt)(),this._viewport=(0,g.fA)(0,0,1,1),this._padding=(0,g.fA)(0,0,0,0),this._fov=55/180*Math.PI,this._nearFar=(0,d.fA)(1,1e3),this._viewDirty=!0,this._viewMatrix=(0,p.vt)(),this._viewProjectionDirty=!0,this._viewProjectionMatrix=(0,p.vt)(),this._viewInverseTransposeMatrixDirty=!0,this._viewInverseTransposeMatrix=(0,p.vt)(),this._frustumDirty=!0,this._frustum=(0,m.vt)(),this._fullViewport=(0,g.vt)(),this._pixelRatio=1,this.row=0,this.column=0,this._rows=1,this._columns=1,this._center=(0,v.vt)(),this._up=(0,v.vt)(),this.relativeElevation=0}get pixelRatio(){return this._pixelRatio}set pixelRatio(t){this._pixelRatio=t>0?t:1}get rows(){return this._rows}set rows(t){this._rows=Math.max(1,t)}get columns(){return this._columns}set columns(t){this._columns=Math.max(1,t)}get eye(){return this._ray.origin}set eye(t){this._compareAndSetView(t,this._ray.origin)}get center(){return this._center}set center(t){this._compareAndSetView(t,this._center,"_center")}get ray(){return(0,f.d)(this._ray.direction,this.center,this.eye),this._ray}get up(){return this._up}set up(t){this._compareAndSetView(t,this._up,"_up")}get viewMatrix(){return this._ensureViewClean(),this._viewMatrix}set viewMatrix(t){(0,h.C)(this._viewMatrix,t),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0,this._viewProjectionDirty=!0,this._frustumDirty=!0}get viewForward(){return this._ensureViewClean(),(0,f.i)((0,v.vt)(),-this._viewMatrix[2],-this._viewMatrix[6],-this._viewMatrix[10])}get viewUp(){return this._ensureViewClean(),(0,f.i)((0,v.vt)(),this._viewMatrix[1],this._viewMatrix[5],this._viewMatrix[9])}get viewRight(){return this._ensureViewClean(),(0,f.i)((0,v.vt)(),this._viewMatrix[0],this._viewMatrix[4],this._viewMatrix[8])}get nearFar(){return this._nearFar}get near(){return this._nearFar[0]}set near(t){this._nearFar[0]!==t&&(this._nearFar[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get far(){return this._nearFar[1]}set far(t){this._nearFar[1]!==t&&(this._nearFar[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_nearFar"))}get viewport(){return this._viewport}set viewport(t){this.x=t[0],this.y=t[1],this.width=t[2],this.height=t[3]}get screenViewport(){if(1===this.pixelRatio)return this._viewport;const t=(0,_.b)((0,g.vt)(),this._viewport,1/this.pixelRatio),e=this._get("screenViewport");return e&&(0,_.e)(t,e)?e:t}get screenPadding(){if(1===this.pixelRatio)return this._padding;const t=(0,_.b)((0,g.vt)(),this._padding,1/this.pixelRatio),e=this._get("screenPadding");return e&&(0,_.e)(t,e)?e:t}get x(){return this._viewport[0]}set x(t){t+=this._padding[M.LEFT],this._viewport[0]!==t&&(this._viewport[0]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get y(){return this._viewport[1]}set y(t){t+=this._padding[M.BOTTOM],this._viewport[1]!==t&&(this._viewport[1]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get width(){return this._viewport[2]}set width(t){this._viewport[2]!==t&&(this._viewport[2]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get height(){return this._viewport[3]}set height(t){this._viewport[3]!==t&&(this._viewport[3]=t,this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_viewport"))}get fullWidth(){return this._viewport[2]+this._padding[M.RIGHT]+this._padding[M.LEFT]}set fullWidth(t){this.width=t-(this._padding[M.RIGHT]+this._padding[M.LEFT])}get fullHeight(){return this._viewport[3]+this._padding[M.TOP]+this._padding[M.BOTTOM]}set fullHeight(t){this.height=t-(this._padding[M.TOP]+this._padding[M.BOTTOM])}get fullViewport(){return this._fullViewport[0]=this._viewport[0]-this._padding[M.LEFT],this._fullViewport[1]=this._viewport[1]-this._padding[M.BOTTOM],this._fullViewport[2]=this.fullWidth,this._fullViewport[3]=this.fullHeight,this._fullViewport}get _aspect(){return this.width/this.height}get padding(){return this._padding}set padding(t){(0,_.a)(this._padding,t)||(this._viewport[0]+=t[M.LEFT]-this._padding[M.LEFT],this._viewport[1]+=t[M.BOTTOM]-this._padding[M.BOTTOM],this._viewport[2]-=t[M.RIGHT]+t[M.LEFT]-(this._padding[M.RIGHT]+this._padding[M.LEFT]),this._viewport[3]-=t[M.TOP]+t[M.BOTTOM]-(this._padding[M.TOP]+this._padding[M.BOTTOM]),(0,_.c)(this._padding,t),this._viewProjectionDirty=!0,this._frustumDirty=!0,this.notifyChange("_padding"),this.notifyChange("_viewport"))}get viewProjectionMatrix(){return this._viewProjectionDirty&&((0,h.lw)(this._viewProjectionMatrix,this.projectionMatrix,this.viewMatrix),this._viewProjectionDirty=!1),this._viewProjectionMatrix}get projectionMatrix(){return this._projectionMatrixInternal}get inverseProjectionMatrix(){return(0,h.B8)((0,p.vt)(),this.projectionMatrix)||this._get("inverseProjectionMatrix")||(0,p.vt)()}get fov(){return this._fov}set fov(t){this._fov=t,this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovX(){return function(t,e,i){return 2*Math.atan(e*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}(this._fov,this.width,this.height)}set fovX(t){this._fov=function(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/e)}(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get fovY(){return function(t,e,i){return 2*Math.atan(i*Math.tan(.5*t)/Math.sqrt(e*e+i*i))}(this._fov,this.width,this.height)}set fovY(t){this._fov=function(t,e,i){return 2*Math.atan(Math.sqrt(e*e+i*i)*Math.tan(.5*t)/i)}(t,this.width,this.height),this._viewProjectionDirty=!0,this._frustumDirty=!0}get distance(){return(0,f.j)(this.center,this.eye)}get frustum(){return this._recomputeFrustum(),this._frustum}get viewInverseTransposeMatrix(){return(this._viewInverseTransposeMatrixDirty||this._viewDirty)&&((0,h.B8)(this._viewInverseTransposeMatrix,this.viewMatrix),(0,h.mg)(this._viewInverseTransposeMatrix,this._viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),this._viewInverseTransposeMatrix}depthNDCToWorld(t){const{near:e,far:i}=this;return 2*e*i/(i+e-t*(i-e))}get perRenderPixelRatio(){return Math.tan(this.fovX/2)/(this.width/2)}get perScreenPixelRatio(){return this.perRenderPixelRatio*this.pixelRatio}get aboveGround(){return null!=this.relativeElevation&&this.relativeElevation>=0}get _projectionMatrixInternal(){const t=this.width,e=this.height,i=this.near*Math.tan(this.fovY/2)*2,r=i*this._aspect,o=i/this.rows,s=r/this.columns,n=-r/2+this.column*s,a=n+s,l=-i/2+this.row*o,c=l+o,u=(0,h.$h)((0,p.vt)(),n*(1+2*this._padding[M.LEFT]/t),a*(1+2*this._padding[M.RIGHT]/t),l*(1+2*this._padding[M.BOTTOM]/e),c*(1+2*this._padding[M.TOP]/e),this.near,this.far),d=this._get("projectionMatrix");return d&&(0,h.aI)(d,u)?d:u}copyFrom(t){(0,f.c)(this._ray.origin,t.eye),this.center=t.center,this.up=t.up,(0,_.c)(this._viewport,t.viewport),this.notifyChange("_viewport"),(0,_.c)(this._padding,t.padding),this.notifyChange("_padding"),(0,u.C)(this._nearFar,t.nearFar),this.notifyChange("_nearFar"),this._fov=t.fov,this.row=t.row,this.column=t.column,this.rows=t.rows,this.columns=t.columns,this.relativeElevation=t.relativeElevation;const e=t;return this._viewDirty=e._viewDirty,this._viewDirty||((0,h.C)(this._viewMatrix,t.viewMatrix),this.notifyChange("_viewMatrix")),this._viewProjectionDirty=!0,this._frustumDirty=e._frustumDirty,this._frustumDirty||((0,m.C)(this._frustum,t.frustum),this._frustumDirty=!1),e._viewInverseTransposeMatrixDirty?this._viewInverseTransposeMatrixDirty=!0:((0,h.C)(this._viewInverseTransposeMatrix,t.viewInverseTransposeMatrix),this._viewInverseTransposeMatrixDirty=!1),(0,_.c)(this._fullViewport,t.fullViewport),this.pixelRatio=t.pixelRatio,this}copyViewFrom(t){this.eye=t.eye,this.center=t.center,this.up=t.up,this.fov=t.fov}clone(){return(new C).copyFrom(this)}equals(t){return(0,f.p)(this.eye,t.eye)&&(0,f.p)(this.center,t.center)&&(0,f.p)(this.up,t.up)&&(0,_.a)(this._viewport,t.viewport)&&(0,_.a)(this._padding,t.padding)&&(0,u.t2)(this.nearFar,t.nearFar)&&this._fov===t.fov&&this.pixelRatio===t.pixelRatio&&this.relativeElevation===t.relativeElevation&&this.row===t.row&&this.column===t.column&&this.rows===t.rows&&this.columns===t.columns}almostEquals(t){const e=Math.max(1,1/this.pixelRatio,1/t.pixelRatio);if(Math.abs(t.fov-this._fov)>=.001||(0,_.d)(t.screenPadding,this.screenPadding)>=e||(0,_.d)(this.screenViewport,t.screenViewport)>=e||this.row!==t.row||this.column!==t.column||this.rows!==t.rows||this.columns!==t.columns)return!1;(0,f.a)(D,t.eye,t.center),(0,f.a)(A,this.eye,this.center);const i=(0,f.f)(D,A),r=(0,f.z)(D),o=(0,f.z)(A),s=5e-4;return i*i>=(1-1e-10)*r*o&&(0,f.y)(t.eye,this.eye)<Math.max(r,o)*s*s}computeRenderPixelSizeAt(t){return this.computeRenderPixelSizeAtDist(this._viewDirectionDistance(t))}computeRenderPixelSizeAtDist(t){return t*this.perRenderPixelRatio}computeScreenPixelSizeAt(t){return this.computeScreenPixelSizeAtDist(this._viewDirectionDistance(t))}_viewDirectionDistance(t){return Math.abs((0,y.gr)(this.viewForward,(0,f.d)(D,t,this.eye)))}computeScreenPixelSizeAtDist(t){return t*this.perScreenPixelRatio}computeDistanceFromRadius(t,e){return t/Math.tan(Math.min(this.fovX,this.fovY)/(2*(e||1)))}getScreenCenter(t=(0,a.gs)()){return t[0]=(this.padding[M.LEFT]+this.width/2)/this.pixelRatio,t[1]=(this.padding[M.TOP]+this.height/2)/this.pixelRatio,t}getRenderCenter(t,e=.5,i=.5){return t[0]=this.padding[M.LEFT]+this.width*e,t[1]=this.padding[M.BOTTOM]+this.height*i,t[2]=.5,t}setGLViewport(t){const e=this.viewport,i=this.padding;t.setViewport(e[0]-i[3],e[1]-i[2],e[2]+i[1]+i[3],e[3]+i[0]+i[2])}applyProjection(t,e){t!==P&&(0,f.c)(P,t),P[3]=1,(0,_.t)(P,P,this.projectionMatrix);const i=Math.abs(P[3]);(0,f.h)(P,P,1/i);const r=this.fullViewport;e[0]=(0,n.Cc)(0,r[0]+r[2],.5+.5*P[0]),e[1]=(0,n.Cc)(0,r[1]+r[3],.5+.5*P[1]),e[2]=.5*(P[2]+1),e[3]=i}unapplyProjection(t,e){const i=this.fullViewport;P[0]=(t[0]/(i[0]+i[2])*2-1)*t[3],P[1]=(t[1]/(i[1]+i[3])*2-1)*t[3],P[2]=(2*t[2]-1)*t[3],P[3]=t[3],null!=this.inverseProjectionMatrix&&((0,_.t)(P,P,this.inverseProjectionMatrix),e[0]=P[0],e[1]=P[1],e[2]=P[2])}projectToScreen(t,e){return this.projectToRenderScreen(t,E),this.renderToScreen(E,e),e}projectToRenderScreen(t,e){if(P[0]=t[0],P[1]=t[1],P[2]=t[2],P[3]=1,(0,_.t)(P,P,this.viewProjectionMatrix),0===P[3])return null;const i=P;(0,f.h)(i,i,1/Math.abs(P[3]));const r=this.fullViewport,o=(0,n.Cc)(0,r[0]+r[2],.5+.5*i[0]),s=(0,n.Cc)(0,r[1]+r[3],.5+.5*i[1]);return"x"in e?(e.x=o,e.y=s):(e[0]=o,e[1]=s,e.length>2&&(e[2]=.5*(i[2]+1))),e}unprojectFromScreen(t,e){return this.unprojectFromRenderScreen(this.screenToRender(t,E),e)}unprojectFromRenderScreen(t,e){if((0,h.lw)(b,this.projectionMatrix,this.viewMatrix),!(0,h.B8)(b,b))return null;const i=this.fullViewport;return P[0]=2*(t[0]-i[0])/i[2]-1,P[1]=2*(t[1]-i[1])/i[3]-1,P[2]=2*t[2]-1,P[3]=1,(0,_.t)(P,P,b),0===P[3]?null:(e[0]=P[0]/P[3],e[1]=P[1]/P[3],e[2]=P[2]/P[3],e)}constrainWindowSize(t,e,i,r){const o=t*this.pixelRatio,s=e*this.pixelRatio,n=Math.max(o-i/2,0),a=Math.max(this.fullHeight-s-r/2,0),l=-Math.min(o-i/2,0),c=-Math.min(this.fullHeight-s-r/2,0),h=i-l- -Math.min(this.fullWidth-o-i/2,0),p=r-c- -Math.min(s-r/2,0);return[Math.round(n),Math.round(a),Math.round(h),Math.round(p)]}computeUp(t){t===x.RT.Global?this._computeUpGlobal():this._computeUpLocal()}screenToRender(t,e){const i=t[0]*this.pixelRatio,r=this.fullHeight-t[1]*this.pixelRatio;return e[0]=i,e[1]=r,e}renderToScreen(t,e){const i=t[0]/this.pixelRatio,r=(this.fullHeight-t[1])/this.pixelRatio;e[0]=i,e[1]=r}_computeUpGlobal(){(0,f.d)(D,this.center,this.eye);const t=(0,f.l)(this.center);t<1?((0,f.i)(this._up,0,0,1),this._markViewDirty(),this.notifyChange("_up")):Math.abs((0,f.f)(D,this.center))>.9999*(0,f.l)(D)*t||((0,f.e)(this._up,D,this.center),(0,f.e)(this._up,this._up,D),(0,f.n)(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_computeUpLocal(){(0,f.o)(D,this.eye,this.center),Math.abs(D[2])<=.9999&&((0,f.h)(D,D,D[2]),(0,f.i)(this._up,-D[0],-D[1],1-D[2]),(0,f.n)(this._up,this._up),this.notifyChange("_up"),this._markViewDirty())}_compareAndSetView(t,e,i=""){"number"==typeof t[0]&&isFinite(t[0])&&"number"==typeof t[1]&&isFinite(t[1])&&"number"==typeof t[2]&&isFinite(t[2])?(0,f.p)(t,e)||((0,f.c)(e,t),this._markViewDirty(),i.length&&this.notifyChange(i)):s.A.getLogger("esri.views.3d.webgl-engine.lib.RenderCamera").warn("RenderCamera vector contains invalid number, ignoring value")}_markViewDirty(){this._viewDirty=!0,this._frustumDirty=!0,this._viewProjectionDirty=!0}_recomputeFrustum(){this._frustumDirty&&((0,m.ui)(this.viewMatrix,this.projectionMatrix,this._frustum),this._frustumDirty=!1)}_ensureViewClean(){this._viewDirty&&((0,h.t5)(this._viewMatrix,this.eye,this.center,this.up),this.notifyChange("_viewMatrix"),this._viewDirty=!1,this._viewInverseTransposeMatrixDirty=!0)}};(0,r._)([(0,l.MZ)()],O.prototype,"_viewport",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_padding",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_fov",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_nearFar",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_viewDirty",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_viewMatrix",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_pixelRatio",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"pixelRatio",null),(0,r._)([(0,l.MZ)()],O.prototype,"row",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"column",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"_rows",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"rows",null),(0,r._)([(0,l.MZ)()],O.prototype,"_columns",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"columns",null),(0,r._)([(0,l.MZ)()],O.prototype,"eye",null),(0,r._)([(0,l.MZ)()],O.prototype,"center",null),(0,r._)([(0,l.MZ)()],O.prototype,"_center",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"up",null),(0,r._)([(0,l.MZ)()],O.prototype,"_up",void 0),(0,r._)([(0,l.MZ)()],O.prototype,"viewMatrix",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"viewForward",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"viewUp",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"viewRight",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"nearFar",null),(0,r._)([(0,l.MZ)()],O.prototype,"near",null),(0,r._)([(0,l.MZ)()],O.prototype,"far",null),(0,r._)([(0,l.MZ)()],O.prototype,"viewport",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"screenViewport",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"screenPadding",null),(0,r._)([(0,l.MZ)()],O.prototype,"x",null),(0,r._)([(0,l.MZ)()],O.prototype,"y",null),(0,r._)([(0,l.MZ)()],O.prototype,"width",null),(0,r._)([(0,l.MZ)()],O.prototype,"height",null),(0,r._)([(0,l.MZ)()],O.prototype,"fullWidth",null),(0,r._)([(0,l.MZ)()],O.prototype,"fullHeight",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"_aspect",null),(0,r._)([(0,l.MZ)()],O.prototype,"padding",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"projectionMatrix",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"inverseProjectionMatrix",null),(0,r._)([(0,l.MZ)()],O.prototype,"fov",null),(0,r._)([(0,l.MZ)()],O.prototype,"fovX",null),(0,r._)([(0,l.MZ)()],O.prototype,"fovY",null),(0,r._)([(0,l.MZ)()],O.prototype,"viewInverseTransposeMatrix",null),(0,r._)([(0,l.MZ)({readOnly:!0})],O.prototype,"_projectionMatrixInternal",null),(0,r._)([(0,l.MZ)()],O.prototype,"relativeElevation",void 0),O=C=(0,r._)([(0,c.$)("esri.views.3d.webgl.RenderCamera")],O);const S=O,P=(0,g.vt)(),b=(0,p.vt)(),D=(0,v.vt)(),A=(0,v.vt)(),E=(0,a.r_)()}}]);
//# sourceMappingURL=11811.56c37960.chunk.js.map