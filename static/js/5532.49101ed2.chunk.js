"use strict";(globalThis.webpackChunkmy_app=globalThis.webpackChunkmy_app||[]).push([[5532],{25532:(e,t,s)=>{s.r(t),s.d(t,{uploadAssets:()=>w});var a=s(76200),r=s(10064),n=s(32718),o=s(66978),i=s(35995),l=s(71907),u=s(17493),c=s(25899);const p=1e6,d=20*p;async function f(e,t,s){let{data:r,name:n,description:l}=e,u=null;try{const e=(0,i.v_)(t,"uploads"),f=(0,i.v_)(e,"info"),{data:y}=await(0,a.default)(f,{query:{f:"json"},responseType:"json"});(0,o.k_)(s);const w=(0,c.M8)(t),m=y.maxUploadFileSize*p,h=w?2e9:m,g=w?Math.min(d,m):d;if(r.size>h)throw new Error("Data too large");const T=(0,i.v_)(e,"register"),{data:b}=await(0,a.default)(T,{query:{f:"json",itemName:n,description:l},responseType:"json",method:"post"});if((0,o.k_)(s),!b.success)throw new Error("Registration failed");const{itemID:v}=b.item;u=(0,i.v_)(e,v);const E=(0,i.v_)(u,"uploadPart"),_=Math.ceil(r.size/g),$=new Array;for(let t=0;t<_;++t)$.push(r.slice(t*g,Math.min((t+1)*g,r.size)));const j=$.slice().reverse(),F=new Array,k=async()=>{for(;0!==j.length;){const e=$.length-j.length,t=j.pop(),r=new FormData;r.append("f","json"),r.append("file",t),r.append("partId",`${e}`);const{data:n}=await(0,a.default)(E,{timeout:0,body:r,responseType:"json",method:"post"});if((0,o.k_)(s),!n.success)throw new Error("Part upload failed")}};for(let t=0;t<3&&0!==j.length;++t)F.push(k());await Promise.all(F);const D=(0,i.v_)(u,"commit"),{data:U}=await(0,a.default)(D,{query:{f:"json",parts:$.map(((e,t)=>t)).join(",")},responseType:"json",method:"post"});if((0,o.k_)(s),!U.success)throw new Error("Commit failed");return U.item}catch(f){if(null!=u){const e=(0,i.v_)(u,"delete");await(0,a.default)(e,{query:{f:"json"},responseType:"json",method:"post"})}throw f}}var y=s(18277);async function w(e,t,s){return e.length?Promise.all(e.map((e=>async function(e,t,s){let{layer:a,ongoingUploads:n}=t;const i=n.get(e);if(i)return i;if(!function(e){return!!e.infoFor3D&&!!e.url}(a))throw new r.Z(`${a.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(function(e,t){const{parsedUrl:s}=t;return null!=s&&e.metadata.externalSources.some((e=>(0,u.JG)(e,s)))}(e,a))return e;const c=async function(e,t,s){const{metadata:a}=e,{displaySource:n}=a,i=m(n?.source,t),u=!!i,c=a.externalSources.length>0,p=u?async function(e,t,s){return{source:await g(e,t,s),original:!0}}(i,t,s):c?async function(e,t,s){const a=v(t),{externalSources:n}=e.metadata,o=function(e,t){for(const s of e){const e=m(s.source,t);if(e)return e}return null}(n,t);if(!o)throw new r.Z(`${t.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const i=await g(o,t,s);return e.addExternalSources([{source:i,original:!0}]),{source:await b(i,t,a)}}(e,t,s):async function(e,t,s){const a=async function(e,t,s){const a=v(t),r=await e.load(s),n=await r.toBinaryGLTF({ignoreLocalTransform:!0});(0,o.k_)(s);const i=await n.buffer();return(0,o.k_)(s),{blob:new Blob([i.data],{type:i.type}),assetName:`${(0,l.z)()}.glb`,assetType:a}}(e,t,s);return{source:await T([a],t,s),extent:e.extent.clone(),original:!0}}(e,t,s),d=await p;return(0,o.k_)(s),e.addExternalSources([d]),e}(e,a,s);n.set(e,c);try{await c}finally{n.delete(e)}return e}(e,t,s)))):[]}function m(e,t){if(!e)return null;const{infoFor3D:{supportedFormats:s,editFormats:a}}=t,r=(0,u.zE)(e),n=new Array;let o=!1;for(let i=0;i<r.length;++i){const e=h(r[i],s);if(!e)return null;a.includes(e.assetType)&&(o=!0),n.push(e)}return o?n:null}function h(e,t){const s=(0,u.vj)(e,t);return s?{asset:e,assetType:s}:null}async function g(e,t,s){return T(e.map((e=>async function(e,t){const{asset:s,assetType:a}=e;if(s instanceof File)return{blob:s,assetName:s.name,assetType:a};const r=await s.toBlob(t);return(0,o.k_)(t),{blob:r,assetName:s.assetName,assetType:a}}(e,s))),t,s)}async function T(e,t,s){const l=await Promise.all(e.map((async e=>{const a=async function(e,t,s){const{blob:a,assetType:l,assetName:u}=e;let c=null;try{const e=await f({data:a,name:u},t.url,s);(0,o.k_)(s),c={assetType:l,assetUploadId:e.itemID}}catch(p){(0,o.r9)(p),n.Z.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${t.url} does not support the REST Uploads API.`)}if(!c){const e=await(0,i.IR)(a);if((0,o.k_)(s),!e.isBase64)throw new r.Z(`${t.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);c={assetType:l,assetData:e.data}}if(!c)throw new r.Z(`${t.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:c,assetName:u}}(await e,t,s);return(0,o.k_)(s),a})));(0,o.k_)(s);const{uploadResults:c}=await async function(e,t,s){const n=await(0,a.default)((0,i.v_)(t.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if((0,o.k_)(s),n.data.uploadResults.length!==e.length)throw new r.Z(`${t.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${e.length} items and received ${n.data.uploadResults.length} results.`,new Error);return n.data}(l.map((e=>{let{item:t}=e;return t})),t,s);return(0,o.k_)(s),e.map(((e,s)=>function(e,t,s){const{success:a}=t;if(!a){const{error:a}=t;throw new r.Z(`${s.type}-layer:upload-failure`,`Failed to upload mesh file ${e.assetName}. Error code: ${a.code}. Error message: ${a.messages}`,new Error)}const{assetHash:n}=t,{assetName:o,item:{assetType:i}}=e,{infoFor3D:{supportedFormats:l}}=s,c=(0,y.d1)(i,l);if(!c)throw new r.Z(`${s.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${i}, but it does not list it in its supported formats.`,new Error);return new u.CP(o,c,[new u.LL(`${s.parsedUrl.path}/assets/${n}`,n)])}(l[s],c[s],t)))}async function b(e,t,s){const n=e.map((e=>{let{assetName:t,parts:s}=e;return{assetName:t,assetHash:s[0].partHash}})),l=t.capabilities?.operations.supportsAsyncConvert3D,c={query:{f:"json",assets:JSON.stringify(n),transportType:"esriTransportTypeUrl",targetFormat:s,async:l},responseType:"json",timeout:0},p=(0,i.v_)(t.parsedUrl.path,"convert3D"),d=(l?await async function(e,t){const s=(await(0,a.default)(e,t)).data.statusUrl;for(;;){const e=(await(0,a.default)(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return(0,a.default)(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new r.Z("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new r.Z("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await(0,o.e4)(E)}}(p,c):await(0,a.default)(p,c)).data,{infoFor3D:{supportedFormats:f}}=t;return d.assets.map((e=>{const s=(0,y.S0)(e.contentType,f);if(!s)throw new r.Z(`${t.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${s}, but it does not list it in its supported formats.`,new Error);return new u.CP(e.assetName,e.contentType,[new u.LL(e.assetURL,e.assetHash)])}))}function v(e){const{infoFor3D:t}=e,s=(0,y.S0)("model/gltf-binary",t.supportedFormats)??(0,y.Ow)("glb",t.supportedFormats);if(!s)throw new r.Z(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return s}const E=1e3}}]);
//# sourceMappingURL=5532.49101ed2.chunk.js.map