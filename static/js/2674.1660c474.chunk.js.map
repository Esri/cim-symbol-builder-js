{"version":3,"file":"static/js/2674.1660c474.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/node_modules/focus-trap/dist/focus-trap.esm.js","../node_modules/@esri/calcite-components/dist/esm/src/utils/focusTrapComponent.ts","../node_modules/@esri/calcite-components/dist/esm/src/utils/loadable.ts"],"sourcesContent":["/*!\n* focus-trap 7.6.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { isFocusable, tabbable, focusable, isTabbable, getTabIndex } from 'tabbable';\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n    return true; // next\n  });\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","import { createFocusTrap, FocusTrap as _FocusTrap, Options as FocusTrapOptions } from \"focus-trap\";\nimport { FocusableElement, focusElement, tabbableOptions } from \"./dom\";\nimport { focusTrapStack } from \"./config\";\n\n/**\n * Defines interface for components with a focus trap. Focusable content is required for components implementing focus trapping with this interface.\n */\nexport interface FocusTrapComponent {\n  /**\n   * The focus trap element.\n   */\n  el: HTMLElement;\n\n  /**\n   * When `true`, prevents focus trapping.\n   */\n  focusTrapDisabled?: boolean;\n\n  /**\n   * The focus trap instance.\n   */\n  focusTrap: FocusTrap;\n\n  /**\n   * Method to update the element(s) that are used within the FocusTrap component.\n   *\n   * This should be implemented for components that allow user content and/or have conditionally-rendered focusable elements within the trap.\n   */\n  updateFocusTrapElements?: () => Promise<void>;\n}\n\nexport type FocusTrap = _FocusTrap;\n\ninterface ConnectFocusTrapOptions {\n  /**\n   * This option allows the focus trap to be created on a different element that's not the host (e.g., a supporting popup component).\n   */\n  focusTrapEl?: HTMLElement;\n\n  /**\n   * This allows specifying overrides to ConnectFocusTrap options.\n   */\n  focusTrapOptions?: Omit<FocusTrapOptions, \"document\" | \"tabbableOptions\" | \"trapStack\">;\n}\n\n/**\n * Helper to set up the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param options\n */\nexport function connectFocusTrap(component: FocusTrapComponent, options?: ConnectFocusTrapOptions): void {\n  const { el } = component;\n  const focusTrapNode = options?.focusTrapEl || el;\n\n  if (!focusTrapNode) {\n    return;\n  }\n\n  const focusTrapOptions: FocusTrapOptions = {\n    clickOutsideDeactivates: true,\n    escapeDeactivates: false,\n    fallbackFocus: focusTrapNode,\n    setReturnFocus: (el) => {\n      focusElement(el as FocusableElement);\n      return false;\n    },\n    ...options?.focusTrapOptions,\n\n    // the following options are not overridable\n    document: el.ownerDocument,\n    tabbableOptions,\n    trapStack: focusTrapStack,\n  };\n\n  component.focusTrap = createFocusTrap(focusTrapNode, focusTrapOptions);\n}\n\n/**\n * Helper to activate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap activate options.\n */\nexport function activateFocusTrap(\n  component: FocusTrapComponent,\n  options?: Parameters<_FocusTrap[\"activate\"]>[0],\n): void {\n  if (!component.focusTrapDisabled) {\n    component.focusTrap?.activate(options);\n  }\n}\n\n/**\n * Helper to deactivate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap deactivate options.\n */\nexport function deactivateFocusTrap(\n  component: FocusTrapComponent,\n  options?: Parameters<_FocusTrap[\"deactivate\"]>[0],\n): void {\n  component.focusTrap?.deactivate(options);\n}\n\n/**\n * Helper to update the element(s) that are used within the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @example\n * const modal = document.querySelector(\"calcite-modal\");\n * const input = document.createElement(\"calcite-input\");\n * content.appendChild(input);\n * await input.componentOnReady();\n * await modal.updateFocusTrapElements();\n * requestAnimationFrame(() => input.setFocus());\n */\nexport function updateFocusTrapElements(component: FocusTrapComponent): void {\n  component.focusTrap?.updateContainerElements(component.el);\n}\n","import { forceUpdate } from \"@stencil/core\";\nimport { isBrowser } from \"./browser\";\n\n/**\n * This helper adds support for knowing when a component has been loaded.\n *\n * Related issue: https://github.com/Esri/calcite-design-system/issues/5369\n * Could be related to Stencil.js issue: https://github.com/ionic-team/stencil/issues/3580\n *\n * Implementing\n *\n * ```\n * export class MyComponent implements LoadableComponent { }\n * ```\n *\n * ```\n *  //--------------------------------------------------------------------------\n *  //\n *  //  Lifecycle\n *  //\n *  //--------------------------------------------------------------------------\n *\n *  componentWillLoad(): void {\n *    setUpLoadableComponent(this);\n *  }\n *\n *  componentDidLoad(): void {\n *    setComponentLoaded(this);\n *  }\n *\n *  // --------------------------------------------------------------------------\n *  //\n *  //  Methods\n *  //\n *  // --------------------------------------------------------------------------\n *\n *  async myMethod(): Promise<void> {\n *    await componentLoaded(this);\n *  }\n * ```\n */\nexport interface LoadableComponent {\n  /**\n   * Stencil lifecycle method.\n   * https://stenciljs.com/docs/component-lifecycle#componentwillload\n   *\n   * Called once just after the component is first connected to the DOM. Since this method is only called once, it's a good place to load data asynchronously and to setup the state without triggering extra re-renders.\n   */\n  componentWillLoad: () => Promise<void> | void;\n\n  /**\n   * Stencil lifecycle method.\n   * https://stenciljs.com/docs/component-lifecycle#componentdidload\n   *\n   * Called once just after the component is fully loaded and the first render() occurs.\n   */\n  componentDidLoad: () => Promise<void> | void;\n}\n\nconst resolveMap = new WeakMap<LoadableComponent, (value: void | PromiseLike<void>) => void>();\n\nconst promiseMap = new WeakMap<LoadableComponent, Promise<void>>();\n\n/**\n * This helper util sets up the component for the ability to know when the component has been loaded.\n *\n * This should be used in the `componentWillLoad` lifecycle hook.\n *\n * ```\n * componentWillLoad(): void {\n *   setUpLoadableComponent(this);\n * }\n * ```\n *\n * @param component\n */\nexport function setUpLoadableComponent(component: LoadableComponent): void {\n  promiseMap.set(component, new Promise((resolve) => resolveMap.set(component, resolve)));\n}\n\n/**\n * This helper util lets the loadable component know that it is now loaded.\n *\n * This should be used in the `componentDidLoad` lifecycle hook.\n *\n * ```\n * componentDidLoad(): void {\n *   setComponentLoaded(this);\n * }\n * ```\n *\n * @param component\n */\nexport function setComponentLoaded(component: LoadableComponent): void {\n  resolveMap.get(component)();\n}\n\n/**\n * This helper util can be used to ensure a component has been loaded (The \"componentDidLoad\" Stencil lifecycle method has been called).\n *\n * Requires requires `LoadableComponent` to be implemented.\n *\n * A component developer can await this method before proceeding with any logic that requires a component to be loaded first.\n *\n * ```\n * async myMethod(): Promise<void> {\n *   await componentLoaded(this);\n * }\n * ```\n *\n * @param component\n * @returns Promise<void>\n */\nexport function componentLoaded(component: LoadableComponent): Promise<void> {\n  return promiseMap.get(component);\n}\n\n/**\n * This helper util can be used to ensuring the component is loaded and rendered by the browser (The \"componentDidLoad\" Stencil lifecycle method has been called and any internal elements are focusable).\n *\n * Requires `LoadableComponent` to be implemented.\n *\n * A component developer can await this method before proceeding with any logic that requires a component to be loaded first and then an internal element be focused.\n *\n * ```\n * async setFocus(): Promise<void> {\n *   await componentFocusable(this);\n *   this.internalElement?.focus();\n * }\n * ```\n *\n * @param component\n * @returns Promise<void>\n */\nexport async function componentFocusable(component: LoadableComponent): Promise<void> {\n  await componentLoaded(component);\n\n  if (!isBrowser()) {\n    return;\n  }\n\n  forceUpdate(component);\n  return new Promise((resolve) => requestAnimationFrame(() => resolve()));\n}\n"],"names":["_defineProperty","e","r","t","i","Symbol","toPrimitive","call","TypeError","String","Number","_toPrimitive","_toPropertyKey","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","activeFocusTraps","trapStack","trap","activeTrap","pause","trapIndex","indexOf","splice","unpause","isTabEvent","key","keyCode","isKeyForward","shiftKey","isKeyBackward","delay","fn","setTimeout","findIndex","arr","idx","every","valueOrHandler","_len","params","Array","_key","getActualTarget","event","target","shadowRoot","composedPath","internalTrapStack","createFocusTrap","elements","userOptions","doc","document","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","active","paused","delayInitialFocusTimer","undefined","recentNavEvent","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","element","_ref","container","tabbableNodes","contains","includes","find","node","getNodeForOption","optionValue","_len2","_key2","Error","concat","querySelector","getInitialFocusNode","isFocusable","tabbableOptions","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","tabbable","focusableNodes","focusable","lastTabbableNode","firstDomTabbableNode","isTabbable","lastDomTabbableNode","slice","reverse","posTabIndexesFound","getTabIndex","nextTabbableNode","forward","nodeIdx","el","group","g","_getActiveElement","_tryFocus","focus","preventScroll","tagName","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref3","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","preventDefault","checkFocusIn","targetContained","Document","nextNode","stopImmediatePropagation","navAcrossContainers","mruContainerIdx","mruTabIdx","some","n","checkTabKey","checkKeyNav","checkEscapeKey","checkClick","addListeners","addEventListener","capture","passive","removeListeners","removeEventListener","mutationObserver","window","MutationObserver","mutations","mutation","from","removedNodes","updateObservedNodes","disconnect","observe","subtree","childList","activate","activateOptions","this","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","options","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","updateContainerElements","containerElements","elementsAsArray","Boolean","connectFocusTrap","component","focusTrapNode","focusTrapEl","focusTrapOptions","fallbackFocus","setReturnFocus","focusElement","ownerDocument","focusTrapStack","focusTrap","activateFocusTrap","focusTrapDisabled","deactivateFocusTrap","updateFocusTrapElements","resolveMap","WeakMap","promiseMap","setUpLoadableComponent","set","Promise","resolve","setComponentLoaded","get","componentLoaded","async","componentFocusable","isBrowser","forceUpdate","requestAnimationFrame"],"sourceRoot":""}