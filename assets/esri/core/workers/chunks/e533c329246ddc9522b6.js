"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[3804],{35982:(e,t,r)=>{r.d(t,{B:()=>c});var s=r(4576),i=r(36563),n=r(53966),a=r(74887),o=r(29953);class c{constructor(e,t,r,s,i={}){this._mainMethod=t,this._transferLists=r,this._listeners=[],this._promise=(0,o.ho)(e,{...i,schedule:s}).then((e=>{if(void 0===this._thread){this._thread=e,this._promise=null,i.hasInitialize&&this.broadcast({},"initialize");for(const e of this._listeners)this._connectListener(e)}else e.close()})),this._promise.catch((t=>n.A.getLogger("esri.core.workers.WorkerHandle").error(`Failed to initialize ${e} worker: ${t}`)))}on(e,t){const r={removed:!1,eventName:e,callback:t,threadHandle:null};return this._listeners.push(r),this._connectListener(r),(0,i.hA)((()=>{r.removed=!0,(0,s.TF)(this._listeners,r),this._thread&&null!=r.threadHandle&&r.threadHandle.remove()}))}destroy(){this._thread&&(this._thread.close(),this._thread=null),this._promise=null,this._listeners.length=0,this._transferLists={}}invoke(e,t){return this.invokeMethod(this._mainMethod,e,t)}invokeMethod(e,t,r){if(this._thread){const s=this._transferLists[e],i=s?s(t):[];return this._thread.invoke(e,t,{transferList:i,signal:r})}return this._promise?this._promise.then((()=>((0,a.Te)(r),this.invokeMethod(e,t,r)))):Promise.reject(null)}broadcast(e,t){return this._thread?Promise.all(this._thread.broadcast(t,e)).then((()=>{})):this._promise?this._promise.then((()=>this.broadcast(e,t))):Promise.reject()}get promise(){return this._promise}_connectListener(e){this._thread&&this._thread.on(e.eventName,e.callback).then((t=>{e.removed||(e.threadHandle=t)}))}}},36421:(e,t,r)=>{var s;r.d(t,{p:()=>s}),function(e){e[e.Texture=0]="Texture",e[e.RenderBuffer=1]="RenderBuffer"}(s||(s={}))},14113:(e,t,r)=>{r.d(t,{N5:()=>c});var s=r(49186),i=(r(44208),r(53966)),n=r(69270);const a=()=>i.A.getLogger("esri.views.3d.webgl-engine.core.shaderModules.shaderBuilder");class o{constructor(){this._includedModules=new Map}include(e,t){this._includedModules.has(e)?this._includedModules.get(e):(this._includedModules.set(e,t),e(this.builder,t))}}class c extends o{constructor(){super(...arguments),this.vertex=new _,this.fragment=new _,this.attributes=new d,this.varyings=new m,this.extensions=new p,this.outputs=new A}get fragmentUniforms(){return this.fragment.uniforms.entries}get builder(){return this}generate(e,t=!1){const r=this.extensions.generateSource(e),s=this.attributes.generateSource(e),i=this.varyings.generateSource(e),n="vertex"===e?this.vertex:this.fragment,a=n.uniforms.generateSource(),o=n.code.generateSource(),c=n.main.generateSource(t),l="vertex"===e?T:g,h=n.constants.generateSource(),u=this.outputs.generateSource(e);return`#version 300 es\n${r.join("\n")}\n${l}\n${h.join("\n")}\n${a.join("\n")}\n${s.join("\n")}\n${i.join("\n")}\n${u.join("\n")}\n${o.join("\n")}\n${c.join("\n")}`}generateBind(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[n.c.Bind];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[n.c.Bind];r&&t.set(e.name,r)}));const r=Array.from(t.values()),s=r.length;return t=>{for(let i=0;i<s;++i)r[i](e,t)}}generateBindPass(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[n.c.Pass];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[n.c.Pass];r&&t.set(e.name,r)}));const r=Array.from(t.values()),s=r.length;return(t,i)=>{for(let n=0;n<s;++n)r[n](e,t,i)}}generateBindDraw(e){const t=new Map;this.vertex.uniforms.entries.forEach((e=>{const r=e.bind[n.c.Draw];r&&t.set(e.name,r)})),this.fragment.uniforms.entries.forEach((e=>{const r=e.bind[n.c.Draw];r&&t.set(e.name,r)}));const r=Array.from(t.values()),s=r.length;return(t,i,n)=>{for(let a=0;a<s;++a)r[a](e,n,t,i)}}}class l{constructor(e){this._stage=e,this._entries=new Map}add(...e){for(const t of e)this._add(t);return this._stage}get(e){return this._entries.get(e)}_add(e){if(null!=e){if(this._entries.has(e.name)&&!this._entries.get(e.name).equals(e))throw new s.A(`Duplicate uniform name ${e.name} for different uniform type`);this._entries.set(e.name,e)}else a().error(`Trying to add null Uniform from ${(new Error).stack}.`)}generateSource(){return Array.from(this._entries.values()).map((e=>null!=e.arraySize?`uniform ${e.type} ${e.name}[${e.arraySize}];`:`uniform ${e.type} ${e.name};`))}get entries(){return Array.from(this._entries.values())}}class h{constructor(e){this._stage=e,this._bodies=new Array}add(e){return this._bodies.push(e),this._stage}generateSource(e){if(this._bodies.length>0)return[`void main() {\n ${this._bodies.join("\n")||""} \n}`];if(e)throw new s.A("Shader does not contain main function body.");return[]}}class u{constructor(e){this._stage=e,this._entries=new Array}add(e){return this._entries.push(e),this._stage}generateSource(){return this._entries}}class _ extends o{constructor(){super(...arguments),this.uniforms=new l(this),this.main=new h(this),this.code=new u(this),this.constants=new E(this)}get builder(){return this}}class d{constructor(){this._entries=new Array}add(e,t){this._entries.push([e,t])}generateSource(e){return"fragment"===e?[]:this._entries.map((e=>`in ${e[1]} ${e[0]};`))}}class m{constructor(){this._entries=new Map}add(e,t){this._entries.has(e)?a().warn(`Ignoring duplicate varying ${t} ${e}`):this._entries.set(e,t)}generateSource(e){const t=new Array;return this._entries.forEach(((r,s)=>t.push("vertex"===e?`out ${r} ${s};`:`in ${r} ${s};`))),t}}class p{constructor(){this._entries=new Set}add(e){this._entries.add(e)}generateSource(e){const t="vertex"===e?p.ALLOWLIST_VERTEX:p.ALLOWLIST_FRAGMENT;return Array.from(this._entries).filter((e=>t.includes(e))).map((e=>`#extension ${e} : enable`))}}p.ALLOWLIST_FRAGMENT=["GL_EXT_shader_texture_lod","GL_OES_standard_derivatives"],p.ALLOWLIST_VERTEX=[];class A{constructor(){this._entries=new Map}add(e,t,r=0){const s=this._entries.get(r);s?.name!==e||s?.type!==t?this._entries.set(r,{name:e,type:t}):a().warn(`Fragment shader output location ${r} occupied`)}generateSource(e){if("vertex"===e)return[];0===this._entries.size&&this._entries.set(0,{name:A.DEFAULT_NAME,type:A.DEFAULT_TYPE});const t=new Array;return this._entries.forEach(((e,r)=>t.push(`layout(location = ${r}) out ${e.type} ${e.name};`))),t}}A.DEFAULT_TYPE="vec4",A.DEFAULT_NAME="fragColor";class E{constructor(e){this._stage=e,this._entries=new Set}add(e,t,r){let s="ERROR_CONSTRUCTOR_STRING";switch(t){case"float":s=E._numberToFloatStr(r);break;case"int":s=E._numberToIntStr(r);break;case"bool":s=r.toString();break;case"vec2":s=`vec2(${E._numberToFloatStr(r[0])},                            ${E._numberToFloatStr(r[1])})`;break;case"vec3":s=`vec3(${E._numberToFloatStr(r[0])},                            ${E._numberToFloatStr(r[1])},                            ${E._numberToFloatStr(r[2])})`;break;case"vec4":s=`vec4(${E._numberToFloatStr(r[0])},                            ${E._numberToFloatStr(r[1])},                            ${E._numberToFloatStr(r[2])},                            ${E._numberToFloatStr(r[3])})`;break;case"ivec2":s=`ivec2(${E._numberToIntStr(r[0])},                             ${E._numberToIntStr(r[1])})`;break;case"ivec3":s=`ivec3(${E._numberToIntStr(r[0])},                             ${E._numberToIntStr(r[1])},                             ${E._numberToIntStr(r[2])})`;break;case"ivec4":s=`ivec4(${E._numberToIntStr(r[0])},                             ${E._numberToIntStr(r[1])},                             ${E._numberToIntStr(r[2])},                             ${E._numberToIntStr(r[3])})`;break;case"mat2":case"mat3":case"mat4":s=`${t}(${Array.prototype.map.call(r,(e=>E._numberToFloatStr(e))).join(", ")})`}return this._entries.add(`const ${t} ${e} = ${s};`),this._stage}static _numberToIntStr(e){return e.toFixed(0)}static _numberToFloatStr(e){return Number.isInteger(e)?e.toFixed(1):e.toString()}generateSource(){return Array.from(this._entries)}}const g="#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n  precision highp int;\n  precision highp sampler2D;\n#else\n  precision mediump float;\n  precision mediump int;\n  precision mediump sampler2D;\n#endif",T="precision highp float;\nprecision highp sampler2D;"},4172:(e,t,r)=>{r.d(t,{g:()=>f});var s=r(49186),i=(r(44208),r(53966)),n=r(97768),a=r(74887),o=r(44794);(r(36708),r(35982)).B;new Set;var c=r(94656),l=r(63907),h=r(36421),u=r(67171);function _(e){(null!=e.width&&e.width<0||null!=e.height&&e.height<0||null!=e.depth&&e.depth<0)&&i.A.getLogger("esri/views/webgl/textureUtils").error("Negative dimension parameters are not allowed!")}function d(e){return null!=e&&"type"in e&&"compressed"===e.type}function m(e){return null!=e&&!d(e)&&!function(e){return null!=e&&"byteLength"in e}(e)}function p(e){return e===l.Ap.TEXTURE_3D||e===l.Ap.TEXTURE_2D_ARRAY}function A(e,t,r,s=1){let i=Math.max(t,r);return e===l.Ap.TEXTURE_3D&&(i=Math.max(i,s)),Math.floor(Math.log2(i))+1}function E(e){if(null!=e.internalFormat)return e.internalFormat===l.Ab.DEPTH_STENCIL?l.Ab.DEPTH24_STENCIL8:e.internalFormat;switch(e.dataType){case l.ld.FLOAT:switch(e.pixelFormat){case l.Ab.RGBA:return l.H0.RGBA32F;case l.Ab.RGB:return l.H0.RGB32F;default:throw new s.A("Unable to derive format")}case l.ld.UNSIGNED_BYTE:switch(e.pixelFormat){case l.Ab.RGBA:return l.H0.RGBA8;case l.Ab.RGB:return l.H0.RGB8}}return e.internalFormat=e.pixelFormat===l.Ab.DEPTH_STENCIL?l.Ab.DEPTH24_STENCIL8:e.pixelFormat}class g extends u.R{constructor(e,t){switch(super(),this.context=e,Object.assign(this,t),this.internalFormat){case l.H0.R16F:case l.H0.R16I:case l.H0.R16UI:case l.H0.R32F:case l.H0.R32I:case l.H0.R32UI:case l.H0.R8_SNORM:case l.H0.R8:case l.H0.R8I:case l.H0.R8UI:this.pixelFormat=l.Ab.RED}}static validate(e,t){return new g(e,t)}}const T=()=>i.A.getLogger("esri/views/webgl/Texture");let f=class e{constructor(e,t=null,r=null){if(this.type=h.p.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._wasImmutablyAllocated=!1,this._compressionAbortController=(0,o.v)(null),"context"in e)this._descriptor=e,r=t;else{const r=g.validate(e,t);if(!r)throw new s.A("Texture descriptor invalid");this._descriptor=r}this._descriptor.target===l.Ap.TEXTURE_CUBE_MAP?this._setDataCubeMap(r):this.setData(r)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return(0,u.e)(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty}get isCompressing(){return null!==this._compressionAbortController.value}dispose(){this.abortCompression(),this._glName&&this._descriptor.context.instanceCounter.decrement(l.vt.Texture,this),this._descriptor.context.gl&&this._glName&&(this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,t){const r=this._descriptor;if(r.width!==e||r.height!==t){if(this._wasImmutablyAllocated)throw new s.A("Immutable textures can't be resized!");r.width=e,r.height=t,this._descriptor.target===l.Ap.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(e){this._descriptor.shouldCompress=e}setData(e){this.abortCompression(),!d(e)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in l.CQ&&(this._descriptor.internalFormat=void 0),this._setData(e)}updateData(t,r,i,n,a,o,c=0){o||T().error("An attempt to use uninitialized data!"),this._glName||T().error("An attempt to update uninitialized texture!");const l=this._descriptor;l.internalFormat=E(l);const{context:h,pixelFormat:u,dataType:_,target:p,isImmutable:A}=l;if(A&&!this._wasImmutablyAllocated)throw new s.A("Cannot update immutable texture before allocation!");const g=h.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES,!0);(r<0||i<0||r+n>l.width||i+a>l.height)&&T().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:f}=h;c&&(n&&a||T().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),f.pixelStorei(f.UNPACK_SKIP_ROWS,c)),m(o)?f.texSubImage2D(p,t,r,i,n,a,u,_,o):d(o)?f.compressedTexSubImage2D(p,t,r,i,n,a,l.internalFormat,o.levels[t]):f.texSubImage2D(p,t,r,i,n,a,u,_,o),c&&f.pixelStorei(f.UNPACK_SKIP_ROWS,0),h.bindTexture(g,e.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(t,r,i,n,a,o,c,l){l||T().error("An attempt to use uninitialized data!"),this._glName||T().error("An attempt to update an uninitialized texture!");const h=this._descriptor;h.internalFormat=E(h);const{context:u,pixelFormat:_,dataType:m,isImmutable:A,target:g}=h;if(A&&!this._wasImmutablyAllocated)throw new s.A("Cannot update immutable texture before allocation!");p(g)||T().warn("Attempting to set 3D texture data on a non-3D texture");const f=u.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);u.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),(r<0||i<0||n<0||r+a>h.width||i+o>h.height||n+c>h.depth)&&T().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:R}=u;if(d(l))l=l.levels[t],R.compressedTexSubImage3D(g,t,r,i,n,a,o,c,h.internalFormat,l);else{const e=l;R.texSubImage3D(g,t,r,i,n,a,o,c,_,m,e)}u.bindTexture(f,e.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const t=this._descriptor;if(0===t.width||0===t.height)return;if(!t.hasMipmap){if(this._wasImmutablyAllocated)throw new s.A("Cannot add mipmaps to immutable texture after allocation");t.hasMipmap=!0,this._samplingModeDirty=!0,_(t)}t.samplingMode===l.Cj.LINEAR?(this._samplingModeDirty=!0,t.samplingMode=l.Cj.LINEAR_MIPMAP_NEAREST):t.samplingMode===l.Cj.NEAREST&&(this._samplingModeDirty=!0,t.samplingMode=l.Cj.NEAREST_MIPMAP_NEAREST);const r=this._descriptor.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(t.target),this._descriptor.context.bindTexture(r,e.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new s.A("Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,_(e)}e.samplingMode===l.Cj.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=l.Cj.LINEAR):e.samplingMode===l.Cj.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=l.Cj.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,_(this._descriptor),this._wrapModeDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1)}abortCompression(){this.isCompressing&&(this._compressionAbortController.value=(0,n.DC)(this._compressionAbortController.value))}_setData(t,r){const i=this._descriptor,n=i.context?.gl;if(!n)return;(0,c.Y2)(n),this._glName||(this._glName=n.createTexture(),this._glName&&i.context.instanceCounter.increment(l.vt.Texture,this)),_(i);const a=i.context.bindTexture(this,e.TEXTURE_UNIT_FOR_UPDATES);i.context.setActiveTexture(e.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),(0,c.Y2)(n);const o=r??i.target,h=p(o);if(m(t))this._setDataFromTexImageSource(t,o);else{const{width:e,height:r,depth:a}=i;if(null==e||null==r)throw new s.A("Width and height must be specified!");if(h&&null==a)throw new s.A("Depth must be specified!");if(i.internalFormat=E(i),i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(o,i.internalFormat,i.hasMipmap,e,r,a),d(t)){if(!(i.internalFormat in l.CQ))throw new s.A("Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(t,i.internalFormat,o)}else this._texImage(o,0,i.internalFormat,e,r,a,t),(0,c.Y2)(n),i.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),(0,c.Y2)(n),i.context.bindTexture(a,e.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(e=null){for(let t=l.Ap.TEXTURE_CUBE_MAP_POSITIVE_X;t<=l.Ap.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:r,preMultiplyAlpha:s}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,r?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s?1:0)}_setDataFromTexImageSource(e,t){const{gl:r}=this._descriptor.context,s=this._descriptor;s.internalFormat=E(s);const i=p(t),{width:n,height:a,depth:o}=function(e){let t="width"in e?e.width:e.codedWidth,r="height"in e?e.height:e.codedHeight;return e instanceof HTMLVideoElement&&(t=e.videoWidth,r=e.videoHeight),{width:t,height:r,depth:1}}(e);s.width&&s.height,s.width||(s.width=n),s.height||(s.height=a),i&&s.depth,i&&(s.depth=o),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(t,s.internalFormat,s.hasMipmap,n,a,o),this._texImage(t,0,s.internalFormat,n,a,o,e),(0,c.Y2)(r),s.hasMipmap&&(this.generateMipmap(),(0,c.Y2)(r))}_setDataFromCompressedSource(e,t,r){const s=this._descriptor,{width:i,height:n,depth:a}=s,o=e.levels,c=A(r,i,n,a),l=Math.min(c,o.length)-1;this._descriptor.context.gl.texParameteri(s.target,s.context.gl.TEXTURE_MAX_LEVEL,l),this._forEachMipmapLevel(((e,s,i,n)=>{const a=o[Math.min(e,o.length-1)];this._compressedTexImage(r,e,t,s,i,n,a)}),l)}_texStorage(e,t,r,i,n,a){const{gl:o}=this._descriptor.context;if(!(t in l.H0))throw new s.A("Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const c=r?A(e,i,n,a):1;if(p(e)){if(null==a)throw new s.A("Missing depth dimension for 3D texture upload");o.texStorage3D(e,c,t,i,n,a)}else o.texStorage2D(e,c,t,i,n);this._wasImmutablyAllocated=!0}_texImage(e,t,r,i,n,a,o){const c=this._descriptor.context.gl,l=p(e),{isImmutable:h,pixelFormat:u,dataType:_}=this._descriptor;if(h){if(null!=o){const r=o;if(l){if(null==a)throw new s.A("Missing depth dimension for 3D texture upload");c.texSubImage3D(e,t,0,0,0,i,n,a,u,_,r)}else c.texSubImage2D(e,t,0,0,i,n,u,_,r)}}else{const h=o;if(l){if(null==a)throw new s.A("Missing depth dimension for 3D texture upload");c.texImage3D(e,t,r,i,n,a,0,u,_,h)}else c.texImage2D(e,t,r,i,n,0,u,_,h)}}_compressedTexImage(e,t,r,i,n,a,o){const c=this._descriptor.context.gl,l=p(e);if(this._descriptor.isImmutable){if(null!=o)if(l){if(null==a)throw new s.A("Missing depth dimension for 3D texture upload");c.compressedTexSubImage3D(e,t,0,0,0,i,n,a,r,o)}else c.compressedTexSubImage2D(e,t,0,0,i,n,r,o)}else if(l){if(null==a)throw new s.A("Missing depth dimension for 3D texture upload");c.compressedTexImage3D(e,t,r,i,n,a,0,o)}else c.compressedTexImage2D(e,t,r,i,n,0,o)}async compressOnWorker(e){const t=this._descriptor.context?.gl.getExtension("WEBGL_compressed_texture_etc"),r=this._descriptor.context?.gl.getExtension("WEBGL_compressed_texture_s3tc"),s=null;if(s&&(t||r)){const i=new AbortController;this._compressionAbortController.value=i;const n={data:await createImageBitmap(e),flipped:this.descriptor.flipped,width:e.width,height:e.height,hasMipmap:this._descriptor.hasMipmap,hasETC:!!t,hasS3TC:!!r};s.invoke(n,this._compressionAbortController.value.signal).then((e=>{e&&this.isCompressing&&this.glName&&(this._descriptor.internalFormat=e.internalFormat,this._setData(e.compressedTexture)),i===this._compressionAbortController.value&&(this._compressionAbortController.value=null)})).catch((e=>{(0,a.zf)(e)||i!==this._compressionAbortController.value||(this._compressionAbortController.value=null)}))}}_forEachMipmapLevel(e,t=1/0){let{width:r,height:i,depth:n,hasMipmap:a,target:o}=this._descriptor;const c=o===l.Ap.TEXTURE_3D;if(null==r||null==i||c&&null==n)throw new s.A("Missing texture dimensions for mipmap calculation");for(let s=0;e(s,r,i,n),a&&(1!==r||1!==i||c&&1!==n)&&!(s>=t);++s)r=Math.max(1,r>>1),i=Math.max(1,i>>1),c&&(n=Math.max(1,n>>1))}_applySamplingMode(){const e=this._descriptor,t=e.context?.gl;let r=e.samplingMode,s=e.samplingMode;r===l.Cj.LINEAR_MIPMAP_NEAREST||r===l.Cj.LINEAR_MIPMAP_LINEAR?(r=l.Cj.LINEAR,e.hasMipmap||(s=l.Cj.LINEAR)):r!==l.Cj.NEAREST_MIPMAP_NEAREST&&r!==l.Cj.NEAREST_MIPMAP_LINEAR||(r=l.Cj.NEAREST,e.hasMipmap||(s=l.Cj.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,r),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,s)}_applyWrapMode(){const e=this._descriptor,t=e.context?.gl;"number"==typeof e.wrapMode?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}_applyAnisotropicFilteringParameters(){const e=this._descriptor,t=e.context.capabilities.textureFilterAnisotropic;t&&e.context.gl.texParameterf(e.target,t.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}};f.TEXTURE_UNIT_FOR_UPDATES=0},67171:(e,t,r)=>{r.d(t,{R:()=>n,e:()=>a});var s=r(63907),i=r(42293);class n{constructor(e=0,t=e){this.width=e,this.height=t,this.target=s.Ap.TEXTURE_2D,this.pixelFormat=s.Ab.RGBA,this.dataType=s.ld.UNSIGNED_BYTE,this.samplingMode=s.Cj.LINEAR,this.wrapMode=s.pF.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.shouldCompress=!1,this.depth=1,this.isImmutable=!1}}function a(e){return e.width<=0||e.height<=0?0:Math.round(e.width*e.height*e.depth*(e.hasMipmap?4/3:1)*(null==e.internalFormat?4:(0,i.IB)(e.internalFormat))*(e.target===s.Ap.TEXTURE_CUBE_MAP?6:1))}},42293:(e,t,r)=>{r.d(t,{Hi:()=>c,IB:()=>l,yu:()=>o}),r(44208);var s=r(94656),i=r(63907),n=r(62298);function a(e){const t=e.gl;switch(t.getError()){case t.NO_ERROR:return null;case t.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case t.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case t.INVALID_OPERATION:return"The specified command is not allowed for the current state";case t.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case t.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case t.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function o(e,t,r,i,o=0){const c=e.gl;e.bindBuffer(r);for(const r of i){const i=t.get(r.name);if(null==i){console.warn(`There is no location for vertex attribute '${r.name}' defined.`);continue}const l=o*r.stride;if(r.count<=4)c.vertexAttribPointer(i,r.count,r.type,r.normalized,r.stride,r.offset+l),c.enableVertexAttribArray(i),r.divisor>0&&e.gl.vertexAttribDivisor(i,r.divisor);else if(9===r.count)for(let t=0;t<3;t++)c.vertexAttribPointer(i+t,3,r.type,r.normalized,r.stride,r.offset+12*t+l),c.enableVertexAttribArray(i+t),r.divisor>0&&e.gl.vertexAttribDivisor(i+t,r.divisor);else if(16===r.count)for(let t=0;t<4;t++)c.vertexAttribPointer(i+t,4,r.type,r.normalized,r.stride,r.offset+16*t+l),c.enableVertexAttribArray(i+t),r.divisor>0&&e.gl?.vertexAttribDivisor(i+t,r.divisor);else console.error("Unsupported vertex attribute element count: "+r.count);if((0,s.en)()){const t=a(e),s=(0,n._)(r.type),i=r.offset,o=Math.round(s/i)!==s/i?`. Offset not a multiple of stride. DataType requires ${s} bytes, but descriptor has an offset of ${i}`:"";t&&console.error(`Unable to bind vertex attribute "${r.name}" with baseInstanceOffset ${l}${o}:`,t,r)}}}function c(e,t,r,s){const n=e.gl;e.bindBuffer(r);for(const r of s){const s=t.get(r.name);if(r.count<=4)n.disableVertexAttribArray(s),r.divisor&&r.divisor>0&&e.gl?.vertexAttribDivisor(s,0);else if(9===r.count)for(let t=0;t<3;t++)n.disableVertexAttribArray(s+t),r.divisor&&r.divisor>0&&e.gl?.vertexAttribDivisor(s+t,0);else if(16===r.count)for(let t=0;t<4;t++)n.disableVertexAttribArray(s+t),r.divisor&&r.divisor>0&&e.gl?.vertexAttribDivisor(s+t,0);else console.error("Unsupported vertex attribute element count: "+r.count)}e.unbindBuffer(i.NZ.ARRAY_BUFFER)}function l(e){switch(e){case i.Ab.ALPHA:case i.Ab.LUMINANCE:case i.Ab.RED:case i.Ab.RED_INTEGER:case i.H0.R8:case i.H0.R8I:case i.H0.R8UI:case i.H0.R8_SNORM:case i.yQ.STENCIL_INDEX8:return 1;case i.Ab.LUMINANCE_ALPHA:case i.Ab.RG:case i.Ab.RG_INTEGER:case i.H0.RGBA4:case i.H0.R16F:case i.H0.R16I:case i.H0.R16UI:case i.H0.RG8:case i.H0.RG8I:case i.H0.RG8UI:case i.H0.RG8_SNORM:case i.H0.RGB565:case i.H0.RGB5_A1:case i.yQ.DEPTH_COMPONENT16:return 2;case i.Ab.DEPTH_COMPONENT:case i.Ab.RGB:case i.Ab.RGB_INTEGER:case i.H0.RGB8:case i.H0.RGB8I:case i.H0.RGB8UI:case i.H0.RGB8_SNORM:case i.H0.SRGB8:case i.yQ.DEPTH_COMPONENT24:return 3;case i.Ab.DEPTH_STENCIL:case i.Ab.DEPTH24_STENCIL8:case i.Ab.RGBA:case i.Ab.RGBA_INTEGER:case i.H0.RGBA8:case i.H0.R32F:case i.H0.R11F_G11F_B10F:case i.H0.RG16F:case i.H0.R32I:case i.H0.R32UI:case i.H0.RG16I:case i.H0.RG16UI:case i.H0.RGBA8I:case i.H0.RGBA8UI:case i.H0.RGBA8_SNORM:case i.H0.SRGB8_ALPHA8:case i.H0.RGB9_E5:case i.H0.RGB10_A2UI:case i.H0.RGB10_A2:case i.yQ.DEPTH_STENCIL:case i.yQ.DEPTH_COMPONENT32F:case i.yQ.DEPTH24_STENCIL8:return 4;case i.yQ.DEPTH32F_STENCIL8:return 5;case i.H0.RGB16F:case i.H0.RGB16I:case i.H0.RGB16UI:return 6;case i.H0.RG32F:case i.H0.RG32I:case i.H0.RG32UI:case i.H0.RGBA16F:case i.H0.RGBA16I:case i.H0.RGBA16UI:return 8;case i.H0.RGB32F:case i.H0.RGB32I:case i.H0.RGB32UI:return 12;case i.H0.RGBA32F:case i.H0.RGBA32I:case i.H0.RGBA32UI:return 16;case i.CQ.COMPRESSED_RGB_S3TC_DXT1_EXT:case i.CQ.COMPRESSED_RGBA_S3TC_DXT1_EXT:return.5;case i.CQ.COMPRESSED_RGBA_S3TC_DXT3_EXT:case i.CQ.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case i.CQ.COMPRESSED_R11_EAC:case i.CQ.COMPRESSED_SIGNED_R11_EAC:case i.CQ.COMPRESSED_RGB8_ETC2:case i.CQ.COMPRESSED_SRGB8_ETC2:case i.CQ.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.CQ.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return.5;case i.CQ.COMPRESSED_RG11_EAC:case i.CQ.COMPRESSED_SIGNED_RG11_EAC:case i.CQ.COMPRESSED_RGBA8_ETC2_EAC:case i.CQ.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}},94656:(e,t,r)=>{r.d(t,{Xc:()=>l,Y2:()=>h,en:()=>c});var s=r(49186),i=r(44208),n=r(53966);const a=()=>n.A.getLogger("esri.views.webgl.checkWebGLError"),o=!!(0,i.A)("enable-feature:webgl-debug");function c(){return o}function l(){return o}function h(e){if(c()){const t=e.getError();if(t){const r=function(e,t){switch(t){case e.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case e.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case e.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case e.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case e.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case e.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}(e,t),i=(new Error).stack;a().error(new s.A("webgl-error","WebGL error occurred",{message:r,stack:i}))}}}},62298:(e,t,r)=>{r.d(t,{_:()=>i});var s=r(63907);function i(e){switch(e){case s.pe.BYTE:case s.pe.UNSIGNED_BYTE:return 1;case s.pe.SHORT:case s.pe.UNSIGNED_SHORT:case s.pe.HALF_FLOAT:return 2;case s.pe.FLOAT:case s.pe.INT:case s.pe.UNSIGNED_INT:return 4}}}}]);