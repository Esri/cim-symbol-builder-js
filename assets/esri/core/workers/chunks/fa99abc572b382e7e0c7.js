"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[1253,6061],{1364:(e,t,s)=>{s.d(t,{c:()=>i});var n=s(55537);function i(e,t){const s=e.getGeometryType();return s===n.G.enumPoint?e:(0,n.h)(s)?function(e){if(function(e){for(let t=0,s=e.getPathCount();t<s;t++){const s=e.getPathSize(t);if(0===s)return!1;if(1===s){if(0===e.getSegmentCountPath(t))return!1;if(e.getSegmentType(e.getPathStart(t))===n.G.enumLine)return!1;if(!e.isClosedPath(t))return!1}}return!0}(e))return e;const t=e.createInstance();for(let s=0,i=e.getPathCount();s<i;s++){const i=e.getPathSize(s);if(0!==i){if(1===i){if(0===e.getSegmentCountPath(s))continue;if(e.getSegmentType(e.getPathStart(s))===n.G.enumLine)continue;if(!e.isClosedPath(s))continue}t.addPath(e,s,!0)}}return t}(e):s===n.G.enumMultiPoint||s===n.G.enumEnvelope?e:s===n.G.enumMultipatch?((0,n.t)("not implemented for multipatch"),e):e}},41253:(e,t,s)=>{s.d(t,{g7:()=>E,yv:()=>M,fz:()=>G});var n,i,r=s(76061),m=s(55537),o=s(12189),h=s(79187),a=s(90237),l=s(95213),c=s(83661),u=s(88885),_=s(11878),f=s(1364),g=s(98783),d=s(64523);function p(e,t,s,n,i,r){return{m_from:e.clone(),m_to:t.clone(),m_center:s.clone(),m_next:i,m_type:n}}function P(e,t,s,n,i){return{m_from:e.clone(),m_to:t.clone(),m_next:s,m_type:4,m_center:new c.P}}(i=n||(n={}))[i.enumDummy=256]="enumDummy",i[i.enumLine=1]="enumLine",i[i.enumArc=2]="enumArc",i[i.enumMiter=8]="enumMiter",i[i.enumBevel=16]="enumBevel",i[i.enumJoinMask=26]="enumJoinMask",i[i.enumConnectionMask=27]="enumConnectionMask";class y extends r.G{constructor(e,t,s,n,i,r,m,o,h,a){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=a,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=n,this.m_densifyDist=o,this.m_maxVertexInCompleteCircle=h,this.m_joins=i,this.m_caps=r,this.m_miterLimit=m}next(){const e=new l.P;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(1===this.m_caps)return this.m_index=this.m_mp.getPointCount(),new u.a({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(null===this.m_bufferedPolygon&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const s=new _.T,n=e.getX()-this.m_x,i=e.getY()-this.m_y;s.setShiftCoords(n,i),t.applyTransformation(s)}return(0,l.s)(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class b extends r.G{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;const e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){const t=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(t)){let s=e.getXY(e.getPathEnd(t)-1);for(;this.m_currentPathIndex<e.getPathCount();){const t=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex))break;if(!t.equals(s))break;s=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(0===t&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const e=this.m_polyline;return this.m_polyline=null,e}const s=new u.P({vd:this.m_polyline.getDescription()});s.addPath(this.m_polyline,t,!0);for(let n=t+1;n<this.m_currentPathIndex;n++)s.addSegmentsFromPath(this.m_polyline,n,0,e.getSegmentCountPath(n),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),s}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class x extends r.G{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(null===this.m_geometry&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){const e=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,e,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class C extends r.G{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){const e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){const t=this.m_index,s=e.calculateRingArea2D(this.m_index);for((0,m.g)(s>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let n;return n=0===t&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),n}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class D{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=m.G.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new l.C(0,0),this.m_smallTolerance=new l.C(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new u.L,this.m_helperLine2=new u.L,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=u.D.constructDefault(e),this.m_progressTracker=e}buffer(e,t,s,n,i,r,o,a){if(e||(0,m.a)("Geometry.Bufferer.Impl.Buffer"),o<0&&(0,m.a)("Geometry.Bufferer.Impl.Buffer"),(0,m.j)(e.getGeometryType())&&(0,m.t)("Unsupported geometry type."),e.isEmpty())return new u.a({vd:e.getDescription()});if(this.m_joins=n,this.m_caps=i,this.m_bRoundBuffer=!1,this.m_miterLimit=r,this.m_originalGeomType=e.getGeometryType(),(0,m.k)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_joins:(0,m.e)(this.m_originalGeomType)?this.m_bRoundBuffer=0===this.m_caps:(0,m.l)(this.m_originalGeomType)&&(this.m_bRoundBuffer=0===this.m_joins&&0===this.m_caps),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=(0,f.c)(e),this.m_geometry.isEmpty())return new u.a({vd:e.getDescription()});const _=new h.Envelope2D;this.m_geometry.queryLooseEnvelope(_),t>0&&_.inflateCoords(t,t),this.m_tolerance=(0,l.c)(s,_,!0),this.m_smallTolerance=(0,l.c)(null,_,!0),a<=0&&(a=96),this.m_spatialReference=s,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=0!==this.m_absDistance?1/this.m_absDistance:0,Number.isNaN(o)||0===o?o=1e-5*this.m_absDistance:o>.5*this.m_absDistance&&(o=.5*this.m_absDistance),a<12&&(a=12);const g=Math.abs(t)*(1-Math.cos(Math.PI/a));if(g>o)o=g;else if(0!==t){const e=Math.PI/Math.acos(1-o/Math.abs(t));e<a-1&&(a=Math.trunc(e))<12&&(a=12,o=Math.abs(t)*(1-Math.cos(Math.PI/a)))}this.m_densifyDist=o,this.m_maxVertexInCompleteCircle=a,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&(0,m.m)(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,0!==this.m_joins,(0,c.i)()));const d=this.bufferImpl();return this.m_geometry=null,d}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),s=.5*Math.PI/t;this.m_dA=s,this.m_circleTemplate=(0,c.m)(c.P,4*t);const n=Math.cos(s),i=Math.sin(s),r=c.P.construct(0,1);for(let e=0;e<t;e++)this.m_circleTemplate[e+0*t].setCoords(r.y,-r.x),this.m_circleTemplate[e+1*t].setCoords(-r.x,-r.y),this.m_circleTemplate[e+2*t].setCoords(-r.y,r.x),this.m_circleTemplate[e+3*t].setCoords(r.x,r.y),r.rotateReverse(n,i)}bufferImpl(){const e=this.m_geometry.getGeometryType();if((0,m.f)(e)){const e=new u.P({vd:this.m_geometry.getDescription()});return e.addSegment(this.m_geometry,!0),this.m_geometry=e,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!(0,m.k)(e))return new u.a({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const e=new h.Envelope2D;if(this.m_geometry.queryEnvelope(e),e.width()<=2*this.m_absDistance||e.height()<=2*this.m_absDistance)return new u.a({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case m.G.enumPoint:return this.bufferPoint();case m.G.enumMultiPoint:return this.bufferMultiPoint();case m.G.enumPolyline:return this.bufferPolyline();case m.G.enumPolygon:return this.bufferPolygon();case m.G.enumEnvelope:return this.bufferEnvelope();default:(0,m.d)("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const e=new l.P;this.m_geometry.getPointByVal(0,e);const t=new h.Envelope2D;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}const e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;const s=new b(e);let n,i;n=0===this.m_joins?(new d.O).executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,i=this.m_bRoundBuffer?(new g.O).executeMany(n,null,!0,this.m_progressTracker):n;const r=new x(this,i,this.m_bFilter),m=(new o.j).executeMany(r,this.m_spatialReference,this.m_progressTracker,2),a=(new o.O).executeMany(m,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==a?a:new u.a({vd:t})}bufferPolygon(){if(0===this.m_distance)return this.m_geometry;this.generateCircleTemplate();const e=(new o.O).execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;const t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return(new o.O).execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){const e=new l.P;this.m_geometry.getPointByVal(0,e);const t=new h.Envelope2D;return this.m_geometry.queryEnvelope(t),e.setXY(t.getCenter()),this.bufferDegeneratePath(e,!0)}const t=new C(this),s=(new o.j).executeMany(t,this.m_spatialReference,this.m_progressTracker,2),n=(new o.O).executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return null!==n?n:new u.a({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){const n=e,i=n.getImpl();let r=new u.a({vd:e.getDescription()});for(let m=t;m<s;m++){if(i.getPathSize(m)<1)continue;const t=i.calculateRingArea2D(m),s=new h.Envelope2D;if(i.queryPathEnvelope(m,s),this.m_distance>0)if(t>0)if(this.isDegeneratePath(i,m)){const e=new l.P;i.getPointByVal(i.getPathStart(m),e),e.setXY(s.getCenter()),r.add(this.bufferDegeneratePath(e,!0),!1)}else{const t=new u.P({vd:e.getDescription()}),s=t.getImpl();if((0,u.i)(this.m_geometry,m)){const e=this.bufferConvexPath(n,m);r.add(e,!1)}else{this.bufferClosedPath(this.m_geometry,m,s,this.m_bRoundBuffer,1);const e=this.bufferCleanup(t);r.add(e,!1)}}else{if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const t=new u.P({vd:e.getDescription()}),n=t.getImpl();if(this.bufferClosedPath(this.m_geometry,m,n,this.m_bRoundBuffer,1),!t.isEmpty()){const e=s,i=Math.max(1,this.m_absDistance),m=e.clone();m.inflateCoords(i,i),n.addEnvelope(m,!1);const o=this.bufferCleanup(t);r.reserve(r.getPointCount()+o.getPointCount()-4),k(o,r,m,!0)}}else if(t>0){if(s.width()+this.m_tolerance.total()<=2*this.m_absDistance||s.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const t=new u.P({vd:e.getDescription()}),n=t.getImpl();if(this.bufferClosedPath(this.m_geometry,m,n,this.m_bRoundBuffer,-1),!t.isEmpty()){const e=new h.Envelope2D;n.queryLooseEnvelope(e);const s=Math.max(1,this.m_absDistance),i=e.clone();i.inflateCoords(s,s),n.addEnvelope(i,!1),k(this.bufferCleanup(t),r,i,!0)}}else{const t=new u.P({vd:e.getDescription()}),s=t.getImpl();this.bufferClosedPath(this.m_geometry,m,s,this.m_bRoundBuffer,-1);const n=this.bufferCleanup(t);for(let e=0,t=n.getPathCount();e<t;e++)r.addPath(n,e,!0)}}if(this.m_distance>0)return r.getPathCount()>1?this.bufferCleanup(r):w(r);{const e=new h.Envelope2D;if(r.queryLooseEnvelope(e),r.isEmpty())return w(r);{const t=Math.max(1,this.m_absDistance),s=e.clone();s.inflateCoords(t,t),r.addEnvelope(s,!1);const n=this.bufferCleanup(r);r=new u.a;const i=new u.a({vd:n.getDescription()});return k(n,i,s,!1),w(i)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){const t=new u.a({vd:e.getDescription()});return 0===this.m_caps?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):2===this.m_caps?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){const s=new u.a({vd:e.getDescription()});return t&&0===this.m_joins||!t&&0===this.m_caps?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||2!==this.m_caps?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){const e=new y(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return(new o.j).executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new u.a({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(0===this.m_distance)e.addEnvelope(this.m_geometry,!1),v(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{const t=new l.E;this.m_geometry.queryEnvelope(t),t.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(t,!1),v(t,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(1===this.m_joins){const t=new l.E({copy:this.m_geometry});return t.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(t,!1),e}const t=this.m_geometry.clone();if(0===t.width()||0===t.height()){if(0===t.width()&&0===t.height()){const e=new l.P({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,e),this.m_geometry=e,this.bufferImpl()}const e=new u.P({vd:this.m_geometry.getDescription()}),s=new l.P;return t.queryCornerByVal(0,s),e.startPathPoint(s),t.queryCornerByVal(2,s),e.lineToPoint(s),this.m_geometry=e,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();const s=e.hasAttribute(10),i=new u.a({vd:e.getDescription()}),r=i.getImpl();i.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));const o=new c.P,h=new c.P,a=new c.P,l=new c.P(0,0),_=new c.P,f=new c.P,g=e.getImpl(),d=e.getPathSize(t),p=e.getPathStart(t);for(let i=0,c=e.getPathSize(t);i<c;i++){const e=g.getXY(p+i),t=g.getXY(p+(i+1)%d),c=g.getXY(p+(i+2)%d);_.setSub(t,e),0===_.length()&&(0,m.d)("");const u=s&&!!(1&g.getAttributeAsInt(10,(i+1)%d,0));_.normalize();const P=_.clone();_.leftPerpendicularThis(),_.scale(this.m_absDistance),o.setAdd(_,e),h.setAdd(_,t),0===i?r.startPath(o):r.lineTo(o),r.lineTo(h),f.setSub(c,t),0===f.length()&&(0,m.d)(""),f.normalize();const y=f.clone();f.leftPerpendicularThis(),f.scale(this.m_absDistance),a.setAdd(f,t);let b=n.enumArc;const x=u?0:this.m_joins;if(2===x)b=n.enumBevel;else if(1===x){const e=-P.crossProduct(y);l.setSub(P,y),l.scale(this.m_absDistance/e),l.length()<this.m_miterLimit*this.m_absDistance?(l.addThis(t),b=n.enumMiter):b=n.enumBevel}else l.assign(t);this.addJoin(b,r,l,h,a,!1,!1)}return w(i)}bufferPolylinePath(e,t,s){this.generateCircleTemplate();const n=e,i=n.getImpl();if(i.getPathSize(t)<1)return null;let r;if(r=this.m_bRoundBuffer?i.isClosedPathInXYPlane(t):i.isClosedPath(t),this.isDegeneratePath(i,t)&&this.m_distance>0){const e=new l.P;i.getPointByVal(i.getPathStart(t),e);const s=new h.Envelope2D;return i.queryPathEnvelope(t,s),e.setXY(s.getCenter()),this.bufferDegeneratePath(e,r)}const m=new u.P({vd:e.getDescription()});m.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*i.getPathSize(t));const o=m.getImpl();return r?2!==this.bufferClosedPath(n,t,o,s,1)&&this.bufferClosedPath(n,t,o,s,-1):this.bufferOpenPath(n,t,o,s),this.bufferCleanup(m)}progress_(){}bufferCleanup(e,t=!1){const s=t?this.m_tolerance:this.m_smallTolerance;return(0,o.p)(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(0===this.m_densifyDist)return this.m_maxVertexInCompleteCircle;const e=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let t=4;return t=e<-1?4:2*Math.PI/Math.acos(e)+.5,t<4?t=4:t>this.m_maxVertexInCompleteCircle&&(t=this.m_maxVertexInCompleteCircle),Math.trunc(t)}addJoin(e,t,s,i,r,m,o){if(this.generateCircleTemplate(),m&&(t.startPath(i),m=!1),e===n.enumBevel)return void(o&&t.lineTo(r));if(e===n.enumMiter){const e=s.clone();return t.lineTo(e),void(o&&t.lineTo(r))}const h=new c.P;h.setSub(i,s),h.scale(this.m_absDistanceReversed);const a=new c.P;a.setSub(r,s),a.scale(this.m_absDistanceReversed);let l=Math.atan2(h.y,h.x)/this.m_dA;l<0&&(l=this.m_circleTemplate.length+l),l=this.m_circleTemplate.length-l;let u=Math.atan2(a.y,a.x)/this.m_dA;u<0&&(u=this.m_circleTemplate.length+u),u=this.m_circleTemplate.length-u,u<l&&(u+=this.m_circleTemplate.length);let _=Math.trunc(u),f=Math.ceil(l),g=this.m_circleTemplate[f%this.m_circleTemplate.length].clone();g.scaleAddThis(this.m_absDistance,s);const d=10*this.m_tolerance.total();g.sub(i).length()<d&&(f+=1),g=this.m_circleTemplate[_%this.m_circleTemplate.length].clone(),g.scaleAddThis(this.m_absDistance,s),g.sub(r).length()<d&&(_-=1);let p=_-f;p++;for(let e=0,n=f%this.m_circleTemplate.length;e<p;e++,n=(n+1)%this.m_circleTemplate.length)g=this.m_circleTemplate[n].clone(),g.scaleAddThis(this.m_absDistance,s),t.lineTo(g),this.progress_();o&&t.lineTo(r)}bufferClosedPath(e,t,s,n,i){const r=new u.E,m=r.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(r,m,s,n,i)}bufferClosedPathImpl(e,t,s,i,r){const o=e.getFirstVertex(e.getFirstPath(t)),h=new l.P;if(e.queryPoint(o,h),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(t)<2)return r<0?0:(this.m_bRoundBuffer&&this.addCircle(s,h),2);(0,m.g)(e.getFirstPath(t)!==u.n),(0,m.g)(e.getFirstVertex(e.getFirstPath(t))!==u.n);const f=e.getXY(e.getFirstVertex(e.getFirstPath(t))),g=new _.T;if(g.setShift(f.negate()),e.applyTransformation(g),i){const n=function(e,t,s,n,i,r,m){return function(e,t,s,n,i,r,m){const o={stack:[],error:void 0,hasError:!1};try{const n=e.getFirstPath(t),h=e.createUserIndex();(0,a.b)(o,(0,c.h)((()=>{e.removeUserIndex(h)}),!1),!1),function(e,t,s,n){let i=-1;const r=new c.P,m=new c.P,o=new c.P;for(let s=0,h=e.getPathSize(n),a=e.getFirstVertex(n);s<h;++s){-1===i&&(e.queryXY(a,m),i=e.getPrevVertex(a),-1!==i&&(e.queryXY(i,r),o.setSub(m,r),o.normalize()));const s=e.getNextVertex(a);if(-1===s)break;const n=e.getXY(s),h=n.sub(m);h.normalize(),-1!==i&&h.dotProduct(o)<-.99&&Math.abs(h.crossProduct(o))<1e-7&&e.setUserIndex(a,t,1),i=a,a=s,r.assign(m),m.assign(n),o.assign(h)}}(e,h,0,n);for(let t=0;t<100;++t){if(0===e.getPathSize(n))return 1;let t=e.getFirstVertex(n),r=e.getPathSize(n);if(r<3)return 1;e.isClosedPath(n)||(r-=1);const o=64;let a=0,l=!1;for(let n=0;n<r&&t!==u.n;n++){let c=0,u=t;for(let a=1,l=Math.min(o,r-n);a<l;a++)if(u=e.getNextVertexEx(u,s),a>1){const n=T(e,h,t,u,s,i,m,o);if(-1===n)break;c+=n,r-=n}if(a+=c,l=c>0,l){const n=e.getPrevVertexEx(t,s);if(-1!==n){t=n,r++;continue}}t=e.getNextVertexEx(t,s)}if(0===a)break}return e.filterClosePoints(r,!1,!1,!1,-1),1}catch(e){o.error=e,o.hasError=!0}finally{(0,a.c)(o)}}(e,t,s,0,i,r,m)}(e,t,r,0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if((0,m.g)(1===n),e.getPointCount(t)<2)return r<0?0:(this.addCircle(s,h),2)}const d=0!==this.m_joins&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const y=e.getFirstPath(t);let b=e.getFirstVertex(y),x=1===r?e.getPrevVertex(b):e.getNextVertex(b),C=1===r?e.getNextVertex(b):e.getPrevVertex(b),D=!0;const w=new c.P,v=new c.P,k=new c.P,S=new c.P,I=new c.P,E=new c.P,M=new c.P,G=new c.P,R=this.m_absDistance,V=e.getPathSize(y),A=new c.P(0,0);for(let t=0;t<V;t++){v.assign(e.getXY(C)),D&&(w.assign(e.getXY(b)),k.assign(e.getXY(x)),E.setSub(w,k),E.normalize(),G.leftPerpendicularOther(E),G.scale(R),S.setAdd(G,w));const t=d&&!!(1&e.getAttributeAsDbl(10,b,0));I.setSub(v,w),I.normalize(),M.leftPerpendicularOther(I),M.scale(R);const s=new c.P;s.setAdd(w,M);const i=E.crossProduct(I),m=E.dotProduct(I);if(i<0||m<0&&i<Math.abs(m)*Number.EPSILON*8){let e=!1;const r=t?0:this.m_joins;if(1===r){const t=-i;A.setSub(E,I),A.scale(this.m_absDistance/t),A.length()<this.m_miterLimit*this.m_absDistance&&(A.addThis(w),e=!0),this.m_bufferCommands.push(p(S,s,A,e?n.enumMiter:n.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(p(S,s,w,0===r?n.enumArc:n.enumBevel,this.m_bufferCommands.length+1))}else S.equals(s)||(this.m_bufferCommands.push(P(S,w,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(P(w,s,this.m_bufferCommands.length+1)));const o=new c.P;o.setAdd(v,M),this.m_bufferCommands.push(p(s,o,w,n.enumLine,this.m_bufferCommands.length+1)),S.setCoordsPoint2D(o),G.setCoordsPoint2D(M),k.setCoordsPoint2D(w),w.setCoordsPoint2D(v),E.setCoordsPoint2D(I),x=b,b=C,D=!1,C=1===r?e.getNextVertex(b):e.getPrevVertex(b)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),g.setShift(f),s.applyTransformationToPath(g,s.getPathCount()-1),1}bufferOpenPath(e,t,s,i){if(this.m_bRoundBuffer){const n=new u.P({vd:e.getDescription()});return n.addPath(e,t,!1),n.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(n,0,s,i,1)}let r=0;const o=new u.P({vd:e.getDescription()}),h=new c.P(0,0);{const n=new u.E,i=n.addPathFromMultiPath(e,t,!1),m=n.getFirstVertex(n.getFirstPath(i)),a=new l.P;if(n.queryPoint(m,a),h.assign(a.getXY()),n.filterClosePoints(0,!1,!1,!1,-1),n.getPointCount(i)<2)return this.m_bRoundBuffer&&this.addCircle(s,a),2;const c=n.getGeometry(n.getFirstGeometry());o.addPath(c,0,!1),r=o.getPointCount()-1,o.addSegmentsFromPath(c,0,0,c.getSegmentCountPath(0)-1,!1)}const a=new u.E,f=a.addPathFromMultiPath(o,0,!0);(0,m.g)(a.getFirstPath(f)!==u.n),(0,m.g)(a.getFirstVertex(a.getFirstPath(f))!==u.n);const g=new _.T;g.setShift(h.negate()),a.applyTransformation(g),this.m_bufferCommands.length=0;const d=a.getFirstPath(f),y=0!==this.m_joins&&a.getVertexDescription().hasAttribute(10);let b=a.getFirstVertex(d),x=a.getPrevVertex(b),C=a.getNextVertex(b),D=!0;const w=new c.P,v=new c.P,T=new c.P,k=new c.P,S=new c.P,I=new c.P,E=new c.P,M=new c.P,G=this.m_absDistance,R=a.getPathSize(d),V=new c.P(0,0);for(let e=0;e<R;e++){let t=!1;0!==e&&e!==r||(t=!0),v.assign(a.getXY(C)),D&&(w.assign(a.getXY(b)),T.assign(a.getXY(x)),I.setSub(w,T),I.normalize(),M.leftPerpendicularOther(I),M.scale(G),k.setAdd(M,w));const s=y&&!!(1&a.getAttributeAsDbl(10,b,0));S.setSub(v,w),S.normalize(),E.leftPerpendicularOther(S),E.scale(G);const i=new c.P;i.setAdd(w,E);const m=I.crossProduct(S),o=I.dotProduct(S);if(m<0||o<0&&m<Math.abs(o)*Number.EPSILON*8)if(t)if(0===this.m_caps)this.m_bufferCommands.push(p(k,i,w,n.enumArc,this.m_bufferCommands.length+1));else if(1===this.m_caps)this.m_bufferCommands.push(p(k,i,w,n.enumLine,this.m_bufferCommands.length+1));else{const e=S.mul(this.m_absDistance).negate(),t=e.clone();e.addThis(k),t.addThis(i),this.m_bufferCommands.push(p(k,e,w,n.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(p(e,t,w,n.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(p(t,i,w,n.enumLine,this.m_bufferCommands.length+1))}else{let e=!1;const t=s?0:this.m_joins;if(1===t){const t=-m;V.setSub(I,S),V.scale(this.m_absDistance/t),V.length()<this.m_miterLimit*this.m_absDistance&&(V.addThis(w),e=!0),this.m_bufferCommands.push(p(k,i,V,e?n.enumMiter:n.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(p(k,i,w,0===t?n.enumArc:n.enumBevel,this.m_bufferCommands.length+1))}else k.equals(i)||(this.m_bufferCommands.push(P(k,w,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(P(w,i,this.m_bufferCommands.length+1)));const h=new c.P;h.setAdd(v,E),this.m_bufferCommands.push(p(i,h,w,n.enumLine,this.m_bufferCommands.length+1)),k.setCoordsPoint2D(h),M.setCoordsPoint2D(E),T.setCoordsPoint2D(w),w.setCoordsPoint2D(v),I.setCoordsPoint2D(S),x=b,b=C,D=!1,C=a.getNextVertex(b)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),g.setShift(h),s.applyTransformationToPath(g,s.getPathCount()-1),1}processBufferCommands(e){const t=this.cleanupBufferCommands();let s=!0,i=t+1;for(let r=t;i!==t;r=i){const t=this.m_bufferCommands[r];i=-1!==t.m_next?t.m_next:(r+1)%this.m_bufferCommands.length,t.m_type&&(s&&(e.startPath(t.m_from),s=!1),t.m_type&n.enumJoinMask?this.addJoin(t.m_type,e,t.m_center,t.m_from,t.m_to,!1,!0):e.lineTo(t.m_to))}}cleanupBufferCommands(){this.m_helperArray=(0,c.m)(c.P,9);let e=0;for(let t=0,s=this.m_bufferCommands.length;t<s;){const s=this.m_bufferCommands[t];if(s.m_type&n.enumConnectionMask){e=t;break}t=s.m_next}let t=e+1;for(let s=e;t!==e;s=t){const e=this.m_bufferCommands[s];t=e.m_next;let i=1,r=null;for(;t!==s&&(r=this.m_bufferCommands[t],!(r.m_type&n.enumConnectionMask));)t=r.m_next,i++;1!==i&&(e.m_type&r.m_type)===n.enumLine&&(this.m_helperLine1.setStartXY(e.m_from),this.m_helperLine1.setEndXY(e.m_to),this.m_helperLine2.setStartXY(r.m_from),this.m_helperLine2.setEndXY(r.m_to),1===this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())&&(e.m_to.assign(this.m_helperArray[0]),r.m_from.assign(this.m_helperArray[0]),e.m_next=t))}return e}isDegeneratePath(e,t){if(1===e.getPathSize(t))return!0;if(0===this.m_joins&&0===this.m_caps){const s=new h.Envelope2D;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(0===this.m_joins&&0===this.m_caps){const t=new h.Envelope2D;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){const s=t.getXY();if(0!==this.m_circleTemplate.length){let t=this.m_circleTemplate[0].clone();t.scaleAddThis(this.m_absDistance,s),e.startPath(t);for(let n=1,i=this.m_circleTemplate.length;n<i;n++)t=this.m_circleTemplate[n].clone(),t.scaleAddThis(this.m_absDistance,s),e.lineTo(t);return}const n=this.m_circleTemplateSize,i=Math.trunc((n+3)/4),r=.5*Math.PI/i;e.reserve(4*i);const m=Math.cos(r),o=Math.sin(r);for(let t=3;t>=0;t--){const n=c.P.construct(0,this.m_absDistance);switch(t){case 0:for(let t=0;t<i;t++)e.lineToCoords(n.x+s.x,n.y+s.y),n.rotateReverse(m,o);break;case 1:for(let t=0;t<i;t++)e.lineToCoords(-n.y+s.x,n.x+s.y),n.rotateReverse(m,o);break;case 2:for(let t=0;t<i;t++)e.lineToCoords(-n.x+s.x,-n.y+s.y),n.rotateReverse(m,o);break;default:e.startPathCoords(n.y+s.x,-n.x+s.y);for(let t=1;t<i;t++)n.rotateReverse(m,o),e.lineToCoords(n.y+s.x,-n.x+s.y)}this.progress_()}}addSquare(e,t){const s=new l.E({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}function w(e){return(0,l.s)(e,0),e}function v(e,t){return!!e.isEmpty()||Math.min(e.width(),e.height())>t}function T(e,t,s,n,i,r,o,h){const a=e.getXY(s),l=e.getXY(n);if(a.equals(l))return-1;const u=.25*o,_=.25*o,f=new c.P;f.setSub(l,a);const g=f.length(),d=g*g*.25,p=r*r-d;if(p<=d)return-1;const P=Math.sqrt(p);f.normalize();const y=f.clone();y.rightPerpendicularThis();const b=d/P,x=b<=_,C=c.P.lerp(l,a,.5),D=y.clone(),w=b-u;D.scaleAddThis(Math.max(0,w),C),y.negate().scaleAddThis(P,C);const v=3.61*(0,c.a)(r-_),T=D.sub(a),k=D.sub(l);let S=!1,I=0;const E=(0,c.d)(64,0);(0,m.g)(h===E.length);{for(let r=e.getPrevVertexEx(n,i);r!==s;){if(1===e.getUserIndex(r,t))return-1;if(!e.getXY(r).equals(l))break;{const t=e.getPrevVertexEx(r,i);e.removeVertex(r,!1),r=t}}const r=new c.P,o=a.clone();E[I++]=1;for(let m=e.getNextVertexEx(s,i);m!==n;){if(1===e.getUserIndex(m,t))return-1;const s=e.getXY(m);if(s.equals(o)){const t=e.getNextVertexEx(m,i);e.removeVertex(m,!1),m=t;continue}E[I++]=0;const n=new c.P;if(n.setSub(s,a),n.dotProduct(y)<0)return 0;(c.P.sqrDistance(s,a)>v||c.P.sqrDistance(s,l)>v)&&(S=!0);let h=0;if(s.sub(a).crossProduct(T)>=0&&(h=1),s.sub(l).crossProduct(k)<=0&&(h|=2),0===h)return 0;E[I-1]=h,r.assign(o),o.assign(s),m=e.getNextVertexEx(m,i)}if(1===I)return 0;(0,m.g)(I<E.length),E[I++]=2}let M=!0;for(let e=1,t=0;e<I;e++)if(E[e]!==E[e-1]&&(t++,M=t<3&&(1===t&&3===E[e]||2===t&&2===E[e]),!M))return 0;if(I>2&&M&&(3===I||!S)){let t=0,r=e.getNextVertexEx(s,i);for(x||(e.setXY(r,D),r=e.getNextVertexEx(r,i));r!==n;){const s=e.getNextVertexEx(r,i);e.removeVertex(r,!1),r=s,++t}return t}if((0,m.g)(3!==I),S&&I>3)return 0;const G=a.clone();let R=s;const V=a.clone();let A=1,X=-1,Y=R,B=0;for(I=1;Y!==n;){Y=e.getNextVertexEx(Y,i);const t=E[I++];if(0===t){if(Y===n)break;continue}const s=e.getXY(Y);if(-1!==X){if(X&A&t&3){e.removeVertex(R,!0),B++,R=Y,V.setCoordsPoint2D(s),A=t;continue}if(3===A&&0!==X&&0!==t){if(V.setCoordsPoint2D(D),x||V.equals(G)){e.removeVertex(R,!0),B++,R=Y,V.setCoordsPoint2D(s),A=t;continue}e.setXY(R,V)}}X=A,G.setCoordsPoint2D(V),R=Y,A=t,V.setCoordsPoint2D(s)}return B}function k(e,t,s,n){for(let i=0,r=e.getPathCount();i<r;i++){const r=e.getXY(e.getPathStart(i));r.x!==s.xmin&&r.x!==s.xmax&&t.addPath(e,i,n)}}class S extends r.G{constructor(e,t,s,n,i,r,m){super(),this.m_currentUnionEnvelope2D=new h.Envelope2D,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=m,this.m_bufferer=new D(m),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_distances=s,this.m_maxDeviation=n,this.m_maxVerticesInFullCircle=i}tock(){return!0}getRank(){return 1}next(){{let e;for(;e=this.m_inputGeoms.next();)return(0,m.c)(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.buffer(e,this.m_distances[this.m_dindex]);return null}}getGeometryID(){return this.m_index}buffer(e,t){return this.m_bufferer.buffer(e,t,this.m_spatialReference,0,0,4,this.m_maxDeviation,this.m_maxVerticesInFullCircle)}}const I=new class{getOperatorType(){return 10004}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n,i){return this.executeManyEx(e,t,s,Number.NaN,96,n,i)}execute(e,t,s,n){Number.isFinite(s)||(0,m.a)("Invalid distance for buffer operation");const i=new r.S([e]),o=[s],h=this.executeMany(i,t,o,!1,n).next();return h||(0,m.d)("null buffer output"),h}executeManyEx(e,t,s,n,i,r,h){if(void 0!==s.find((e=>!Number.isFinite(e)))&&(0,m.a)("Invalid distance for buffer operation"),r){const r=new S(e,t,s,n,i,!1,h);return(new o.j).executeMany(r,t,h,2)}return new S(e,t,s,n,i,!1,h)}};function E(e,t,s){return I.execute(e,t,s,null)}function M(e,t,s,n,i,m){const o=I.executeManyEx(new r.S(e),t,s,n,i,m,null);return Array.from(o)}function G(){return I.supportsCurves()}},64523:(e,t,s)=>{s.d(t,{O:()=>l});var n=s(90237),i=s(76061),r=s(55537),m=s(88885),o=s(95213),h=s(83661),a=s(5247);class l{getOperatorType(){return 10204}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n){return new c(e,t,s,n)}execute(e,t,s,n){return e||(0,r.a)("null param is not allowed."),new c(null,t,s,n).generalize(e)}}class c extends i.G{constructor(e,t,s,n){super(),this.m_pline=null,this.m_point=new o.P,this.m_stack=[],this.m_resultstack=[],this.m_callCount=0,this.m_progressTracker=n,this.m_geoms=e,this.m_maxDeviation=t,this.m_bRemoveDegenerateParts=s}tock(){return!0}getRank(){return 1}next(){const e=this.m_geoms.next();return null===e?null:((0,r.c)(e),this.generalize(e))}getGeometryID(){return this.m_geoms.getGeometryID()}generalize(e){const t=e.getGeometryType();if((0,r.e)(t))return e;if(t===r.G.enumEnvelope){const t=new m.a({vd:e.getDescription()});return t.addEnvelope(e,!1),this.generalize(t)}if((0,r.f)(t)){const t=new m.P({vd:e.getDescription()});return t.addSegment(e,!0),this.generalize(t)}if((0,r.h)(t)||(0,r.t)(""),e.isEmpty()||this.m_maxDeviation<=0)return e;const s=(new a.O).execute(e,0,.05*this.m_maxDeviation,0,this.m_progressTracker);e.hasNonLinearSegments()&&(this.m_maxDeviation*=.95);const i=s,o=e.createInstance();o.getGeometryType()===r.G.enumPolygon&&o.setFillRule(e.getFillRule()),this.m_xy=i.getAttributeStreamRef(0);{const e={stack:[],error:void 0,hasError:!1};try{const t=new m.L;this.m_pline=t,(0,n.b)(e,(0,h.h)((()=>{this.m_pline=null}),!1),!1);for(let e=0,t=i.getPathCount();e<t;e++)this.generalizePath(i.getImpl(),e,o.getImpl())}catch(t){e.error=t,e.hasError=!0}finally{(0,n.c)(e)}}return this.m_resultstack.length=0,this.m_stack.length=0,o}generalizePath(e,t,s){if(e.getPathSize(t)<2)return;this.m_resultstack.length=0,this.m_stack.length=0;const n=e.getPathStart(t),i=e.getPathEnd(t)-1,r=e.isClosedPath(t),m=e.isClosedPathInXYPlane(t);let o=0,a=-1;this.m_stack.push(r?n:i),this.m_stack.push(n);let l=!1,c=!1;for(!this.m_bRemoveDegenerateParts&&m&&(l=!0,c=!0);this.m_stack.length>1;){const t=this.m_stack.at(-1);this.m_stack.pop();const s=this.m_stack.at(-1);let n=e.getXY(t);this.m_pline.setStartXY(n),n=e.getXY(s),this.m_pline.setEndXY(n);const r=[Number.NaN];let m=this.findGreatestDistance(t,s,i,r);m>=0&&(l?l=!1:(c&&r[0]>o&&(o=r[0],a=m),r[0]<=this.m_maxDeviation&&(m=-1))),m>=0?(this.m_stack.push(m),this.m_stack.push(t)):this.m_resultstack.push(t)}r||this.m_resultstack.push(this.m_stack[0]);const u=this.m_resultstack.length;if(u===e.getPathSize(t)&&u===this.m_stack.length)s.addPath(e,t,!0);else if(this.m_resultstack.length>0){if(this.m_bRemoveDegenerateParts&&this.m_resultstack.length<=2){if(r||1===this.m_resultstack.length)return;if(h.P.distance(e.getXY(this.m_resultstack[0]),e.getXY(this.m_resultstack[1]))<=this.m_maxDeviation)return}if(c&&a>=0&&o<=this.m_maxDeviation){const e=this.m_resultstack.at(-1)>a;this.m_resultstack.push(a),e&&(this.m_resultstack[this.m_resultstack.length-2]=(0,h.c)(this.m_resultstack[this.m_resultstack.length-1],this.m_resultstack[this.m_resultstack.length-1]=this.m_resultstack[this.m_resultstack.length-2]))}for(let t=0,n=this.m_resultstack.length;t<n;t++)e.getPointByVal(this.m_resultstack[t],this.m_point),0===t?s.startPathPoint(this.m_point):s.lineToPoint(this.m_point);if(r){for(let e=this.m_resultstack.length;e<3;e++)s.lineToPoint(this.m_point);s.closePathWithLine()}}}findGreatestDistance(e,t,s,n){let i=t-1;t<=e&&(i=s);let r=-1,m=0;const o=new h.P;for(let t=e+1;t<=i;t++){this.m_xy.queryPoint2D(2*t,o);const e=o.x,s=o.y,n=this.m_pline.getClosestCoordinate(o,!1);o.assign(this.m_pline.getCoord2D(n)),o.x-=e,o.y-=s;const i=o.length();i>m&&(r=t,m=i),this.m_callCount++}return n[0]=m,r}}},76061:(e,t,s)=>{s.d(t,{G:()=>n,S:()=>i});class n{*[Symbol.iterator](){let e=this.next();for(;e;)yield e,e=this.next()}}class i extends n{constructor(e){super(),this.m_iGeom=-1,this.m_aGeoms=e?e.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const e=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,e}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},98783:(e,t,s)=>{s.d(t,{O:()=>m});var n=s(76061),i=s(55537),r=s(12189);class m{getOperatorType(){return 10104}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}supportsCurves(){return!0}isSimple(e,t,s,n,i){return 5===(0,r.k)(e,t,s,n,i)}executeMany(e,t,s,n){return new o(e,t,s,n)}execute(e,t,s,r){const m=new n.S([e]),o=this.executeMany(m,t,s,r).next();return o||(0,i.d)("null output"),o}}class o extends n.G{constructor(e,t,s,n){super(),e||(0,i.a)(""),this.m_progressTracker=n,this.m_bForceSimplify=s,this.m_index=-1,this.m_inputGeometryCursor=e,this.m_spatialReference=t}next(){const e=this.m_inputGeometryCursor.next();return e?((0,i.c)(e),this.m_index=this.m_inputGeometryCursor.getGeometryID(),this.simplify(e)):null}getGeometryID(){return this.m_index}tock(){return!1}getRank(){return 1}simplify(e){return e||(0,i.a)(""),(0,r.s)(e,this.m_spatialReference,this.m_bForceSimplify,this.m_progressTracker)}}}}]);