"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[7136,9341],{51624:(t,e,s)=>{s.d(e,{A:()=>f});var n,i,r=s(44208),o=s(69397),a=s(93687);(i=n||(n={}))[i.varint=0]="varint",i[i.fixed64=1]="fixed64",i[i.delimited=2]="delimited",i[i.fixed32=5]="fixed32",i[i.unknown=99]="unknown";const h=4294967296,u=new TextDecoder("utf-8"),c=(0,r.A)("safari")||(0,r.A)("ios")?6:(0,r.A)("ff")?12:32;class f{constructor(t,e,s=0,i=(t?t.byteLength:0)){this._tag=0,this._dataType=n.unknown,this._init(t,e,s,i)}_init(t,e,s,n){this._data=t,this._dataView=e,this._pos=s,this._end=n}get usedMemory(){return 64+(0,o.Qf)(this._data)}asUnsafe(){return this}clone(){return new f(this._data,this._dataView,this._pos,this._end)}pos(){return this._pos}move(t){this._pos=t}nextTag(t){for(;;){if(this._pos===this._end)return!1;const e=this._decodeVarint();if(this._tag=e>>3,this._dataType=7&e,!t||t===this._tag)break;this.skip()}return!0}next(){if(this._pos===this._end)return!1;const t=this._decodeVarint();return this._tag=t>>3,this._dataType=7&t,!0}empty(){return this._pos>=this._end}tag(){return this._tag}getInt32(){return this._decodeVarint()}getInt64(){return this._decodeVarint()}getUInt32(){let t=4294967295;if(t=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128)return t;if(t=(t|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128)return t;if(t=(t|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128)return t;if(t=(t|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128)return t;if(t=(t|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128)return t;throw new Error("Varint overflow")}getUInt64(){return this._decodeVarint()}getSInt32(){const t=this.getUInt32();return t>>>1^-(1&t)}getSInt64(){return this._decodeSVarint()}getBool(){const t=0!==this._data[this._pos];return this._skip(1),t}getEnum(){return this._decodeVarint()}getFixed64(){const t=this._dataView,e=this._pos,s=t.getUint32(e,!0)+t.getUint32(e+4,!0)*h;return this._skip(8),s}getSFixed64(){const t=this._dataView,e=this._pos,s=t.getUint32(e,!0)+t.getInt32(e+4,!0)*h;return this._skip(8),s}getDouble(){const t=this._dataView.getFloat64(this._pos,!0);return this._skip(8),t}getFixed32(){const t=this._dataView.getUint32(this._pos,!0);return this._skip(4),t}getSFixed32(){const t=this._dataView.getInt32(this._pos,!0);return this._skip(4),t}getFloat(){const t=this._dataView.getFloat32(this._pos,!0);return this._skip(4),t}getString(){const t=this._getLength(),e=this._pos,s=this._toString(this._data,e,e+t);return this._skip(t),s}getBytes(){const t=this._getLength(),e=this._pos,s=this._toBytes(this._data,e,e+t);return this._skip(t),s}getLength(){return this._getLengthUnsafe()}processMessageWithArgs(t,e,s,n){const i=this.getMessage(),r=t(i,e,s,n);return i.release(),r}processMessage(t){const e=this.getMessage(),s=t(e);return e.release(),s}getMessage(){const t=this._getLength(),e=f.pool.acquire();return e._init(this._data,this._dataView,this._pos,this._pos+t),this._skip(t),e}release(){f.pool.release(this)}dataType(){return this._dataType}skip(){switch(this._dataType){case n.varint:this._decodeVarint();break;case n.fixed64:this._skip(8);break;case n.delimited:this._skip(this._getLength());break;case n.fixed32:this._skip(4);break;default:throw new Error("Invalid data type!")}}skipLen(t){this._skip(t)}_skip(t){if(this._pos+t>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=t}_decodeVarint(){const t=this._data;let e=this._pos,s=0,n=0;if(this._end-e>=10)do{if(n=t[e++],s|=127&n,!(128&n))break;if(n=t[e++],s|=(127&n)<<7,!(128&n))break;if(n=t[e++],s|=(127&n)<<14,!(128&n))break;if(n=t[e++],s|=(127&n)<<21,!(128&n))break;if(n=t[e++],s+=268435456*(127&n),!(128&n))break;if(n=t[e++],s+=34359738368*(127&n),!(128&n))break;if(n=t[e++],s+=4398046511104*(127&n),!(128&n))break;if(n=t[e++],s+=562949953421312*(127&n),!(128&n))break;if(n=t[e++],s+=72057594037927940*(127&n),!(128&n))break;if(n=t[e++],s+=0x8000000000000000*(127&n),!(128&n))break;throw new Error("Varint too long!")}while(0);else{let i=1;for(;e!==this._end&&(n=t[e],128&n);)++e,s+=(127&n)*i,i*=128;if(e===this._end)throw new Error("Varint overrun!");++e,s+=n*i}return this._pos=e,s}_decodeSVarint(){const t=this._data;let e,s=0,n=0;const i=1&t[this._pos];if(n=t[this._pos++],s|=127&n,!(128&n))return i?-(s+1)/2:s/2;if(n=t[this._pos++],s|=(127&n)<<7,!(128&n))return i?-(s+1)/2:s/2;if(n=t[this._pos++],s|=(127&n)<<14,!(128&n))return i?-(s+1)/2:s/2;if(n=t[this._pos++],s|=(127&n)<<21,!(128&n))return i?-(s+1)/2:s/2;if(n=t[this._pos++],s+=268435456*(127&n),!(128&n))return i?-(s+1)/2:s/2;if(n=t[this._pos++],s+=34359738368*(127&n),!(128&n))return i?-(s+1)/2:s/2;if(n=t[this._pos++],s+=4398046511104*(127&n),!(128&n))return i?-(s+1)/2:s/2;if(e=BigInt(s),n=t[this._pos++],e+=0x2000000000000n*BigInt(127&n),!(128&n))return Number(i?-(e+1n)/2n:e/2n);if(n=t[this._pos++],e+=0x100000000000000n*BigInt(127&n),!(128&n))return Number(i?-(e+1n)/2n:e/2n);if(n=t[this._pos++],e+=0x8000000000000000n*BigInt(127&n),!(128&n))return Number(i?-(e+1n)/2n:e/2n);throw new Error("Varint too long!")}_getLength(){if(this._dataType!==n.delimited)throw new Error("Not a delimited data type!");return this._decodeVarint()}_getLengthUnsafe(){return this.getUInt32()}_toString(t,e,s){if((s=Math.min(this._end,s))-e>c){const n=t.subarray(e,s);return u.decode(n)}let n="",i="";for(let r=e;r<s;++r){const e=t[r];128&e?i+="%"+e.toString(16):(n+=decodeURIComponent(i)+String.fromCharCode(e),i="")}return i.length&&(n+=decodeURIComponent(i)),n}_toBytes(t,e,s){return s=Math.min(this._end,s),new Uint8Array(t.buffer,e,s-e)}}f.pool=new a.A(f,void 0,(t=>{t._data=null,t._dataView=null}))},17136:(t,e,s)=>{s.d(e,{O7:()=>A,el:()=>x});var n=s(92602),i=s(49186),r=s(53966),o=s(39829),a=s(82799),h=s(80754),u=s(21325),c=s(28735),f=s(78888),p=s(65864),l=s(2272),d=s(84952),_=s(92300);const g=()=>r.A.getLogger("esri.geometry.support.normalizeUtils");function y(t){return"polygon"===t[0].type}function m(t){return"polyline"===t[0].type}function k(t,e,s){if(e){const e=function(t,e){if(!(t instanceof a.A||t instanceof o.A)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw g().error(t),new i.A(t)}const s=(0,h.r8)(t),n=[];for(const t of s){const s=[];n.push(s),s.push([t[0][0],t[0][1]]);for(let n=0;n<t.length-1;n++){const i=t[n][0],r=t[n][1],o=t[n+1][0],a=t[n+1][1],h=Math.sqrt((o-i)*(o-i)+(a-r)*(a-r)),u=(a-r)/h,c=(o-i)/h,f=h/e;if(f>1){for(let t=1;t<=f-1;t++){const n=t*e,o=c*n+i,a=u*n+r;s.push([o,a])}const t=(h+Math.floor(f-1)*e)/2,n=c*t+i,o=u*t+r;s.push([n,o])}s.push([o,a])}}return function(t){return"polygon"===t.type}(t)?new o.A({rings:n,spatialReference:t.spatialReference}):new a.A({paths:n,spatialReference:t.spatialReference})}(t,1e6);t=(0,c.ci)(e,!0)}return s&&(t=(0,h.kS)(t,s)),t}function w(t,e,s){if(Array.isArray(t)){const n=t[0];if(n>e){const s=(0,h.kd)(n,e);t[0]=n+s*(-2*e)}else if(n<s){const e=(0,h.kd)(n,s);t[0]=n+e*(-2*s)}}else{const n=t.x;if(n>e){const s=(0,h.kd)(n,e);t=t.clone().offset(s*(-2*e),0)}else if(n<s){const e=(0,h.kd)(n,s);t=t.clone().offset(e*(-2*s),0)}}return t}function b(t,e){let s=-1;for(let n=0;n<e.cutIndexes.length;n++){const i=e.cutIndexes[n],r=e.geometries[n],o=(0,h.r8)(r);for(let t=0;t<o.length;t++){const e=o[t];e.some((s=>{if(s[0]<180)return!0;{let s=0;for(let t=0;t<e.length;t++){const n=e[t][0];s=n>s?n:s}s=Number(s.toFixed(9));const n=-360*(0,h.kd)(s,180);for(let s=0;s<e.length;s++){const e=r.getPoint(t,s);r.setPoint(t,s,e.clone().offset(n,0))}return!0}}))}if(i===s){if(y(t))for(const e of(0,h.r8)(r))t[i]=t[i].addRing(e);else if(m(t))for(const e of(0,h.r8)(r))t[i]=t[i].addPath(e)}else s=i,t[i]=r}return t}async function x(t,e,s){if(!Array.isArray(t))return x([t],e);e&&"string"!=typeof e&&g().warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const i="string"==typeof e?e:e?.url??n.A.geometryServiceUrl;let r,y,m,A,V,S,M,I,L=0;const R=[],N=[];for(const e of t)if(null!=e)if(r||(r=e.spatialReference,y=(0,u.Vp)(r),m=r.isWebMercator,S=m?102100:4326,A=h.j7[S].maxX,V=h.j7[S].minX,M=h.j7[S].plus180Line,I=h.j7[S].minus180Line),y)if("mesh"===e.type)N.push(e);else if("point"===e.type)N.push(w(e.clone(),A,V));else if("multipoint"===e.type){const t=e.clone();t.points=t.points.map((t=>w(t,A,V))),N.push(t)}else if("extent"===e.type){const t=e.clone()._normalize(!1,!1,y);N.push(t.rings?new o.A(t):t)}else if(e.extent){const t=e.extent,s=(0,h.kd)(t.xmin,V)*(2*A);let n=0===s?e.clone():(0,h.kS)(e.clone(),s);t.offset(s,0);let{xmin:i,xmax:r}=t;i=Number(i.toFixed(9)),r=Number(r.toFixed(9)),t.intersects(M)&&r!==A?(L=r>L?r:L,n=k(n,m),R.push(n),N.push("cut")):t.intersects(I)&&i!==V?(L=r*(2*A)>L?r*(2*A):L,n=k(n,m,360),R.push(n),N.push("cut")):N.push(n)}else N.push(e.clone());else N.push(e);else N.push(e);let U=(0,h.kd)(L,A),v=-90;const T=U,B=new a.A;for(;U>0;){const t=360*U-180;B.addPath([[t,v],[t,-1*v]]),v*=-1,U--}if(R.length>0&&T>0){const e=b(R,await async function(t,e,s,n){const i=(0,l.Dl)(t),r=e[0].spatialReference,o={...n,responseType:"json",query:{...i.query,f:"json",sr:(0,u.YX)(r),target:JSON.stringify({geometryType:(0,p.$B)(e[0]),geometries:e}),cutter:JSON.stringify(s)}},a=await(0,f.A)(i.path+"/cut",o),{cutIndexes:h,geometries:c=[]}=a.data;return{cutIndexes:h,geometries:c.map((t=>{const e=(0,p.rS)(t);return e.spatialReference=r,e}))}}(i,R,B,s)),n=[],r=[];for(let s=0;s<N.length;s++){const i=N[s];if("cut"!==i)r.push(i);else{const i=e.shift(),o=t[s];null!=o&&"polygon"===o.type&&o.rings&&o.rings.length>1&&i.rings.length>=o.rings.length?(n.push(i),r.push("simplify")):r.push(m?(0,c.Gh)(i):i)}}if(!n.length)return r;const o=await async function(t,e,s){const n="string"==typeof t?(0,d.An)(t):t,i=e[0].spatialReference,r=(0,p.$B)(e[0]),o={...s,query:{...n.query,f:"json",sr:(0,u.YX)(i),geometries:JSON.stringify((0,_.X)(e))}},{data:a}=await(0,f.A)(n.path+"/simplify",o);return(0,_.V)(a.geometries,r,i)}(i,n,s),a=[];for(let t=0;t<r.length;t++){const e=r[t];"simplify"!==e?a.push(e):a.push(m?(0,c.Gh)(o.shift()):o.shift())}return a}const j=[];for(let t=0;t<N.length;t++){const e=N[t];if("cut"!==e)j.push(e);else{const t=R.shift();j.push(!0===m?(0,c.Gh)(t):t)}}return j}function A(t,e,s){const n=(0,u.Vp)(s);if(null==n)return t;const[i,r]=n.valid,o=2*r;let a=0,h=0;e>r?a=Math.ceil(Math.abs(e-r)/o):e<i&&(a=-Math.ceil(Math.abs(e-i)/o)),t>r?h=Math.ceil(Math.abs(t-r)/o):t<i&&(h=-Math.ceil(Math.abs(t-i)/o));let c=t+(a-h)*o;const f=c-e;return f>r?c-=o:f<i&&(c+=o),c}},80754:(t,e,s)=>{s.d(e,{j7:()=>o,kS:()=>h,kd:()=>a,r8:()=>u});var n=s(82799),i=s(16930),r=s(65864);const o={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new n.A({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:i.A.WebMercator}),minus180Line:new n.A({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:i.A.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new n.A({paths:[[[180,-180],[180,180]]],spatialReference:i.A.WGS84}),minus180Line:new n.A({paths:[[[-180,-180],[-180,180]]],spatialReference:i.A.WGS84})}};function a(t,e){return Math.ceil((t-e)/(2*e))}function h(t,e){const s=u(t);for(const t of s)for(const s of t)s[0]+=e;return t}function u(t){return(0,r.Bi)(t)?t.rings:t.paths}},92300:(t,e,s)=>{s.d(e,{V:()=>r,X:()=>i});var n=s(65864);function i(t){return{geometryType:(0,n.$B)(t[0]),geometries:t.map((t=>t.toJSON()))}}function r(t,e,s){const i=(0,n.xD)(e);return t.map((t=>{const e=i.fromJSON(t);return e.spatialReference=s,e}))}},2272:(t,e,s)=>{s.d(e,{Dl:()=>o,jV:()=>r,lF:()=>a}),s(92602),s(70333);var n=s(4718),i=s(84952);function r(t,e){return e?{...e,query:{...t??{},...e.query}}:{query:t}}function o(t){return"string"==typeof t?(0,i.An)(t):(0,n.o8)(t)}function a(t,e,s){const n={};for(const i in t){if("declaredClass"===i)continue;const r=t[i];if(null!=r&&"function"!=typeof r)if(Array.isArray(r))n[i]=r.map((t=>a(t)));else if("object"==typeof r)if(r.toJSON){const t=r.toJSON(s?.[i]);n[i]=e?t:JSON.stringify(t)}else n[i]=e?r:JSON.stringify(r);else n[i]=r}return n}s(926)}}]);