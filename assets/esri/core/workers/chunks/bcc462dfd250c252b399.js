"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[4210,4889],{13867:(e,t,r)=>{r.d(t,{Z:()=>i});var s=r(69801);class i{constructor(e,t){this._storage=new s.WJ,this._storage.maxSize=e,t&&this._storage.registerRemoveFunc("",t)}put(e,t,r){this._storage.put(e,t,r,1)}pop(e){return this._storage.pop(e)}get(e){return this._storage.get(e)}clear(){this._storage.clearAll()}destroy(){this._storage.destroy()}get maxSize(){return this._storage.maxSize}set maxSize(e){this._storage.maxSize=e}}},64830:(e,t,r)=>{r.d(t,{Z:()=>i});var s=r(70586);class i{constructor(e=(e=>e.values().next().value)){this._peeker=e,this._items=new Set}get length(){return this._items.size}clear(){this._items.clear()}last(){if(0===this._items.size)return;let e;for(e of this._items);return e}peek(){if(0!==this._items.size)return this._peeker(this._items)}push(e){this.contains(e)||this._items.add(e)}contains(e){return this._items.has(e)}pop(){if(0===this.length)return;const e=this.peek();return this._items.delete((0,s.j0)(e)),e}popLast(){if(0===this.length)return;const e=this.last();return this._items.delete((0,s.j0)(e)),e}remove(e){this._items.delete(e)}filter(e){return this._items.forEach((t=>{e(t)||this._items.delete(t)})),this}}},80903:(e,t,r)=>{r.d(t,{Z:()=>l});var s=r(50758),i=r(92604),n=r(95330),o=r(64830),a=r(25045);class l{constructor(){this._inUseClients=new Array,this._clients=new Array,this._clientPromises=new Array,this._ongoingJobsQueue=new o.Z}destroy(){this.close()}get closed(){return!this._clients||!this._clients.length}open(e,t){return new Promise(((r,s)=>{let i=!0;const o=e=>{(0,n.k_)(t.signal),i&&(i=!1,e())};this._clients.length=e.length,this._clientPromises.length=e.length,this._inUseClients.length=e.length;for(let i=0;i<e.length;++i){const l=e[i];(0,n.y8)(l)?this._clientPromises[i]=l.then((e=>(this._clients[i]=new a.default(e,t,(()=>this._ongoingJobsQueue.pop()??null)),o(r),this._clients[i])),(()=>(o(s),null))):(this._clients[i]=new a.default(l,t,(()=>this._ongoingJobsQueue.pop()??null)),this._clientPromises[i]=Promise.resolve(this._clients[i]),o(r))}}))}broadcast(e,t,r){const s=new Array(this._clientPromises.length);for(let i=0;i<this._clientPromises.length;++i){const n=this._clientPromises[i];s[i]=n.then((s=>s?.invoke(e,t,r)))}return s}close(){let e;for(;e=this._ongoingJobsQueue.pop();)e.deferred.reject((0,n.zE)(`Worker closing, aborting job calling '${e.methodName}'`));for(const e of this._clientPromises)e.then((e=>e?.close()));this._clients.length=0,this._clientPromises.length=0}invoke(e,t,r){let s;Array.isArray(r)?(i.Z.getLogger("esri.core.workers.Connection").warn("invoke()","The transferList parameter is deprecated, use the options object instead"),s={transferList:r}):s=r;const o=(0,n.dD)();this._ongoingJobsQueue.push({methodName:e,data:t,invokeOptions:s,deferred:o});for(let e=0;e<this._clientPromises.length;e++){const t=this._clients[e];t?t.jobAdded():this._clientPromises[e].then((e=>e?.jobAdded()))}return o.promise}on(e,t){return Promise.all(this._clientPromises).then((()=>(0,s.AL)(this._clients.map((r=>r.on(e,t))))))}openPorts(){return new Promise((e=>{const t=new Array(this._clientPromises.length);let r=t.length;for(let s=0;s<this._clientPromises.length;++s)this._clientPromises[s].then((i=>{i&&(t[s]=i.openPort()),0==--r&&e(t)}))}))}get test(){return{numClients:this._clients.length}}}},78346:(e,t,r)=>{r.d(t,{bA:()=>A});var s=r(20102),i=r(80442),n=r(95330),o=r(80903),a=r(25045),l=r(40330),c=r(92604),u=r(70586),h=r(94362),f=r(99880),d=r(68773),p=(r(2587),r(17452));const m={};function g(e){const t={async:e.async,isDebug:e.isDebug,locale:e.locale,baseUrl:e.baseUrl,has:{...e.has},map:{...e.map},packages:e.packages&&e.packages.concat()||[],paths:{...e.paths}};return e.hasOwnProperty("async")||(t.async=!0),e.hasOwnProperty("isDebug")||(t.isDebug=!1),e.baseUrl||(t.baseUrl=m.baseUrl),m.packages?.forEach((e=>{!function(e,t){for(const r of e)if(r.name===t.name)return;e.push(t)}(t.packages??[],e)})),t}var y=r(41213);class x{constructor(){const e=document.createDocumentFragment();["addEventListener","dispatchEvent","removeEventListener"].forEach((t=>{this[t]=(...r)=>e[t](...r)}))}}class w{constructor(){this._dispatcher=new x,this._workerPostMessage({type:h.Cs.HANDSHAKE})}terminate(){}get onmessage(){return this._onmessageHandler}set onmessage(e){this._onmessageHandler&&this.removeEventListener("message",this._onmessageHandler),this._onmessageHandler=e,e&&this.addEventListener("message",e)}get onmessageerror(){return this._onmessageerrorHandler}set onmessageerror(e){this._onmessageerrorHandler&&this.removeEventListener("messageerror",this._onmessageerrorHandler),this._onmessageerrorHandler=e,e&&this.addEventListener("messageerror",e)}get onerror(){return this._onerrorHandler}set onerror(e){this._onerrorHandler&&this.removeEventListener("error",this._onerrorHandler),this._onerrorHandler=e,e&&this.addEventListener("error",e)}postMessage(e){(0,y.Y)((()=>{this._workerMessageHandler(new MessageEvent("message",{data:e}))}))}dispatchEvent(e){return this._dispatcher.dispatchEvent(e)}addEventListener(e,t,r){this._dispatcher.addEventListener(e,t,r)}removeEventListener(e,t,r){this._dispatcher.removeEventListener(e,t,r)}_workerPostMessage(e){(0,y.Y)((()=>{this.dispatchEvent(new MessageEvent("message",{data:e}))}))}async _workerMessageHandler(e){const t=(0,h.QM)(e);if(t&&t.type===h.Cs.OPEN){const{modulePath:e,jobId:r}=t;let s=await a.default.loadWorker(e);s||(s=await import(e));const i=a.default.connect(s);this._workerPostMessage({type:h.Cs.OPENED,jobId:r,data:i})}}}var b=r(70171),I=r(17202);const _=c.Z.getLogger("esri.core.workers.workerFactory"),{HANDSHAKE:v}=h.Cs;let S,C;const R="Failed to create Worker. Fallback to execute module in main thread";async function k(e){return new Promise((t=>{function r(i){const n=(0,h.QM)(i);n&&n.type===v&&(e.removeEventListener("message",r),e.removeEventListener("error",s),t(e))}function s(t){t.preventDefault(),e.removeEventListener("message",r),e.removeEventListener("error",s),_.warn("Failed to create Worker. Fallback to execute module in main thread",t),(e=new w).addEventListener("message",r),e.addEventListener("error",s)}e.addEventListener("message",r),e.addEventListener("error",s)}))}let T=0;const{ABORT:P,INVOKE:M,OPEN:F,OPENED:O,RESPONSE:E}=h.Cs;class N{constructor(e,t){this._outJobs=new Map,this._inJobs=new Map,this.worker=e,this.id=t,e.addEventListener("message",this._onMessage.bind(this)),e.addEventListener("error",(e=>{e.preventDefault(),c.Z.getLogger("esri.core.workers.WorkerOwner").error(e)}))}static async create(e){const t=await async function(){if(!(0,i.Z)("esri-workers")||((0,i.Z)("mozilla"),0))return k(new w);if(!S&&!C)try{const e='let globalId=0;const outgoing=new Map,configuration=JSON.parse("{CONFIGURATION}");self.esriConfig=configuration.esriConfig;const workerPath=self.esriConfig.workers.workerPath,HANDSHAKE=0,OPEN=1,OPENED=2,RESPONSE=3,INVOKE=4,ABORT=5;function createAbortError(){const e=new Error("Aborted");return e.name="AbortError",e}function receiveMessage(e){return e&&e.data?"string"==typeof e.data?JSON.parse(e.data):e.data:null}function invokeStaticMessage(e,o,r){const t=r&&r.signal,n=globalId++;return new Promise(((r,i)=>{if(t){if(t.aborted)return i(createAbortError());t.addEventListener("abort",(()=>{outgoing.get(n)&&(outgoing.delete(n),self.postMessage({type:5,jobId:n}),i(createAbortError()))}))}outgoing.set(n,{resolve:r,reject:i}),self.postMessage({type:4,jobId:n,methodName:e,abortable:null!=t,data:o})}))}let workerRevisionChecked=!1;function checkWorkerRevision(e){if(!workerRevisionChecked&&e.kernelInfo){workerRevisionChecked=!0;const{revision:o,version:r}=configuration.kernelInfo,{revision:t,version:n}=e.kernelInfo;!esriConfig.assetsPath!==esriConfig.defaultAssetsPath&&o!==t&&console.warn(`Version mismatch detected between ArcGIS API for JavaScript modules and assets. For more information visit https://bit.ly/3QnsuSo.\\nModules version: ${r}\\nAssets version: ${n}`)}}function messageHandler(e){const o=receiveMessage(e);if(!o)return;const r=o.jobId;switch(o.type){case 1:let n;function t(e){const o=n.connect(e);self.postMessage({type:2,jobId:r,data:o},[o])}"function"==typeof define&&define.amd?require([workerPath],(e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||new Promise((e=>{require([o.modulePath],e)})))).then(t)})):"System"in self&&"function"==typeof System.import?System.import(workerPath).then((e=>(n=e.default,checkWorkerRevision(n),n.loadWorker(o.modulePath)))).then((e=>e||System.import(o.modulePath))).then(t):esriConfig.workers.useDynamicImport?import(workerPath).then((e=>{n=e.default||e,checkWorkerRevision(n),n.loadWorker(o.modulePath).then((e=>e||import(o.modulePath))).then(t)})):(self.RemoteClient||importScripts(workerPath),n=self.RemoteClient.default||self.RemoteClient,checkWorkerRevision(n),n.loadWorker(o.modulePath).then(t));break;case 3:if(outgoing.has(r)){const i=outgoing.get(r);outgoing.delete(r),o.error?i.reject(JSON.parse(o.error)):i.resolve(o.data)}}}self.dojoConfig=configuration.loaderConfig,esriConfig.workers.loaderUrl&&(self.importScripts(esriConfig.workers.loaderUrl),"function"==typeof require&&"function"==typeof require.config&&require.config(configuration.loaderConfig)),self.addEventListener("message",messageHandler),self.postMessage({type:0});'.split('"{CONFIGURATION}"').join(`'${function(){let e;if(null!=d.Z.default){const t={...d.Z};delete t.default,e=JSON.parse(JSON.stringify(t))}else e=JSON.parse(JSON.stringify(d.Z));e.assetsPath=(0,p.hF)(e.assetsPath),e.defaultAssetsPath=e.defaultAssetsPath?(0,p.hF)(e.defaultAssetsPath):void 0,e.request.interceptors=[],e.log.interceptors=[],e.locale=(0,b.Kd)(),e.has={"esri-csp-restrictions":(0,i.Z)("esri-csp-restrictions"),"esri-2d-debug":!1,"esri-2d-update-debug":(0,i.Z)("esri-2d-update-debug"),"featurelayer-pbf":(0,i.Z)("featurelayer-pbf"),"featurelayer-simplify-thresholds":(0,i.Z)("featurelayer-simplify-thresholds"),"featurelayer-simplify-payload-size-factors":(0,i.Z)("featurelayer-simplify-payload-size-factors"),"featurelayer-simplify-mobile-factor":(0,i.Z)("featurelayer-simplify-mobile-factor"),"esri-atomics":(0,i.Z)("esri-atomics"),"esri-shared-array-buffer":(0,i.Z)("esri-shared-array-buffer"),"esri-tiles-debug":(0,i.Z)("esri-tiles-debug"),"esri-workers-arraybuffer-transfer":(0,i.Z)("esri-workers-arraybuffer-transfer"),"feature-polyline-generalization-factor":(0,i.Z)("feature-polyline-generalization-factor"),"host-webworker":1,"polylabel-placement-enabled":(0,i.Z)("polylabel-placement-enabled")},e.workers.loaderUrl&&(e.workers.loaderUrl=(0,p.hF)(e.workers.loaderUrl)),e.workers.workerPath?e.workers.workerPath=(0,p.hF)(e.workers.workerPath):e.workers.workerPath=(0,p.hF)((0,f.V)("esri/core/workers/RemoteClient.js")),e.workers.useDynamicImport=!1;const t=d.Z.workers.loaderConfig,r=g({baseUrl:t?.baseUrl,locale:(0,b.Kd)(),has:{"csp-restrictions":1,"dojo-test-sniff":0,"host-webworker":1,...t?.has},map:{...t?.map},paths:{...t?.paths},packages:t?.packages||[]}),s={version:l.i8,buildDate:I.r,revision:I.$};return JSON.stringify({esriConfig:e,loaderConfig:r,kernelInfo:s})}()}'`);S=URL.createObjectURL(new Blob([e],{type:"text/javascript"}))}catch(e){C=e||{}}let e;if(S)try{e=new Worker(S,{name:"esri-worker-"+T++})}catch(t){_.warn(R,C),e=new w}else _.warn(R,C),e=new w;return k(e)}();return new N(t,e)}terminate(){this.worker.terminate()}async open(e,t={}){const{signal:r}=t,s=(0,h.jt)();return new Promise(((t,i)=>{const o={resolve:t,reject:i,abortHandle:(0,n.$F)(r,(()=>{this._outJobs.delete(s),this._post({type:P,jobId:s})}))};this._outJobs.set(s,o),this._post({type:F,jobId:s,modulePath:e})}))}_onMessage(e){const t=(0,h.QM)(e);if(t)switch(t.type){case O:this._onOpenedMessage(t);break;case E:this._onResponseMessage(t);break;case P:this._onAbortMessage(t);break;case M:this._onInvokeMessage(t)}}_onAbortMessage(e){const t=this._inJobs,r=e.jobId,s=t.get(r);s&&(s.controller&&s.controller.abort(),t.delete(r))}_onInvokeMessage(e){const{methodName:t,jobId:r,data:s,abortable:i}=e,o=i?new AbortController:null,a=this._inJobs,c=l.Nv[t];let u;try{if("function"!=typeof c)throw new TypeError(`${t} is not a function`);u=c.call(null,s,{signal:o?o.signal:null})}catch(e){return void this._post({type:E,jobId:r,error:(0,h.AB)(e)})}(0,n.y8)(u)?(a.set(r,{controller:o,promise:u}),u.then((e=>{a.has(r)&&(a.delete(r),this._post({type:E,jobId:r},e))}),(e=>{a.has(r)&&(a.delete(r),e||(e={message:"Error encountered at method"+t}),(0,n.D_)(e)||this._post({type:E,jobId:r,error:(0,h.AB)(e||{message:`Error encountered at method ${t}`})}))}))):this._post({type:E,jobId:r},u)}_onOpenedMessage(e){const{jobId:t,data:r}=e,s=this._outJobs.get(t);s&&(this._outJobs.delete(t),(0,u.hw)(s.abortHandle),s.resolve(r))}_onResponseMessage(e){const{jobId:t,error:r,data:i}=e,n=this._outJobs.get(t);n&&(this._outJobs.delete(t),(0,u.hw)(n.abortHandle),r?n.reject(s.Z.fromJSON(JSON.parse(r))):n.resolve(i))}_post(e,t,r){return(0,h.oi)(this.worker,e,t,r)}}let Z=(0,i.Z)("esri-workers-debug")?1:(0,i.Z)("host-browser")?navigator.hardwareConcurrency-1:0;Z||(Z=(0,i.Z)("safari")&&(0,i.Z)("mac")||(0,i.Z)("trident")?7:2);let B=0;const J=[];async function D(e,t){const r=new o.Z;return await r.open(e,t),r}async function A(e,t={}){if("string"!=typeof e)throw new s.Z("workers:undefined-module","modulePath is missing");let r=t.strategy||"distributed";if((0,i.Z)("host-webworker")&&!(0,i.Z)("esri-workers")&&(r="local"),"local"===r){let r=await a.default.loadWorker(e);r||(r=await import(e)),(0,n.k_)(t.signal);const s=t.client||r;return D([a.default.connect(r)],{...t,client:s})}if(await async function(){if(z)return z;L=new AbortController;const e=[];for(let t=0;t<Z;t++){const r=N.create(t).then((e=>(J[t]=e,e)));e.push(r)}return z=Promise.all(e),z}(),(0,n.k_)(t.signal),"dedicated"===r){const r=B++%Z;return D([await J[r].open(e,t)],t)}if(t.maxNumWorkers&&t.maxNumWorkers>0){const r=Math.min(t.maxNumWorkers,Z);if(r<Z){const s=new Array(r);for(let i=0;i<r;++i){const r=B++%Z;s[i]=J[r].open(e,t)}return D(s,t)}}return D(J.map((r=>r.open(e,t))),t)}let L,z=null},82526:(e,t,r)=>{r.d(t,{aX:()=>R});var s=r(68773),i=r(20102),n=r(92604),o=r(70586),a=r(38913),l=r(58901),c=r(82971),u=r(33955);const h={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new l.Z({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:c.Z.WebMercator}),minus180Line:new l.Z({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:c.Z.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new l.Z({paths:[[[180,-180],[180,180]]],spatialReference:c.Z.WGS84}),minus180Line:new l.Z({paths:[[[-180,-180],[-180,180]]],spatialReference:c.Z.WGS84})}};function f(e,t){return Math.ceil((e-t)/(2*t))}function d(e,t){const r=p(e);for(const e of r)for(const r of e)r[0]+=t;return e}function p(e){return(0,u.oU)(e)?e.rings:e.paths}var m=r(8744),g=r(40488),y=(r(66577),r(3172)),x=r(17452);function w(e){return{geometryType:(0,u.Ji)(e[0]),geometries:e.map((e=>e.toJSON()))}}const b=n.Z.getLogger("esri.geometry.support.normalizeUtils");function I(e){return"polygon"===e[0].type}function _(e){return"polyline"===e[0].type}function v(e,t,r){if(t){const t=function(e,t){if(!(e instanceof l.Z||e instanceof a.Z)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw b.error(e),new i.Z(e)}const r=p(e),s=[];for(const e of r){const r=[];s.push(r),r.push([e[0][0],e[0][1]]);for(let s=0;s<e.length-1;s++){const i=e[s][0],n=e[s][1],o=e[s+1][0],a=e[s+1][1],l=Math.sqrt((o-i)*(o-i)+(a-n)*(a-n)),c=(a-n)/l,u=(o-i)/l,h=l/t;if(h>1){for(let e=1;e<=h-1;e++){const s=e*t,o=u*s+i,a=c*s+n;r.push([o,a])}const e=(l+Math.floor(h-1)*t)/2,s=u*e+i,o=c*e+n;r.push([s,o])}r.push([o,a])}}return function(e){return"polygon"===e.type}(e)?new a.Z({rings:s,spatialReference:e.spatialReference}):new l.Z({paths:s,spatialReference:e.spatialReference})}(e,1e6);e=(0,g.Sx)(t,!0)}return r&&(e=d(e,r)),e}function S(e,t,r){if(Array.isArray(e)){const s=e[0];if(s>t){const r=f(s,t);e[0]=s+r*(-2*t)}else if(s<r){const t=f(s,r);e[0]=s+t*(-2*r)}}else{const s=e.x;if(s>t){const r=f(s,t);e=e.clone().offset(r*(-2*t),0)}else if(s<r){const t=f(s,r);e=e.clone().offset(t*(-2*r),0)}}return e}function C(e,t){let r=-1;for(let s=0;s<t.cutIndexes.length;s++){const i=t.cutIndexes[s],n=t.geometries[s],o=p(n);for(let e=0;e<o.length;e++){const t=o[e];t.some((r=>{if(r[0]<180)return!0;{let r=0;for(let e=0;e<t.length;e++){const s=t[e][0];r=s>r?s:r}r=Number(r.toFixed(9));const s=-360*f(r,180);for(let r=0;r<t.length;r++){const t=n.getPoint(e,r);n.setPoint(e,r,t.clone().offset(s,0))}return!0}}))}if(i===r){if(I(e))for(const t of p(n))e[i]=e[i].addRing(t);else if(_(e))for(const t of p(n))e[i]=e[i].addPath(t)}else r=i,e[i]=n}return e}async function R(e,t,r){if(!Array.isArray(e))return R([e],t);t&&"string"!=typeof t&&b.warn("normalizeCentralMeridian()","The url object is deprecated, use the url string instead");const i="string"==typeof t?t:t?.url??s.Z.geometryServiceUrl;let n,c,p,I,_,k,T,P,M=0;const F=[],O=[];for(const t of e)if((0,o.Wi)(t))O.push(t);else if(n||(n=t.spatialReference,c=(0,m.C5)(n),p=n.isWebMercator,k=p?102100:4326,I=h[k].maxX,_=h[k].minX,T=h[k].plus180Line,P=h[k].minus180Line),c)if("mesh"===t.type)O.push(t);else if("point"===t.type)O.push(S(t.clone(),I,_));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((e=>S(e,I,_))),O.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,c);O.push(e.rings?new a.Z(e):e)}else if(t.extent){const e=t.extent,r=f(e.xmin,_)*(2*I);let s=0===r?t.clone():d(t.clone(),r);e.offset(r,0),e.intersects(T)&&e.xmax!==I?(M=e.xmax>M?e.xmax:M,s=v(s,p),F.push(s),O.push("cut")):e.intersects(P)&&e.xmin!==_?(M=e.xmax*(2*I)>M?e.xmax*(2*I):M,s=v(s,p,360),F.push(s),O.push("cut")):O.push(s)}else O.push(t.clone());else O.push(t);let E=f(M,I),N=-90;const Z=E,B=new l.Z;for(;E>0;){const e=360*E-180;B.addPath([[e,N],[e,-1*N]]),N*=-1,E--}if(F.length>0&&Z>0){const t=C(F,await async function(e,t,r,s){const i="string"==typeof e?(0,x.mN)(e):e,n=t[0].spatialReference,o={...s,query:{...i.query,f:"json",sr:JSON.stringify(n),target:JSON.stringify({geometryType:(0,u.Ji)(t[0]),geometries:t}),cutter:JSON.stringify(r)}},a=await(0,y.default)(i.path+"/cut",o),{cutIndexes:l,geometries:c=[]}=a.data;return{cutIndexes:l,geometries:c.map((e=>{const t=(0,u.im)(e);return t.spatialReference=n,t}))}}(i,F,B,r)),s=[],n=[];for(let r=0;r<O.length;r++){const i=O[r];if("cut"!==i)n.push(i);else{const i=t.shift(),a=e[r];(0,o.pC)(a)&&"polygon"===a.type&&a.rings&&a.rings.length>1&&i.rings.length>=a.rings.length?(s.push(i),n.push("simplify")):n.push(p?(0,g.$)(i):i)}}if(!s.length)return n;const a=await async function(e,t,r){const s="string"==typeof e?(0,x.mN)(e):e,i=t[0].spatialReference,n=(0,u.Ji)(t[0]),o={...r,query:{...s.query,f:"json",sr:i.wkid?i.wkid:JSON.stringify(i),geometries:JSON.stringify(w(t))}};return function(e,t,r){const s=(0,u.q9)(t);return e.map((e=>{const t=s.fromJSON(e);return t.spatialReference=r,t}))}((await(0,y.default)(s.path+"/simplify",o)).data,n,i)}(i,s,r),l=[];for(let e=0;e<n.length;e++){const t=n[e];"simplify"!==t?l.push(t):l.push(p?(0,g.$)(a.shift()):a.shift())}return l}const J=[];for(let e=0;e<O.length;e++){const t=O[e];if("cut"!==t)J.push(t);else{const e=F.shift();J.push(!0===p?(0,g.$)(e):e)}}return J}},2587:(e,t,r)=>{r(90344),r(18848),r(940),r(70171);var s=r(94443),i=r(3172),n=r(20102),o=r(70586);async function a(e){if((0,o.pC)(c.fetchBundleAsset))return c.fetchBundleAsset(e);const t=await(0,i.default)(e,{responseType:"text"});return JSON.parse(t.data)}class l{constructor({base:e="",pattern:t,location:r=new URL(window.location.href)}){let s;s="string"==typeof r?e=>new URL(e,new URL(r,window.location.href)).href:r instanceof URL?e=>new URL(e,r).href:r,this.pattern="string"==typeof t?new RegExp(`^${t}`):t,this.getAssetUrl=s,e=e?e.endsWith("/")?e:e+"/":"",this.matcher=new RegExp(`^${e}(?:(.*)/)?(.*)$`)}fetchMessageBundle(e,t){return async function(e,t,r,i){const o=t.exec(r);if(!o)throw new n.Z("esri-intl:invalid-bundle",`Bundle id "${r}" is not compatible with the pattern "${t}"`);const l=o[1]?`${o[1]}/`:"",c=o[2],u=(0,s.Su)(i),h=`${l}${c}.json`,f=u?`${l}${c}_${u}.json`:h;let d;try{d=await a(e(f))}catch(t){if(f===h)throw new n.Z("intl:unknown-bundle",`Bundle "${r}" cannot be loaded`,{error:t});try{d=await a(e(h))}catch(e){throw new n.Z("intl:unknown-bundle",`Bundle "${r}" cannot be loaded`,{error:e})}}return d}(this.getAssetUrl,this.matcher,e,t)}}const c={};var u,h=r(99880);(0,s.tz)((u={pattern:"esri/",location:h.V},new l(u)))},940:(e,t,r)=>{r.d(t,{n:()=>c});var s=r(92604),i=r(78286),n=r(19153),o=r(90344),a=r(18848);const l=s.Z.getLogger("esri.intl.substitute");function c(e,t,r={}){const{format:s={}}=r;return(0,n.gx)(e,(e=>function(e,t,r){let s,n;const o=e.indexOf(":");if(-1===o?s=e.trim():(s=e.slice(0,o).trim(),n=e.slice(o+1).trim()),!s)return"";const a=(0,i.hS)(s,t);if(null==a)return"";const l=(n?r?.[n]:null)??r?.[s];return l?u(a,l):n?h(a,n):f(a)}(e,t,s)))}function u(e,t){switch(t.type){case"date":return(0,o.p6)(e,t.intlOptions);case"number":return(0,a.uf)(e,t.intlOptions);default:return l.warn("missing format descriptor for key {key}"),f(e)}}function h(e,t){switch(t.toLowerCase()){case"dateformat":return(0,o.p6)(e);case"numberformat":return(0,a.uf)(e);default:return l.warn(`inline format is unsupported since 4.12: ${t}`),/^(dateformat|datestring)/i.test(t)?(0,o.p6)(e):/^numberformat/i.test(t)?(0,a.uf)(e):f(e)}}function f(e){switch(typeof e){case"string":return e;case"number":return(0,a.uf)(e);case"boolean":return""+e;default:return e instanceof Date?(0,o.p6)(e):""}}},92045:(e,t,r)=>{r.r(t),r.d(t,{default:()=>nt});var s=r(43697),i=r(51773),n=r(30030),o=r(20102),a=r(70586),l=r(16453),c=r(95330),u=r(17445),h=r(5600),f=(r(67676),r(80442)),d=r(75215),p=r(36030),m=r(71715),g=r(52011),y=r(87085),x=r(71612),w=r(17017),b=(r(66577),r(3172)),I=r(92604),_=r(8744),v=r(66677),S=r(21506),C=r(35956),R=r(29876),k=r(40297),T=r(88281),P=r(11145),M=r(96674),F=r(609),O=r(36679),E=r(99815),N=r(73506),Z=r(94139);const B=new Map,J=new class{constructor(e=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const r=e+"/"+t,s=this._cachedBlocks;if(s.has(r)){const e=s.get(r);return e.refCount--,e.refCount<=0&&(s.delete(r),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const r=e+"/"+t,s=this._cachedBlocks;if(s.has(r)){const e=s.get(r);return e.ts=Date.now(),e.refCount++,s.delete(r),s.set(r,e),e.block}return null}putBlock(e,t,r,s){const i=this._cachedBlocks,n=e+"/"+t;if(i.has(n)){const e=i.get(n);e.ts=Date.now(),e.refCount++}else i.set(n,{block:r,ts:Date.now(),refCount:1,controller:s});this._trim(),this._updateTimer()}deleteBlock(e,t){const r=this._cachedBlocks,s=e+"/"+t;r.has(s)&&r.delete(s)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval((()=>{const t=Array.from(e),r=Date.now();for(let s=0;s<t.length&&t[s][1].ts<=r-this._duration;s++)e.delete(t[s][0]);0===e.size&&this._clearTimer()}),this._interval)}_trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let r=0;r<t.length-this._size;r++)e.delete(t[r][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function D(e,t){return null==t?e:`${e}?sliceId=${t}`}function A(e,t,r){const s=B.get(e);if(!s)return null==t?J.decreaseRefCount(e,r):0;if(null==t||null==s[t])return J.decreaseRefCount(e,r);const i=s[t]?.cache,n=i?.get(r);if(i&&n){if(n.refCount--,0===n.refCount){i.delete(r);for(let e=0;e<s.length;e++)s[e]?.cache.delete(r);n.controller&&n.controller.abort()}return n.refCount}return 0}function L(e,t,r){const s=B.get(e);if(!s)return null==t?J.getBlock(e,r):null;if(null==t||null==s[t]){for(let e=0;e<s.length;e++){const t=s[e]?.cache.get(r);if(t)return t.refCount++,t.block}return J.getBlock(e,r)}const i=s[t]?.cache.get(r);if(i)return i.refCount++,i.block;for(let e=0;e<s.length;e++){if(e===t||!s[e])continue;const i=s[e]?.cache,n=i?.get(r);if(i&&n)return n.refCount++,i.set(r,n),n.block}return null}function z(e,t,r,s,i=null){const n=B.get(e);if(!n)return void(null==t&&J.putBlock(e,r,s,i));if(null==t||null==n[t])return void J.putBlock(e,r,s,i);const o={refCount:1,block:s,isResolved:!1,isRejected:!1,controller:i};s.then((()=>o.isResolved=!0)).catch((()=>o.isRejected=!0)),n[t]?.cache.set(r,o)}function H(e,t,r){const s=B.get(e);s?null!=t&&null!=s[t]?s[t]?.cache.delete(r):J.deleteBlock(e,r):null==t&&J.deleteBlock(e,r)}var W=r(75993),j=r(55914),q=r(80676),G=r(6570);let U=class extends((0,F.v)(M.wq)){constructor(){super(...arguments),this.rasterJobHandler=null,this.datasetName=null,this.datasetFormat=null,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}async init(){const e=(0,N.zD)();this.addResolvingPromise(e),await this.when()}normalizeCtorArgs(e){return e&&e.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:P.Z.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=(0,N.ut)(e.spatialReference);return(0,a.pC)(t)&&e.extent.width>=t/2}set url(e){this._set("url",(0,v.Nm)(e,I.Z.getLogger(this.declaredClass)))}async open(e){throw new o.Z("BaseRaster:open-not-implemented","open() is not implemented")}async fetchTile(e,t,r,s={}){const i=s.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(e,t,r,i);return this.fetchPixels(n,i.size[0],i.size[1],s)}async identify(e,t={}){e=(0,d.TJ)(Z.Z,e).clone().normalize();const{multidimensionalDefinition:r,timeExtent:s}=t,{hasMultidimensionalTranspose:i,multidimensionalInfo:n}=this.rasterInfo;let{transposedVariableName:o}=t;const l=(0,a.pC)(n)&&i&&(null!=s||(0,E.WU)(r));l&&!o&&(o=(0,a.pC)(r)&&r.length>0?r[0].variableName??void 0:n.variables[0].name,t={...t,transposedVariableName:o}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:c,extent:u}=this.rasterInfo,{datumTransformation:h}=t;let f=(0,N.nF)(e,c,h);if(!u.intersects(f))return{location:f,value:null};if((0,a.pC)(this.rasterInfo.transform)){const e=this.rasterInfo.transform.inverseTransform(f);if(!this.rasterInfo.nativeExtent.intersects(e))return{location:e,value:null};f=e}let p=0;const m=(0,a.pC)(o)&&(0,a.pC)(n)&&this.rasterInfo.hasMultidimensionalTranspose;if(!m)if(t.srcResolution)p=(0,N.kr)(t.srcResolution,this.rasterInfo,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(e,t),null==p)return{location:f,value:null};const g=this.identifyPixelLocation(f,p,null,m);if(null===g)return{location:f,value:null};const{row:y,col:x,rowOffset:w,colOffset:b,blockWidth:I}=g,_=o??(0,a.Wg)(t.sliceId),v=D(this.url,_),S=`${p}/${y}/${x}`;let C=L(v,null,S);(0,a.Wi)(C)&&(C=this.fetchRawTile(p,y,x,t),z(v,null,S,C));const R=await C;if((0,a.Wi)(R)||!R.pixels?.length)return{location:f,value:null};const k=w*I+b;return this._processIdentifyResult(R,{srcLocation:f,position:k,pyramidLevel:p,useTransposedTile:!!m,requestSomeSlices:l,identifyOptions:t})}async fetchPixels(e,t,r,s={}){if(e=(0,N.kZ)(e),(s=this._getRequestOptionsWithSliceId(s)).requestRawData)return this._fetchPixels(e,t,r,s);const i=(0,N.ut)(e.spatialReference),n=(0,N.Hq)(e);if((0,a.Wi)(i)||0===n||1===n&&this._isGlobalWrappableSource)return this._fetchPixels(e,t,r,s);if(n>=3)return{extent:e,pixelBlock:null};const o=[],{xmin:l,xmax:c}=e,u=Math.round(i/(c-l)*t),h=u-Math.round((i/2-l)/(c-l)*t);let f=0;const d=[];for(let a=0;a<=n;a++){const p=new G.Z({xmin:0===a?l:-i/2,xmax:a===n?c-i*a:i/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),m=0===a?u-h:a===n?t-f:u;f+=m,d.push(m);const g=s.disableWrapAround&&a>0?null:this._fetchPixels(p,m,r,s);o.push(g)}const p=(await Promise.all(o)).map((e=>e?.pixelBlock));let m=null;const g={width:t,height:r};return m=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:g,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:d},s)).pixelBlock:(0,j.us)(p,g,{blockWidths:d}),{extent:e,srcExtent:(0,N.tB)(e,this.rasterInfo.spatialReference,s.datumTransformation),pixelBlock:m}}async fetchRawPixels(e,t,r,s={}){t={x:Math.floor(t.x),y:Math.floor(t.y)};const i=await this._fetchRawTiles(e,t,r,s),{nativeExtent:n,nativePixelSize:o,storageInfo:l}=this.rasterInfo,c=2**e,u=o.x*c,h=o.y*c,f=new G.Z({xmin:n.xmin+u*t.x,xmax:n.xmin+u*(t.x+r.width-1),ymin:n.ymax-h*(t.y+r.height-1),ymax:n.ymax-h*t.y,spatialReference:n.spatialReference});if(!i)return{extent:f,srcExtent:f,pixelBlock:null};const{pixelBlocks:d,mosaicSize:p}=i;if(1===d.length&&(0,a.pC)(d[0])&&d[0].width===r.width&&d[0].height===r.height)return{extent:f,srcExtent:f,pixelBlock:i.pixelBlocks[0]};const m=e>0?l.pyramidBlockWidth:l.blockWidth,g=e>0?l.pyramidBlockHeight:l.blockHeight,y={x:t.x%m,y:t.y%g};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:p,destDimension:r,clipOffset:y,clipSize:r,coefs:null,sampleSpacing:null,interpolation:s.interpolation,alignmentInfo:null,blockWidths:null},s)).pixelBlock:(0,j.us)(d,p,{clipOffset:y,clipSize:r}),{extent:f,srcExtent:f,pixelBlock:x}}fetchRawTile(e,t,r,s){throw new o.Z("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return(0,N.tB)(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?(0,W.J)(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t,r=0){const{customFetchParameters:s}=this.ioConfig,{range:i,query:n,headers:o}=t;r=r??t.retryCount??this.ioConfig.retryCount;const a=i?{Range:`bytes=${i.from}-${i.to}`}:null;try{return await(0,b.default)(e,{...t,query:{...n,...s},headers:{...o,...a}})}catch(s){if(r>0)return r--,this.request(e,t,r);throw s}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return(0,a.Wi)(t)||(0,a.Wi)(e)||0===e.length?null:(0,E.gk)(e,t)}getTileExtentFromTileInfo(e,t,r,s){const i=(0,a.s3)(s.lodAt(e));return this.getTileExtent({x:i.resolution,y:i.resolution},t,r,s.origin,s.spatialReference,s.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:r,pixelSize:s}=this.rasterInfo;if(!e.tileInfo){const i=[],n=e.maximumPyramidLevel||0;let o=Math.max(s.x,s.y),a=1/.0254*96*o;for(let e=0;e<=n;e++)i.push({level:n-e,resolution:o,scale:a}),o*=2,a*=2;const l=new Z.Z({x:r.xmin,y:r.ymax,spatialReference:t});e.tileInfo=new P.Z({origin:l,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:i}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e,t=512,r=512,s){const{width:i,height:n,nativeExtent:o,pixelSize:a,spatialReference:l}=e,c=new Z.Z({x:o.xmin,y:o.ymax,spatialReference:l});null==s&&(s=Math.max(0,Math.round(Math.log(Math.max(i,n))/Math.LN2-8)));const u=this.computeBlockBoundary(o,512,512,{x:o.xmin,y:o.ymax},[a],s);e.storageInfo=new O.Z({blockWidth:t,blockHeight:r,pyramidBlockWidth:t,pyramidBlockHeight:r,origin:c,firstPyramidLevel:1,maximumPyramidLevel:s,blockBoundary:u})}async computeBestPyramidLevelForLocation(e,t={}){return 0}computeBlockBoundary(e,t,r,s,i,n=0,o=2){if(1===i.length&&n>0){i=[...i];let{x:e,y:t}=i[0];for(let r=0;r<n;r++)e*=o,t*=o,i.push({x:e,y:t})}const a=[],{x:l,y:c}=s;for(let s=0;s<i.length;s++){const{x:n,y:o}=i[s];a.push({minCol:Math.floor((e.xmin-l+.1*n)/t/n),maxCol:Math.floor((e.xmax-l-.1*n)/t/n),minRow:Math.floor((c-e.ymax+.1*o)/r/o),maxRow:Math.floor((c-e.ymin-.1*o)/r/o)})}return a}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:r,pyramidScalingFactor:s}=this.rasterInfo.storageInfo;if(0===e)return t;if((0,a.pC)(r)&&r.length)return r[e-1];const i=s**e;return{x:t.x*i,y:t.y*i}}identifyPixelLocation(e,t,r,s){const{spatialReference:i,nativeExtent:n,storageInfo:o}=this.rasterInfo,{maximumPyramidLevel:l,origin:c,transposeInfo:u}=o,h=s&&(0,a.pC)(u)?u.tileSize[0]:o.blockWidth,f=s&&(0,a.pC)(u)?u.tileSize[1]:o.blockHeight,d=(0,N.nF)(e,i,r);if(!n.intersects(d))return null;if(t<0||t>l)return null;const p=this.getPyramidPixelSize(t),{x:m,y:g}=p,y=(c.y-d.y)/g/f,x=(d.x-c.x)/m/h,w=Math.min(f-1,Math.floor((y-Math.floor(y))*f)),b=Math.min(h-1,Math.floor((x-Math.floor(x))*h));return{pyramidLevel:t,row:Math.floor(y),col:Math.floor(x),rowOffset:w,colOffset:b,blockWidth:h,srcLocation:d}}getTileExtent(e,t,r,s,i,n){const[o,a]=n,l=s.x+r*o*e.x,c=l+o*e.x,u=s.y-t*a*e.y,h=u-a*e.y;return new G.Z({xmin:l,xmax:c,ymin:h,ymax:u,spatialReference:i})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,r){const s=this.rasterInfo.storageInfo.blockBoundary[e];return!s||s.maxRow<t||s.maxCol<r||s.minRow>t||s.minCol>r}async _fetchPixels(e,t,r,s={}){let i=(0,N.Hq)(e);if(i>=2)return{extent:e,pixelBlock:null};const n=this._getSourceDataInfo(e,t,r,s),{pyramidLevel:o,pyramidResolution:l,srcResolution:c,srcExtent:u,srcWidth:h,srcHeight:f}=n;if(0===h||0===f)return{extent:e,srcExtent:u,pixelBlock:null};const d=(0,a.Wg)(this.rasterInfo.transform),p="gcs-shift"===d?.type,m=(0,a.pC)((0,N.ut)(e.spatialReference));!p&&m||(i=(0,N.Hq)(n.srcExtent,p));const g=this.rasterInfo.storageInfo,y={x:Math.floor((u.xmin-g.origin.x)/l.x+.1),y:Math.floor((g.origin.y-u.ymax)/l.y+.1)},x=await this._fetchRawTiles(o,y,{width:h,height:f,wrapCount:i},s);if(!x)return{extent:e,srcExtent:u,pixelBlock:null};const w=o>0?g.pyramidBlockWidth:g.blockWidth,b=o>0?g.pyramidBlockHeight:g.blockHeight,I=w===h&&b===f&&y.x%w==0&&y.y%b==0,_=new Z.Z({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference}),v=!e.spatialReference.equals(this.rasterInfo.spatialReference),{datumTransformation:S}=s;if(!v&&I&&1===x.pixelBlocks.length&&w===t&&b===r&&c.x===_.x&&c.y===_.y)return{extent:e,srcExtent:u,pixelBlock:x.pixelBlocks[0]};const C=m&&(0,a.pC)((0,N.ut)(u.spatialReference)),R=s.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");R&&!this.rasterJobHandler&&await(0,N.zD)();const k=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:_.toJSON(),datumTransformation:S,rasterTransform:d,hasWrapAround:i>0||C,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:R},s):(0,N.Qp)({projectedExtent:e,srcBufferExtent:x.extent,pixelSize:_,datumTransformation:S,rasterTransform:d,hasWrapAround:i>0||C,isAdaptive:!1,includeGCSGrid:R});let T;const P=!s.requestRawData,M={rows:k.spacing[0],cols:k.spacing[1]},F=(0,a.Wg)(this._getRasterTileAlignmentInfo(o,x.extent.xmin)),{pixelBlocks:O,mosaicSize:E,isPartiallyFilled:B}=x;let J=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:O,srcMosaicSize:E,destDimension:P?{width:t,height:r}:null,coefs:P?k.coefficients:null,sampleSpacing:P?M:null,projectDirections:R,gcsGrid:R?k.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:s.interpolation,alignmentInfo:F,blockWidths:null},s);({pixelBlock:T,localNorthDirections:J}=e)}else{const e=(0,j.us)(O,E,{alignmentInfo:F});T=P?(0,j.Uk)(e,{width:t,height:r},k.coefficients,M,s.interpolation):e,R&&k.gcsGrid&&(J=(0,j.Qh)({width:t,height:r},k.gcsGrid),T=(0,q.xQ)(T,this.rasterInfo.dataType,J))}return s.requestRawData||R?{srcExtent:u,pixelBlock:T,transformGrid:k,localNorthDirections:J,extent:e,isPartiallyFilled:B}:{srcExtent:u,extent:e,pixelBlock:T}}async _fetchRawTiles(e,t,r,s){const{origin:i,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:o,blockHeight:l}=this.getBlockWidthHeight(e);let{x:c,y:u}=t,{width:h,height:f,wrapCount:d}=r;const p=this._getRasterTileAlignmentInfo(e,0);s.buffer&&(c-=s.buffer.cols,u-=s.buffer.rows,h+=2*s.buffer.cols,f+=2*s.buffer.rows);let m=0,g=0,y=0;d&&(0,a.pC)(p)&&(({worldColumnCountFromOrigin:g,originColumnOffset:y,rightPadding:m}=p),g*p.blockWidth-m>=c+h&&(m=0));const x=Math.floor(c/o),w=Math.floor(u/l),b=Math.floor((c+h+m-1)/o),I=Math.floor((u+f+m-1)/l),_=n[e];if(!_)return null;const{minRow:v,minCol:S,maxCol:C,maxRow:R}=_;if(0===d&&(I<v||b<S||w>R||x>C))return null;const k=new Array;let T=!1;const P=null==this.ioConfig.allowPartialFill?s.allowPartialFill:this.ioConfig.allowPartialFill;for(let t=w;t<=I;t++)for(let r=x;r<=b;r++){let i=r;if(!s.disableWrapAround&&d&&(0,a.pC)(p)&&g<=r&&(i=r-g-y),t>=v&&i>=S&&R>=t&&C>=i){const r=this._fetchRawTile(e,t,i,s);P?k.push(new Promise((e=>{r.then((t=>e(t))).catch((()=>{T=!0,e(null)}))}))):k.push(r)}else k.push(Promise.resolve(null))}if(0===k.length)return null;const M=await Promise.all(k),F={height:(I-w+1)*l,width:(b-x+1)*o},{spatialReference:O}=this.rasterInfo,E=this.getPyramidPixelSize(e),{x:N,y:Z}=E;return{extent:new G.Z({xmin:i.x+x*o*N,xmax:i.x+(b+1)*o*N,ymin:i.y-(I+1)*l*Z,ymax:i.y-w*l*Z,spatialReference:O}),pixelBlocks:M,mosaicSize:F,isPartiallyFilled:T}}_fetchRawTile(e,t,r,s){const i=this.rasterInfo.storageInfo.blockBoundary[e];if(!i)return Promise.resolve(null);const{minRow:n,minCol:o,maxCol:l,maxRow:u}=i;if(t<n||r<o||t>u||r>l)return Promise.resolve(null);const h=D(this.url,s.sliceId),f=`${e}/${t}/${r}`;let d=L(h,s.registryId,f);if((0,a.Wi)(d)){const i=new AbortController;d=this.fetchRawTile(e,t,r,{...s,signal:i.signal}),z(h,s.registryId,f,d,i),d.catch((()=>H(h,s.registryId,f)))}return s.signal&&(0,c.fu)(s,(()=>{A(h,s.registryId,f)})),d}_computeMagDirValues(e){const{bandCount:t,dataType:r}=this.rasterInfo;if((2!==t||"vector-magdir"!==r)&&"vector-uv"!==r||2!==e?.length||!e[0]?.length)return null;const s=e[0].length;if("vector-magdir"===r){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[i,n]=e,o=[],a=[];for(let e=0;e<s;e++){const[t,r]=(0,q.Tg)([i[e],n[e]]);o.push(t),a.push(r)}return[o,a]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlighmentInfo&&(this._rasterTileAlighmentInfo=(0,N.P_)(this.rasterInfo)),(0,a.Wi)(this._rasterTileAlighmentInfo.pyramidsInfo)?null:{startX:t,halfWorldWidth:this._rasterTileAlighmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlighmentInfo.hasGCSSShiftTransform,...this._rasterTileAlighmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,r,s={}){const i={datumTransformation:s.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0};s.srcResolution&&(i.srcResolution=s.srcResolution,this._updateSourceDataInfo(e,i));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:o,srcHeight:a,pyramidLevel:l}=i,c=o/t,u=a/r,h=l<n&&c*u>=16;if(h||l===n&&(c>8||u>8)||0===o||0===a){const o=new Z.Z({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/r,spatialReference:e.spatialReference});let a=(0,N.VO)(o,this.rasterInfo.spatialReference,e,i.datumTransformation);const f=!a||s.srcResolution&&a.x+a.y<s.srcResolution.x+s.srcResolution.y;if(h&&s.srcResolution&&f){const e=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-l+3>=e){const t=2**e;a={x:s.srcResolution.x*t,y:s.srcResolution.y*t}}}a&&(i.srcResolution=a,this._updateSourceDataInfo(e,i))}return(i.srcWidth/t>8||i.srcHeight/r>8)&&(i.srcWidth=0,i.srcHeight=0),i}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const r=this.rasterInfo.spatialReference,{srcResolution:s,datumTransformation:i}=t,{pyramidLevel:n,pyramidResolution:o,excessiveReading:l}=(0,N.kr)(s,this.rasterInfo,this.ioConfig.sampling);if(l)return;let c=t.srcExtent||(0,N.tB)(e,r,i);if(null==c)return;const u=(0,a.Wg)(this.rasterInfo.transform);u&&(c=u.inverseTransform(c)),t.srcExtent=c;const h=Math.ceil((c.xmax-c.xmin)/o.x-.1),f=Math.ceil((c.ymax-c.ymin)/o.y-.1);t.pyramidLevel=n,t.pyramidResolution=o,t.srcWidth=h,t.srcHeight=f}_getRequestOptionsWithSliceId(e){return(0,a.pC)(this.rasterInfo.multidimensionalInfo)&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:r,position:s,pyramidLevel:i,useTransposedTile:n}=t,o=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[s])return{location:r,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if((0,a.Wi)(l)||!n){const t=e.pixels.map((e=>e[s])),n={location:r,value:t,pyramidLevel:i},o=this._computeMagDirValues(t.map((e=>[e])));return o?.length&&(n.magdirValue=o.map((e=>e[0]))),n}let c=e.pixels.map((e=>Array.prototype.slice.call(e,s*o,s*o+o))),u=this._computeMagDirValues(c);const{requestSomeSlices:h,identifyOptions:f}=t;let d=(0,E.MO)(l,f.transposedVariableName);if(h){const e=(0,E.Ur)(d,(0,a.Wg)(f.multidimensionalDefinition),(0,a.Wg)(f.timeExtent));c=c.map((t=>e.map((e=>t[e])))),u=u?.map((t=>e.map((e=>t[e])))),d=e.map((e=>d[e]))}return{location:r,value:null,dataSeries:d.map(((e,t)=>{const r={value:c.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition};return u?.length&&(r.magdirValue=[u[0][t],u[1][t]]),r})),pyramidLevel:i}}};(0,s._)([(0,h.Cb)()],U.prototype,"_rasterTileAlighmentInfo",void 0),(0,s._)([(0,h.Cb)({readOnly:!0})],U.prototype,"_isGlobalWrappableSource",null),(0,s._)([(0,h.Cb)(S.HQ)],U.prototype,"url",null),(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],U.prototype,"datasetName",void 0),(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],U.prototype,"datasetFormat",void 0),(0,s._)([(0,h.Cb)()],U.prototype,"rasterInfo",void 0),(0,s._)([(0,h.Cb)()],U.prototype,"ioConfig",void 0),(0,s._)([(0,h.Cb)()],U.prototype,"sourceJSON",void 0),U=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.BaseRaster")],U);const $=U;let V=class extends ${constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._primaryRasters=null}async open(e){await this.init();const{rasterFunction:t}=this,{rasters:r,rasterIds:s}=t.getPrimaryRasters(),i=r.map((t=>t.rasterInfo?void 0:t.open(e)));await Promise.all(i);const n=r.map((({rasterInfo:e})=>e)),a=t.bind({rasterInfos:n,rasterIds:s});if(!a.success)throw new o.Z("raster-function:open",`cannot bind the function: ${a.error??""}`);await this.syncJobHandler(),this.set("sourceJSON",r[0].sourceJSON),this.set("rasterInfo",t.rasterInfo)}async syncJobHandler(){const{rasterFunction:e}=this;if(this._primaryRasters=e.getPrimaryRasters(),this.rasterJobHandler)return this.rasterJobHandler.updateRasterFunction(e)}async fetchPixels(e,t,r,s={}){const{rasters:i,rasterIds:n}=this._primaryRasters,o=i.map((i=>i.fetchPixels(e,t,r,s))),l=await Promise.all(o),c=l.map((e=>e.pixelBlock));if(c.every((e=>(0,a.Wi)(e))))return l[0];const u=l.find((e=>(0,a.pC)(e.pixelBlock)))?.extent??e,h=this.rasterJobHandler?await this.rasterJobHandler.process({extent:u,primaryPixelBlocks:c,primaryRasterIds:n}):this.rasterFunction.process({extent:u,primaryPixelBlocks:c,primaryRasterIds:n});return{...l[0],pixelBlock:h}}};(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),(0,s._)([(0,h.Cb)()],V.prototype,"tileType",void 0),(0,s._)([(0,h.Cb)()],V.prototype,"rasterFunction",void 0),V=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.FunctionRaster")],V);const X=V;var Q=r(55444),Y=r(67058),K=r(72758),ee=r(23808),te=r(82971);const re=I.Z.getLogger("esri.layers.mixins.ImageryTileMixin"),se=e=>{let t=class extends e{constructor(){super(...arguments),this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation="nearest",this.multidimensionalDefinition=null,this.multidimensionalSubset=null,this.raster=null,this.rasterFunction=null,this.sourceJSON=null,this.symbolizer=null}get fullExtent(){return this.rasterInfo?.extent}get rasterInfo(){return this.raster?.rasterInfo}get spatialReference(){return this.rasterInfo?.spatialReference??te.Z.WGS84}get tileInfo(){return this.rasterInfo?.storageInfo.tileInfo}set url(e){this._set("url",(0,v.Nm)(e,re))}set renderer(e){this._set("renderer",e),this.updateRenderer()}async convertVectorFieldData(e,t){if((0,a.Wi)(e)||!this.rasterInfo)return null;const r=this._rasterJobHandler.instance,s=this.rasterInfo.dataType;return r?r.convertVectorFieldData({pixelBlock:e,dataType:s},t):(0,q.KC)(e,s)}async createFlowMesh(e,t){const r=this._rasterJobHandler.instance;return r?r.createFlowMesh(e,t):(0,ee.GE)(e.meshType,e.simulationSettings,e.flowData,(0,a.pC)(t.signal)?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.rasterInfo??{};if((0,a.Wi)(t))return e;let r=e.multidimensionalDefinition||this.multidimensionalDefinition;if((0,a.Wi)(r)||!r.length)r=(0,E.Tj)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset});else if((0,E.nb)(r,this.multidimensionalSubset))return{...e,multidimensionalDefinition:null};const s=e.timeExtent||this.timeExtent;if((0,a.pC)(r)&&(0,a.pC)(s)&&((0,a.pC)(s.start)||(0,a.pC)(s.end))){r=r.map((e=>e.clone()));const i=t.variables.find((({name:e})=>e===r[0].variableName))?.dimensions?.find((({name:e})=>"StdTime"===e)),n=r.find((({dimensionName:e})=>"StdTime"===e));if(!i||!n)return{...e,multidimensionalDefinition:null};const{start:o,end:l}=s,c=(0,a.Wi)(o)?null:o.getTime(),u=(0,a.Wi)(l)?null:l.getTime(),h=c??u,f=u??c;if((0,a.pC)(i.values)){const e=i.values.filter((e=>{if(Array.isArray(e)){if(h===f)return e[0]<=h&&e[1]>=h;const t=e[0]<=h&&e[1]>h||e[0]<f&&e[1]>=f,r=e[0]>=h&&e[1]<=f||e[0]<h&&e[1]>f;return t||r}return h===f?e===h:e>=h&&e<=f}));if(e.length){const t=e.sort(((e,t)=>h===f?(e[0]??e)-(t[0]??t):Math.abs((e[1]??e)-f)-Math.abs((t[1]??t)-f)))[0];n.values=[t]}else r=null}else if(i.hasRegularIntervals&&i.extent){const[e,t]=i.extent;h>t||f<e?r=null:n.values=h===f?[h]:[Math.max(e,h),Math.min(t,f)]}}return{...e,multidimensionalDefinition:r}}async updateRenderer(){const{loaded:e,symbolizer:t}=this;if(!e||!t)return;if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(this.renderer))return;const r=this._rasterJobHandler.instance;r&&(t.rendererJSON=(0,Y.ol)(this.renderer.toJSON()),t.bind(),await r.updateSymbolizer(t),this._cachedRendererJson=this.renderer.toJSON())}async applyRenderer(e,t){const r=e&&e.pixelBlock;if(!((0,a.pC)(r)&&r.pixels&&r.pixels.length>0))return null;let s;await this.updateRenderer();const i=this._rasterJobHandler.instance,n=this.bandIds??[];return s=i?await i.symbolize({...e,simpleStretchParams:t,bandIds:n}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:n}),s}getTileUrl(e,t,r){return"RasterTileServer"===this.raster?.datasetFormat?`${this.url}/tile/${e}/${t}/${r}`:""}getCompatibleTileInfo(e,t,r=!1){if(!this.loaded||(0,a.Wi)(t))return null;if(r&&e.equals(this.spatialReference))return this.tileInfo;const s=(0,_.C5)(e);return P.Z.create({size:256,spatialReference:e,origin:s?{x:s.origin[0],y:s.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent&&this._compatibleFullExtent.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,s,i={}){if(r(this),i.requestAsImageElement){const r=this.getTileUrl(e,t,s);return(0,b.default)(r,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:i.signal}).then((e=>e.data))}if((0,a.pC)(this.rasterInfo.multidimensionalInfo)&&(i=this.normalizeRasterFetchOptions(i),(0,a.Wi)(i.multidimensionalDefinition))){const r=i.tileInfo||this.rasterInfo.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,s,r),pixelBlock:null}}return await this._initJobHandler(),await this._updateRasterFunction(),"raster-shaded-relief"===this.renderer.type&&(i={...i,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,s,i)}async fetchPixels(e,t,r,s={}){return(0,a.pC)(this.rasterInfo.multidimensionalInfo)&&(s=this.normalizeRasterFetchOptions(s),(0,a.Wi)(s.multidimensionalDefinition))?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this._updateRasterFunction(),this.raster.fetchPixels(e,t,r,s))}async identify(e,t={}){return r(this),!(0,a.pC)(this.rasterInfo.multidimensionalInfo)||this.rasterInfo.hasMultidimensionalTranspose&&((0,E.WU)(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent)||(t=this.normalizeRasterFetchOptions(t),!(0,a.Wi)(t.multidimensionalDefinition))?this.raster.identify(e,t):{location:e,value:null}}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.rasterInfo?.multidimensionalInfo;if((0,a.Wi)(e)||"standard-time"!==this.rasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,r=t?.[0]?.variableName;return e.variables.some((e=>e.name===r&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date(24*(e-25569)*3600*1e3).toString()}getMultidimensionalSubsetVariables(e){const t=e??this.rasterInfo.multidimensionalInfo;return(0,E.jj)(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,E.Tj)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new T.Z;return this._rasterJobHandler.connectionPromise=e.initialize().then((()=>{r(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,this.renderer&&this.updateRenderer(),"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){r(this);const e=(0,Y.In)(this.rasterInfo,this.raster.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",e)}}_configDefaultRenderer(){r(this);const e=this.raster.rasterInfo;if(this.bandIds||(this.bandIds=(0,Y.YD)(e)),!this.renderer){const t=(0,Y.Ob)(e,{bandIds:this.bandIds,variableName:(0,a.pC)(this.multidimensionalDefinition)?this.multidimensionalDefinition[0]?.variableName:null});"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===t.type&&((e.statistics?.[0].max??0)>1e24||(e.statistics?.[0].min??0)<-1e24)&&(t.dynamicRangeAdjustment=!0,t.statistics=null,"none"===t.stretchType&&(t.stretchType="min-max")),this.renderer=t}this.symbolizer?(this.symbolizer.rendererJSON=(0,Y.ol)(this.renderer.toJSON()),this.symbolizer.rasterInfo=e):this.symbolizer=new K.Z({rendererJSON:this.renderer.toJSON(),rasterInfo:e});const t=this.symbolizer.bind();t.success||re.warn("imagery-tile-mixin",t.error||"The given renderer is not supported by the layer.")}async _updateRasterFunction(){if("imagery-tile"!==this.type||JSON.stringify(this.rasterFunction)===JSON.stringify(this._cachedRasterFunctionJson))return;let e=this.raster;if("Function"===e?.datasetFormat){const t=e.rasterFunction.getPrimaryRasters();e=t.rasters[0]}const{rasterFunction:t}=this;if(t){const r=(0,Q.Ue)(t.toJSON(),{raster:e}),s=new X({rasterFunction:r});s.rasterJobHandler=this._rasterJobHandler.instance,await s.open(),this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this.raster=s}else this.raster=e}};function r(e){if(!e.raster||!e.rasterInfo)throw new o.Z("imagery-tile","no raster")}return(0,s._)([(0,h.Cb)()],t.prototype,"_cachedRendererJson",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"_cachedRasterFunctionJson",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"_compatibleFullExtent",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"_rasterJobHandler",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"bandIds",void 0),(0,s._)([(0,h.Cb)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),(0,s._)([(0,h.Cb)({json:{read:!1}})],t.prototype,"fullExtent",null),(0,s._)([(0,h.Cb)()],t.prototype,"interpolation",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"ioConfig",void 0),(0,s._)([(0,h.Cb)({type:[C.Z]})],t.prototype,"multidimensionalDefinition",void 0),(0,s._)([(0,h.Cb)({type:R.Z,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"raster",void 0),(0,s._)([(0,h.Cb)({type:k.Z})],t.prototype,"rasterFunction",void 0),(0,s._)([(0,h.Cb)()],t.prototype,"rasterInfo",null),(0,s._)([(0,h.Cb)()],t.prototype,"sourceJSON",void 0),(0,s._)([(0,h.Cb)({json:{read:!1}})],t.prototype,"spatialReference",null),(0,s._)([(0,h.Cb)({json:{read:!1}})],t.prototype,"tileInfo",null),(0,s._)([(0,h.Cb)(S.HQ)],t.prototype,"url",null),(0,s._)([(0,h.Cb)({types:n.dr})],t.prototype,"renderer",null),(0,s._)([(0,h.Cb)()],t.prototype,"symbolizer",void 0),t=(0,s._)([(0,g.j)("esri.layers.ImageryTileMixin")],t),t};var ie=r(38009),ne=r(16859),oe=r(34760),ae=r(72965),le=r(28294),ce=r(1231),ue=r(69608),he=r(48526),fe=r(20095);function de(e){const t=e.fields,r=e.records,s=t.some((e=>"oid"===e.name.toLowerCase()))?"OBJECTID":"OID",i=[{name:s,type:"esriFieldTypeOID",alias:"OID"}].concat(t.map((e=>({name:e.name,type:"esriFieldType"+e.typeName,alias:e.name})))),n=i.map((e=>e.name)),o=[];let a=0,l=0;return r.forEach((e=>{const t={};for(t[s]=a++,l=1;l<n.length;l++)t[n[l]]=e[l-1];o.push({attributes:t})})),{displayFieldName:"",fields:i,features:o}}class pe{static get supportedVersions(){return[5]}static parse(e){const t=new DataView(e),r=3&t.getUint8(0);if(3!==r)return{header:{version:r},recordSet:null};const s=t.getUint32(4,!0),i=t.getUint16(8,!0),n=t.getUint16(10,!0),o={version:r,recordCount:s,headerByteCount:i,recordByteCount:n};let a=32;const l=[],c=[];let u;if(3===r){for(;13!==t.getUint8(a);)u=String.fromCharCode(t.getUint8(a+11)).trim(),l.push({name:(0,fe.f)(new Uint8Array(e,a,11)),type:u,typeName:["String","Date","Double","Boolean","String","Integer"][["C","D","F","L","M","N"].indexOf(u)],length:t.getUint8(a+16)}),a+=32;if(a+=1,l.length>0)for(;c.length<s&&e.byteLength-a>n;){const r=[];32===t.getUint8(a)?(a+=1,l.forEach((t=>{if("C"===t.type)r.push((0,fe.f)(new Uint8Array(e,a,t.length)).trim());else if("N"===t.type)r.push(parseInt(String.fromCharCode.apply(null,new Uint8Array(e,a,t.length)).trim(),10));else if("F"===t.type)r.push(parseFloat(String.fromCharCode.apply(null,new Uint8Array(e,a,t.length)).trim()));else if("D"===t.type){const s=String.fromCharCode.apply(null,new Uint8Array(e,a,t.length)).trim();r.push(new Date(parseInt(s.substring(0,4),10),parseInt(s.substring(4,6),10)-1,parseInt(s.substring(6,8),10)))}a+=t.length})),c.push(r)):a+=n}}return{header:o,fields:l,records:c,recordSet:de({fields:l,records:c})}}}var me=r(87521),ge=r(74889);const ye=new Map;ye.set("int16","esriFieldTypeSmallInteger"),ye.set("int32","esriFieldTypeInteger"),ye.set("int64","esriFieldTypeInteger"),ye.set("float32","esriFieldTypeSingle"),ye.set("float64","esriFieldTypeDouble"),ye.set("text","esriFieldTypeString");let xe=class extends ${constructor(){super(...arguments),this.storageInfo=null,this.datasetFormat="CRF"}async open(e){await this.init();const{data:t}=await this.request(this.url+"/conf.json",{signal:e?.signal});if(!this._validateHeader(t))throw new o.Z("cloudraster:open","Invalid or unsupported conf.json.");this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{storageInfo:r,rasterInfo:s}=this._parseHeader(t);if("thematic"===s.dataType){const e=await this._fetchAuxiliaryInformation();s.attributeTable=e}this._set("storageInfo",r),this._set("rasterInfo",s),this.ioConfig.retryCount=this.ioConfig.retryCount||0}async fetchRawTile(e,t,r,s={}){const{transposeInfo:i}=this.rasterInfo.storageInfo,{transposedVariableName:n}=s,o=!(!i||!n),a=o?0:this.rasterInfo.storageInfo.maximumPyramidLevel-e;if(a<0)return null;const l=this._buildCacheFilePath(a,t,r,s.multidimensionalDefinition,n),c=this._getIndexRecordFromBundle(t,r,o),u=await this.request(l,{range:{from:0,to:this.storageInfo.headerSize-1},responseType:"array-buffer",signal:s.signal});if(!u)return null;const h=new Uint8Array(u.data),f=this._getTileEndAndContentType(h,c);if(0===f.recordSize)return null;const d=await this.request(l,{range:{from:f.position,to:f.position+f.recordSize},responseType:"array-buffer",signal:s.signal});if(!d)return null;const[p,m]=this._getTileSize(o);return this.decodePixelBlock(d.data,{width:p,height:m,planes:null,pixelType:null,returnInterleaved:o})}_validateHeader(e){return e&&"RasterInfo"===e.type&&!["origin","extent","geodataXform","LODInfos","blockWidth","blockHeight","bandCount","pixelType","pixelSizeX","pixelSizeY","format","packetSize"].some((t=>!e[t]))}_parseHeader(e){const t=["u1","u2","u4","u8","s8","u16","s16","u32","s32","f32","f64"][e.pixelType],{bandCount:r,histograms:s,colormap:i,blockWidth:n,blockHeight:o,firstPyramidLevel:a,maximumPyramidLevel:l}=e,c=e.statistics&&e.statistics.map((e=>({min:e.min,max:e.max,avg:e.mean,stddev:e.standardDeviation,median:e.median,mode:e.mode}))),u=e.extent.spatialReference,h=e.geodataXform?.spatialReference,f=new te.Z(u?.wkid||u?.wkt?u:h);let d=new G.Z({xmin:e.extent.xmin,ymin:e.extent.ymin,xmax:e.extent.xmax,ymax:e.extent.ymax,spatialReference:f});const p=new Z.Z({x:e.pixelSizeX,y:e.pixelSizeY,spatialReference:f}),m=Math.round((d.xmax-d.xmin)/p.x),g=Math.round((d.ymax-d.ymin)/p.y),y=this._parseTransform(e.geodataXform),x=y?d:null;y&&(d=y.forwardTransform(d),p.x=(d.xmax-d.xmin)/m,p.y=(d.ymax-d.ymin)/g);const w=e.properties??{},b=e.format.toLowerCase().replace("cache/",""),I=new Z.Z(e.origin.x,e.origin.y,f);let _,v,S,C;if(i&&i.colors)for(_=[],v=0;v<i.colors.length;v++)S=i.colors[v],C=i.values?i.values[v]:v,_.push([C,255&S,S<<16>>>24,S<<8>>>24,S>>>24]);const R=e.LODInfos,k=[];for(v=0;v<R.levels.length;v++)k.push({level:R.levels[v],resolution:R.resolutions[v],scale:96/.0254*R.resolutions[v]});const T=new P.Z({dpi:96,lods:k,format:b,origin:I,size:[n,o],spatialReference:f}),M={recordSize:8,packetSize:e.packetSize,headerSize:e.packetSize*e.packetSize*8+64},F=[{maxCol:Math.ceil(m/n)-1,maxRow:Math.ceil(g/o)-1,minCol:0,minRow:0}];let E=2;if(l>0)for(v=0;v<l;v++)F.push({maxCol:Math.ceil(m/E/n)-1,maxRow:Math.ceil(g/E/o)-1,minCol:0,minRow:0}),E*=2;const N=e.mdInfo;let B=null;if(N&&w._yxs){const e=w._yxs;B={packetSize:e.PacketSize,tileSize:[e.TileXSize,e.TileYSize]}}return{storageInfo:M,rasterInfo:new he.Z({width:m,height:g,pixelType:t,bandCount:r,extent:d,nativeExtent:x,transform:y,spatialReference:f,pixelSize:p,keyProperties:w,statistics:c,histograms:s,multidimensionalInfo:N,colormap:_,storageInfo:new O.Z({blockWidth:n,blockHeight:o,pyramidBlockWidth:n,pyramidBlockHeight:o,origin:I,tileInfo:T,transposeInfo:B,firstPyramidLevel:a,maximumPyramidLevel:l,blockBoundary:F})})}}_parseTransform(e){if(!(0,me.j)(e))throw new o.Z("cloudraster:open","the data contains unsupported geodata transform types");const t=(0,me.c)(e);if("identity"===t.type)return null;if("polynomial"!==t.type||!t.forwardCoefficients?.length||!t.inverseCoefficients?.length)throw new o.Z("cloudraster:open","the data contains unsupported geodata transforms - both forward and inverse coefficients are required currently");return t}async _fetchAuxiliaryInformation(e){const t=this.request(this.url+"/conf.vat.json",{signal:e}).then((e=>e.data)).catch((()=>null)),r=this.request(this.url+"/conf.vat.dbf",{responseType:"array-buffer",signal:e}).then((e=>e.data)).catch((()=>null)),s=await Promise.all([t,r]);let i;if(s[0]){let e=s[0].fields;const t=s[0].values;if(e&&t){e=e.map((e=>({type:"OID"===e.name?"esriFieldTypeOID":ye.get(e.type),name:e.name,alias:e.alias||e.name})));const r=t.map((e=>({attributes:e})));e&&t&&(i={fields:e,features:r})}}return!i&&s[1]&&(i=pe.parse(s[1]).recordSet),ge.default.fromJSON(i)}_buildCacheFilePath(e,t,r,s,i){const n=this._getPackageSize(!!i),o=Math.floor(t/n)*n,l=Math.floor(r/n)*n,c="R"+this._toHexString4(o)+"C"+this._toHexString4(l);let u="L";u+=e>=10?e.toString():"0"+e.toString();const{multidimensionalInfo:h}=this.rasterInfo,f=s?.[0];if((0,a.Wi)(h)||!f)return`${this.url}/_alllayers/${u}/${c}.bundle`;let d="_yxs";if(!i){d=h.variables.find((e=>e.name===f.variableName)).dimensions[0].values.indexOf(f.values[0]).toString(16);const e=4-d.length;for(let t=0;t<e;t++)d="0"+d;d="S"+d}const p=this._getVariableFolderName(i||f.variableName);return`${this.url}/_alllayers/${p}/${d}/${u}/${c}.bundle`}_getPackageSize(e=!1){const{transposeInfo:t}=this.rasterInfo.storageInfo;return e&&(0,a.pC)(t)?t.packetSize??0:this.storageInfo.packetSize}_getTileSize(e=!1){const{storageInfo:t}=this.rasterInfo,{transposeInfo:r}=t;return e&&(0,a.pC)(r)?r.tileSize:t.tileInfo.size}_getVariableFolderName(e){return""===(e=e.trim())?"_v":e.replace(/[\{|\}\-]/g,"_").replace("\\*","_v")}_getIndexRecordFromBundle(e,t,r=!1){const s=this._getPackageSize(r),i=s*(e%s)+t%s;if(i<0)throw"Invalid level / row / col";return 20+i*this.storageInfo.recordSize+44}_getTileEndAndContentType(e,t){const r=e.subarray(t,t+8);let s,i=0;for(s=0;s<5;s++)i|=(255&r[s])<<8*s;const n=0xffffffffff&i;for(i=0,s=5;s<8;s++)i|=(255&r[s])<<8*(s-5);return{position:n,recordSize:0xffffffffff&i}}_toHexString4(e){let t=e.toString(16);if(4!==t.length){let e=4-t.length;for(;e-- >0;)t="0"+t}return t}};(0,s._)([(0,h.Cb)({readOnly:!0})],xe.prototype,"storageInfo",void 0),(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],xe.prototype,"datasetFormat",void 0),xe=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.CloudRaster")],xe);const we=xe;var be=r(15612);let Ie=class extends ${constructor(){super(...arguments),this.datasetFormat="MEMORY",this.data=null}async open(e){await this.init();const t=this.data,{pixelBlock:r,statistics:s,histograms:i,name:n,keyProperties:o,nativeExtent:a,transform:l}=this.data,{width:c,height:u,pixelType:h}=r,f=t.extent??new G.Z({xmin:-.5,ymin:.5,xmax:c-.5,ymax:u-.5,spatialReference:new te.Z({wkid:3857})}),d=t.isPseudoSpatialReference??!t.extent,p={x:f.width/c,y:f.height/u},m=new he.Z({width:c,height:u,pixelType:h,extent:f,nativeExtent:a,transform:l,pixelSize:p,spatialReference:f.spatialReference,bandCount:3,keyProperties:o||{},statistics:s,isPseudoSpatialReference:d,histograms:i});this.createRemoteDatasetStorageInfo(m,512,512),this._set("rasterInfo",m),this.updateTileInfo(),await this._buildInMemoryRaster(r,{width:512,height:512},e),this.datasetName=n,this.url="/InMemory/"+n}fetchRawTile(e,t,r,s={}){const i=this._pixelBlockTiles.get(`${e}/${t}/${r}`);return Promise.resolve(i)}async _buildInMemoryRaster(e,t,r){const s=this.rasterInfo.storageInfo.maximumPyramidLevel,i=this.rasterJobHandler?this.rasterJobHandler.split({pixelBlock:e,tileSize:t,maximumPyramidLevel:s},r):Promise.resolve((0,j.Vl)(e,t,s)),n=(0,a.pC)(this.rasterInfo.statistics),l=(0,a.pC)(this.rasterInfo.histograms),u=n?Promise.resolve({statistics:null,histograms:null}):this.rasterJobHandler?this.rasterJobHandler.estimateStatisticsHistograms({pixelBlock:e},r):Promise.resolve((0,be.Hv)(e)),h=await(0,c.as)([i,u]);if(!h[0].value&&h[1].value)throw new o.Z("inmemory-raster:open","failed to build in memory raster");this._pixelBlockTiles=h[0].value,n||(this.rasterInfo.statistics=h[1].value?.statistics),l||(this.rasterInfo.histograms=h[1].value?.histograms)}};(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],Ie.prototype,"datasetFormat",void 0),(0,s._)([(0,h.Cb)()],Ie.prototype,"data",void 0),Ie=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.InMemoryRaster")],Ie);const _e=Ie;function ve(e,t){if(!e||!t)return[];let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=[];if(t){const i=ve(e,r);for(let e=0;e<i.length;e++)ve(i[e],t).forEach((e=>s.push(e)));return s}const i=e.getElementsByTagNameNS("*",r);if(!i||0===i.length)return[];for(let e=0;e<i.length;e++)s.push(i[e]||i.item[e]);return s}function Se(e,t){if(!e||!t)return null;let r=t;t.includes("/")?(r=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=ve(e,r);return s.length>0?t?Se(s[0],t):s[0]:null}function Ce(e,t=null){const r=t?Se(e,t):e;let s;return r?(s=r.textContent||r.nodeValue,s?s.trim():null):null}function Re(e,t){return function(e,t){const r=ve(e,t),s=[];let i;for(let e=0;e<r.length;e++)i=r[e].textContent||r[e].nodeValue,i&&(i=i.trim(),""!==i&&s.push(i));return s}(e,t).map((e=>Number(e)))}function ke(e,t){const r=Ce(e,t);return Number(r)}function Te(e,t){const r=e?.nodeName?.toLowerCase(),s=t.toLowerCase();return r.slice(r.lastIndexOf(":")+1)===s}var Pe=r(87390);function Me(e,t){if(!e||!t)return null;const r=[];for(let s=0;s<e.length;s++)r.push(e[s]),r.push(t[s]);return r}function Fe(e){if(!e)return null;let t=Number(e);if(!isNaN(t)&&0!==t)return new te.Z({wkid:t});if((e=String(e)).startsWith("COMPD_CS")){if(!e.includes("VERTCS")||!e.includes("GEOGCS")&&!e.startsWith("PROJCS"))return null;const r=e.indexOf("VERTCS"),s=e.indexOf("PROJCS"),i=s>-1?s:e.indexOf("GEOGCS");if(-1===i)return null;const n=e.slice(i,e.lastIndexOf("]",r)+1).trim(),o=e.slice(r,e.lastIndexOf("]")).trim();t=Oe(n);const a=new te.Z(t?{wkid:t}:{wkt:n}),l=Oe(o);return l&&(a.vcsWkid=l),a}return e.startsWith("GEOGCS")||e.startsWith("PROJCS")?(t=Oe(e),new te.Z(0!==t?{wkid:t}:{wkt:e})):null}function Oe(e){const t=e.replace(/\]/g,"[").replace(/\"/g,"").split("[").map((e=>e.trim())).filter((e=>""!==e)),r=t[t.length-1].split(","),s=r[0]?.toLowerCase();if(("epsg"===s||"esri"===s)&&e.endsWith('"]]')){const e=Number(r[1]);if(!isNaN(e)&&0!==e)return e}return 0}function Ee(e){if("pamdataset"!==e?.documentElement.tagName?.toLowerCase())return{};const t={spatialReference:null,transform:null,metadata:{},rasterBands:[],statistics:null,histograms:null};e.documentElement.childNodes.forEach((e=>{if(1===e.nodeType)if(Te(e,"SRS")){if(!t.spatialReference){const r=Ce(e);t.spatialReference=Fe(r)}}else if(Te(e,"Metadata"))if("xml:ESRI"===e.getAttribute("domain")){const{spatialReference:r,transform:s}=function(e){const t=Se(e,"GeodataXform"),r=Fe(ke(t,"SpatialReference/WKID")||Ce(t,"SpatialReference/WKT"));if("typens:PolynomialXform"!==t.getAttribute("xsi:type"))return{spatialReference:r,transform:null};const s=ke(t,"PolynomialOrder")??1,i=Re(t,"CoeffX/Double"),n=Re(t,"CoeffY/Double"),o=Re(t,"InverseCoeffX/Double"),a=Re(t,"InverseCoeffY/Double"),l=Me(i,n),c=Me(o,a);return{spatialReference:r,transform:l&&c&&l.length&&c.length?new Pe.Z({spatialReference:r,polynomialOrder:s,forwardCoefficients:l,inverseCoefficients:c}):null}}(e);t.transform=s,t.spatialReference||(t.spatialReference=r)}else ve(e,"MDI").forEach((e=>t.metadata[e.getAttribute("key")]=Ce(e)));else if(Te(e,"PAMRasterBand")){const r=function(e){const t=ke(e,"NoDataValue"),r=Se(e,"Histograms/HistItem"),s=ke(r,"HistMin"),i=ke(r,"HistMax"),n=ke(r,"BucketCount"),o=Ce(r,"HistCounts")?.split("|").map((e=>Number(e)));let a,l,c,u;ve(e,"Metadata/MDI").forEach((e=>{const t=Number(e.textContent??e.nodeValue);switch(e.getAttribute("key").toUpperCase()){case"STATISTICS_MINIMUM":a=t;break;case"STATISTICS_MAXIMUM":l=t;break;case"STATISTICS_MEAN":c=t;break;case"STATISTICS_STDDEV":u=t}}));const h=ke(e,"Metadata/SourceBandIndex");return{noDataValue:t,histogram:o?.length&&null!=s&&null!=i?{min:s,max:i,size:n||o.length,counts:o}:null,sourceBandIndex:h,statistics:null!=a&&null!=l?{min:a,max:l,avg:c,stddev:u}:null}}(e);null!=r.sourceBandIndex&&null==t.rasterBands[r.sourceBandIndex]?t.rasterBands[r.sourceBandIndex]=r:t.rasterBands.push(r)}}));const r=t.rasterBands;if(r.length){const e=!!r[0].statistics;t.statistics=e?r.map((e=>e.statistics)).filter(a.pC):null;const s=!!r[0].histogram;t.histograms=s?r.map((e=>e.histogram)).filter(a.pC):null}return t}let Ne=class extends ${async open(e){await this.init();const t=await this._fetchData(e);let{spatialReference:r,statistics:s,histograms:i,transform:n}=await this._fetchAuxiliaryData(e);const o=!r;o&&(r=new te.Z({wkid:3857})),i?.length&&null==s&&(s=(0,be.Oh)(i));const{width:a,height:l}=t;let c=new G.Z({xmin:-.5,ymin:.5-l,xmax:a-.5,ymax:.5,spatialReference:r});const u=n?n.forwardTransform(c):c;let h=!0;if(n){const e=n.forwardCoefficients;h=e&&0===e[1]&&0===e[2],h&&(n=null,c=u)}const f=new _e({data:{extent:u,nativeExtent:c,transform:n,pixelBlock:t,statistics:s,histograms:i,keyProperties:{DateType:"Processed"},isPseudoSpatialReference:o}});await f.open(),f.data=null,this._set("rasterInfo",f.rasterInfo),this._inMemoryRaster=f}fetchRawTile(e,t,r,s={}){return this._inMemoryRaster.fetchRawTile(e,t,r,s)}async _fetchData(e){const{data:t}=await this.request(this.url,{responseType:"array-buffer",signal:e?.signal}),r=(0,W.y)(t).toUpperCase();if("JPG"!==r&&"PNG"!==r&&"GIF"!==r&&"BMP"!==r)throw new o.Z("image-aux-raster:open","the data is not a supported format");this._set("datasetFormat",r);const s=r.toLowerCase(),i="gif"===s||"bmp"===s||!(0,f.Z)("ios");return await this.decodePixelBlock(t,{format:s,useCanvas:i,hasNoZlibMask:!0})}async _fetchAuxiliaryData(e){const t=(0,a.Wg)(e?.signal),r=this.ioConfig.skipExtensions??[],s=r.includes("aux.xml")?null:this.request(this.url+".aux.xml",{responseType:"xml",signal:t}),i=this.datasetFormat,n="JPG"===i?"jgw":"PNG"===i?"pgw":"BMP"===i?"bpw":null,o=n&&r.includes(n)?null:this.request(this.url.slice(0,this.url.lastIndexOf("."))+"."+n,{responseType:"text",signal:t}),l=await(0,c.as)([s,o]);if(t?.aborted)throw(0,c.zE)();const u=Ee(l[0].value?.data);if(!u.transform){const e=l[1].value?l[1].value.data.split("\n").slice(0,6).map((e=>Number(e))):null;u.transform=6===e?.length?new Pe.Z({forwardCoefficients:[e[4],e[5],e[0],-e[1],e[2],-e[3]]}):null}return u}};(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],Ne.prototype,"datasetFormat",void 0),Ne=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.ImageAuxRaster")],Ne);const Ze=Ne;var Be=r(17452),Je=r(45322),De=r(56608),Ae=r(29680),Le=r(26059);let ze=class extends ${constructor(){super(...arguments),this._levelOffset=0,this._tilemapCache=null,this._slices=null,this.datasetFormat="RasterTileServer",this.tileType=null}async open(e){await this.init();const t=e&&e.signal,r=this.sourceJSON?{data:this.sourceJSON}:await this.request(this.url,{query:{f:"json"},signal:t});r.ssl&&(this.url=this.url.replace(/^http:/i,"https:"));const s=r.data;if(this.sourceJSON=s,!s)throw new o.Z("imageserverraster:open","cannot initialize tiled image service, missing service info");if(!s.tileInfo)throw new o.Z("imageserverraster:open","use ImageryLayer to open non-tiled image services");this._fixScaleInServiceInfo(),this.tileType=s.cacheType,null==this.tileType&&(["jpg","jpeg","png","png8","png24","png32","mixed"].includes(s.tileInfo.format.toLowerCase())?this.tileType="Map":"lerc"===s.tileInfo.format.toLowerCase()?this.tileType="Elevation":this.tileType="Raster"),this.datasetName=s.name?.slice(s.name.indexOf("/")+1)??"";const i=await this._fetchRasterInfo({signal:t});if((0,a.Wi)(i))throw new o.Z("image-server-raster:open","cannot initialize image service");const n="Map"===this.tileType?(0,Je.d)(s.tileInfo,s):P.Z.fromJSON(s.tileInfo);(0,a.O3)(n);const[l,c]=this._computeMinMaxLOD(i,n),{extent:u,pixelSize:h}=i,f=.5/i.width*h.x,d=Math.max(h.x,h.y),{lods:p}=n;("Map"!==this.tileType&&0!==s.maxScale||Math.abs(h.x-h.y)>f||!p.some((e=>Math.abs(e.resolution-d)<f)))&&(h.x=h.y=l.resolution,i.width=Math.ceil((u.xmax-u.xmin)/h.x-.1),i.height=Math.ceil((u.ymax-u.ymin)/h.y-.1));const m=l.level-c.level,[g,y]=n.size,x=[];p.forEach((e=>{e.level>=c.level&&e.level<=l.level&&x.push({x:e.resolution,y:e.resolution})})),x.sort(((e,t)=>e.x-t.x));const w=this.computeBlockBoundary(u,g,y,n.origin,x,m),b=x.length>1?x.slice(1):null;let I;if(s.transposeInfo&&(I={tileSize:[s.transposeInfo.rows,s.transposeInfo.cols],packetSize:i.keyProperties?._yxs.PacketSize??0}),i.storageInfo=new O.Z({blockWidth:n.size[0],blockHeight:n.size[1],pyramidBlockWidth:n.size[0],pyramidBlockHeight:n.size[1],pyramidResolutions:b,compression:n.format,origin:n.origin,firstPyramidLevel:1,maximumPyramidLevel:m,tileInfo:n,transposeInfo:I,blockBoundary:w}),this._fixGCSShift(i),this._set("rasterInfo",i),s.capabilities.toLowerCase().includes("tilemap")){const e={tileInfo:i.storageInfo.tileInfo,parsedUrl:(0,Be.mN)(this.url),url:this.url,tileServers:[],type:"tile"};this._tilemapCache=new De.y({layer:e})}}async fetchRawTile(e,t,r,s={}){const{storageInfo:i,extent:n}=this.rasterInfo,{transposeInfo:o}=i,l=(0,a.pC)(o)&&!!s.transposedVariableName;if(this._slices&&!l&&null==s.sliceId)return null;const c=l?0:i.maximumPyramidLevel-e+this._levelOffset,u=`${this.url}/tile/${c}/${t}/${r}`,h=this._slices?l?{variable:s.transposedVariableName}:{sliceId:s.sliceId||0}:null,{data:f}=await this.request(u,{query:h,responseType:"array-buffer",signal:s.signal});if(!f)return null;const d=l?o.tileSize:i.tileInfo.size,p=await this.decodePixelBlock(f,{width:d[0],height:d[1],planes:null,pixelType:null,isPoint:"Elevation"===this.tileType,returnInterleaved:l}),m=i.blockBoundary[e];if("jpg"!==i.compression||r>m.minCol&&r<m.maxCol&&t>m.minRow&&t<m.maxRow)return p;const{origin:g,blockWidth:y,blockHeight:x}=i,{x:w,y:b}=this.getPyramidPixelSize(e),I=Math.round((n.xmin-g.x)/w)%y,_=Math.round((n.xmax-g.x)/w)%y||y,v=Math.round((g.y-n.ymax)/b)%x,S=Math.round((g.y-n.ymin)/b)%x||x,C=r===m.minCol?I:0,R=t===m.minRow?v:0,k=r===m.maxCol?_:y,T=t===m.maxRow?S:x;return(0,j.pW)(p,{x:C,y:R},{width:k-C,height:T-R}),p}getSliceIndex(e){if(!this._slices||(0,a.Wi)(e)||0===e.length)return null;const t=e;for(let e=0;e<this._slices.length;e++){const r=this._slices[e].multidimensionalDefinition;if(r.length===t.length&&!r.some((e=>{const r=t.find((t=>e.variableName===t.variableName&&t.dimensionName===e.dimensionName));return!r||(Array.isArray(e.values[0])?`${e.values[0][0]}-${e.values[0][1]}`:e.values[0])!==(Array.isArray(r.values[0])?`${r.values[0][0]}-${r.values[0][1]}`:r.values[0])})))return e}return null}async fetchVariableStatisticsHistograms(e,t){const r=this.request(this.url+"/statistics",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.statistics)),s=this.request(this.url+"/histograms",{query:{variable:e,f:"json"},signal:t}).then((e=>e.data?.histograms)),i=await Promise.all([r,s]);return i[0]&&i[0].forEach((e=>{e.avg=e.mean,e.stddev=e.standardDeviation})),{statistics:i[0]||null,histograms:i[1]||null}}async computeBestPyramidLevelForLocation(e,t={}){if(!this._tilemapCache)return 0;let r=this.identifyPixelLocation(e,0,(0,a.Wg)(t.datumTransformation));if(null===r)return null;let s=0;const{maximumPyramidLevel:i}=this.rasterInfo.storageInfo;let n=i-s+this._levelOffset;const o=r.srcLocation;for(;n>=0;){try{if("available"===await this._tilemapCache.fetchAvailability(n,r.row,r.col,t))break}catch{}if(n--,s++,r=this.identifyPixelLocation(o,s,(0,a.Wg)(t.datumTransformation)),null===r)return null}return-1===n||null==r?null:s}async _fetchRasterInfo(e){const t=this.sourceJSON;if("Map"===this.tileType){const e=t.fullExtent||t.extent,r=Math.ceil((e.xmax-e.xmin)/t.pixelSizeX-.1),s=Math.ceil((e.ymax-e.ymin)/t.pixelSizeY-.1),i=te.Z.fromJSON(t.spatialReference||e.spatialReference),n=new Z.Z({x:t.pixelSizeX,y:t.pixelSizeY,spatialReference:i});return new he.Z({width:r,height:s,bandCount:3,extent:G.Z.fromJSON(e),spatialReference:i,pixelSize:n,pixelType:"u8",statistics:null,keyProperties:{DataType:"processed"}})}const{signal:r}=e,s=(0,Le.g)(this.url,this.sourceJSON,{signal:r,query:this.ioConfig.customFetchParameters}),i=t.hasMultidimensions?this.request(`${this.url}/slices`,{query:{f:"json"},signal:r}).then((e=>e.data&&e.data.slices)).catch((()=>null)):null,n=await Promise.all([s,i]);return this._slices=n[1],n[0]}_fixScaleInServiceInfo(){const{sourceJSON:e}=this;e.minScale&&e.minScale<0&&(e.minScale=0),e.maxScale&&e.maxScale<0&&(e.maxScale=0)}_fixGCSShift(e){const{extent:t,spatialReference:r}=e;0===t.xmin&&360===t.xmax&&r?.wkid&&r.isGeographic&&(e.nativeExtent=e.extent,e.transform=new Ae.Z,e.extent=e.transform.forwardTransform(t))}_computeMinMaxLOD(e,t){const{pixelSize:r}=e,s=.5/e.width*r.x,{lods:i}=t,n=t.lodAt(Math.max.apply(null,i.map((e=>e.level)))),o=t.lodAt(Math.min.apply(null,i.map((e=>e.level)))),{tileType:a}=this;if("Map"===a)return this._levelOffset=i[0].level,[n,o];if("Raster"===a)return[i.find((e=>e.resolution===r.x))??n,o];const{minScale:l,maxScale:c}=this.sourceJSON;let u=n;c>0&&(u=i.find((e=>Math.abs(e.scale-c)<s)),u||(u=i.filter((e=>e.scale>c)).sort(((e,t)=>e.scale>t.scale?1:-1))[0]??n));let h=o;return l>0&&(h=i.find((e=>Math.abs(e.scale-l)<s))??o,this._levelOffset=h.level-o.level),[u,h]}};(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],ze.prototype,"datasetFormat",void 0),(0,s._)([(0,h.Cb)()],ze.prototype,"tileType",void 0),ze=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.ImageServerRaster")],ze);const He=ze;var We=r(5847),je=r(48279);const qe=new Map;qe.set("Int8","s8"),qe.set("UInt8","u8"),qe.set("Int16","s16"),qe.set("UInt16","u16"),qe.set("Int32","s32"),qe.set("UInt32","u32"),qe.set("Float32","f32"),qe.set("Float64","f32"),qe.set("Double64","f32");const Ge=new Map;Ge.set("none",{blobExtension:".til",isOneSegment:!0,decoderFormat:"bip"}),Ge.set("lerc",{blobExtension:".lrc",isOneSegment:!1,decoderFormat:"lerc"}),Ge.set("deflate",{blobExtension:".pzp",isOneSegment:!0,decoderFormat:"deflate"}),Ge.set("jpeg",{blobExtension:".pjg",isOneSegment:!0,decoderFormat:"jpg"});let Ue=class extends ${constructor(){super(...arguments),this._files=null,this._storageIndex=null,this.datasetFormat="MRF"}async open(e){await this.init(),this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const t=e?(0,a.Wg)(e.signal):null,r=await this.request(this.url,{responseType:"xml",signal:t}),{rasterInfo:s,files:i}=this._parseHeader(r.data);if(-1===this.ioConfig.skipExtensions?.indexOf("aux.xml")){const t=await this._fetchAuxiliaryData(e);null!=t&&(s.statistics=t.statistics??s.statistics,s.histograms=t.histograms,t.histograms&&(0,a.Wi)(s.statistics)&&(s.statistics=(0,be.Oh)(t.histograms)))}this._set("rasterInfo",s),this._files=i;const n=await this.request(i.index,{responseType:"array-buffer",signal:t});this._storageIndex=this._parseIndex(n.data);const{blockWidth:o,blockHeight:l}=this.rasterInfo.storageInfo,c=this.rasterInfo.storageInfo.pyramidScalingFactor,{width:u,height:h}=this.rasterInfo,f=[],d=this._getBandSegmentCount();let p=0,m=-1;for(;p<this._storageIndex.length;){m++;const e=Math.ceil(u/o/c**m)-1,t=Math.ceil(h/l/c**m)-1;p+=(e+1)*(t+1)*d*4,f.push({maxRow:t,maxCol:e,minCol:0,minRow:0})}this.rasterInfo.storageInfo.blockBoundary=f,m>0&&(this.rasterInfo.storageInfo.firstPyramidLevel=1,this.rasterInfo.storageInfo.maximumPyramidLevel=m),this.updateTileInfo()}async fetchRawTile(e,t,r,s={}){const{blockWidth:i,blockHeight:n,blockBoundary:o}=this.rasterInfo.storageInfo,l=o[e];if(!l||l.maxRow<t||l.maxCol<r||l.minRow>t||l.minCol>r)return null;const{bandCount:c,pixelType:u}=this.rasterInfo,{ranges:h,actualTileWidth:f,actualTileHeight:d}=this._getTileLocation(e,t,r);if(!h||0===h.length)return null;if(0===h[0].from&&0===h[0].to){const e=new Uint8Array(i*n);return new We.Z({width:i,height:n,pixels:null,mask:e,validPixelCount:0})}const{bandIds:p}=this.ioConfig,m=this._getBandSegmentCount(),g=[];let y=0;for(y=0;y<m;y++)(!p||p.indexOf[y]>-1)&&g.push(this.request(this._files.data,{range:{from:h[y].from,to:h[y].to},responseType:"array-buffer",signal:s.signal}));const x=await Promise.all(g),w=x.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),b=new Uint8Array(w);let I=0;for(y=0;y<m;y++)b.set(new Uint8Array(x[y].data),I),I+=x[y].data.byteLength;const _=Ge.get(this.rasterInfo.storageInfo.compression).decoderFormat,v=await this.decodePixelBlock(b.buffer,{width:i,height:n,format:_,planes:p?.length||c,pixelType:u});if((0,a.pC)(this.rasterInfo.noDataValue)&&"lerc"!==_&&!v.mask){const e=this.rasterInfo.noDataValue[0];if(null!=e){const t=v.width*v.height,r=new Uint8Array(t);if(Math.abs(e)>1e24)for(y=0;y<t;y++)Math.abs((v.pixels[0][y]-e)/e)>1e-6&&(r[y]=1);else for(y=0;y<t;y++)v.pixels[0][y]!==e&&(r[y]=1);v.mask=r}}let S=0,C=0;if(f!==i||d!==n){let e=v.mask;if(e)for(y=0;y<n;y++)if(C=y*i,y<d)for(S=f;S<i;S++)e[C+S]=0;else for(S=0;S<i;S++)e[C+S]=0;else for(e=new Uint8Array(i*n),v.mask=e,y=0;y<d;y++)for(C=y*i,S=0;S<f;S++)e[C+S]=1}return v}_parseIndex(e){if(e.byteLength%16>0)throw"invalid array buffer must be multiples of 16";let t,r,s,i,n,o;if(je.f){for(r=new Uint8Array(e),i=new ArrayBuffer(e.byteLength),s=new Uint8Array(i),n=0;n<e.byteLength/4;n++)for(o=0;o<4;o++)s[4*n+o]=r[4*n+3-o];t=new Uint32Array(i)}else t=new Uint32Array(e);return t}_getBandSegmentCount(){return Ge.get(this.rasterInfo.storageInfo.compression).isOneSegment?1:this.rasterInfo.bandCount}_getTileLocation(e,t,r){const{blockWidth:s,blockHeight:i,pyramidScalingFactor:n}=this.rasterInfo.storageInfo,{width:o,height:a}=this.rasterInfo,l=this._getBandSegmentCount();let c,u,h,f=0,d=0;for(h=0;h<e;h++)d=n**h,c=Math.ceil(o/s/d),u=Math.ceil(a/i/d),f+=c*u;d=n**e,c=Math.ceil(o/s/d),u=Math.ceil(a/i/d),f+=t*c+r,f*=4*l;const p=this._storageIndex.subarray(f,f+4*l);let m=0,g=0;const y=[];for(let e=0;e<l;e++)m=p[4*e+0]*2**32+p[4*e+1],g=m+p[4*e+2]*2**32+p[4*e+3],y.push({from:m,to:g});return{ranges:y,actualTileWidth:r<c-1?s:Math.ceil(o/d)-s*(c-1),actualTileHeight:t<u-1?i:Math.ceil(a/d)-i*(u-1)}}_parseHeader(e){const t=Se(e,"MRF_META/Raster");if(!t)throw new o.Z("mrf:open","not a valid MRF format");const r=Se(t,"Size"),s=parseInt(r.getAttribute("x"),10),i=parseInt(r.getAttribute("y"),10),n=parseInt(r.getAttribute("c"),10),a=(Ce(t,"Compression")||"none").toLowerCase();if(!Ge.has(a))throw new o.Z("mrf:open","currently does not support compression "+a);const l=Ce(t,"DataType")||"UInt8",c=qe.get(l);if(null==c)throw new o.Z("mrf:open","currently does not support pixel type "+l);const u=Se(t,"PageSize"),h=parseInt(u.getAttribute("x"),10),f=parseInt(u.getAttribute("y"),10),d=Se(t,"DataValues");let p,m;if(d&&(m=d.getAttribute("NoData"),null!=m&&(p=m.trim().split(" ").map((e=>parseFloat(e))))),Se(e,"MRF_META/CachedSource"))throw new o.Z("mrf:open","currently does not support MRF referencing other data files");const g=Se(e,"MRF_META/GeoTags"),y=Se(g,"BoundingBox");let x,w=!1;if(null!=y){const e=parseFloat(y.getAttribute("minx")),t=parseFloat(y.getAttribute("miny")),r=parseFloat(y.getAttribute("maxx")),s=parseFloat(y.getAttribute("maxy")),i=Ce(g,"Projection")||"";let n=te.Z.WGS84;if("LOCAL_CS[]"!==i)if(i.toLowerCase().startsWith("epsg:")){const e=Number(i.slice(5));isNaN(e)||0===e||(n=new te.Z({wkid:e}))}else n=Fe(i)??te.Z.WGS84;else w=!0,n=new te.Z({wkid:3857});x=new G.Z(e,t,r,s),x.spatialReference=n}else w=!0,x=new G.Z({xmin:-.5,ymin:.5-i,xmax:s-.5,ymax:.5,spatialReference:new te.Z({wkid:3857})});const b=Se(e,"MRF_META/Rsets"),I=parseInt(b&&b.getAttribute("scale")||"2",10),_=x.spatialReference,v=new O.Z({origin:new Z.Z({x:x.xmin,y:x.ymax,spatialReference:_}),blockWidth:h,blockHeight:f,pyramidBlockWidth:h,pyramidBlockHeight:f,compression:a,pyramidScalingFactor:I}),S=new Z.Z({x:x.width/s,y:x.height/i,spatialReference:_}),C=new he.Z({width:s,height:i,extent:x,isPseudoSpatialReference:w,spatialReference:_,bandCount:n,pixelType:c,pixelSize:S,noDataValue:p,storageInfo:v}),R=Ce(e,"datafile"),k=Ce(e,"IndexFile");return{rasterInfo:C,files:{mrf:this.url,index:k||this.url.replace(".mrf",".idx"),data:R||this.url.replace(".mrf",Ge.get(a).blobExtension)}}}async _fetchAuxiliaryData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return Ee(t)}catch{return null}}};(0,s._)([(0,h.Cb)()],Ue.prototype,"_files",void 0),(0,s._)([(0,h.Cb)()],Ue.prototype,"_storageIndex",void 0),(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],Ue.prototype,"datasetFormat",void 0),Ue=(0,s._)([(0,g.j)("esri.layers.support.rasterIO.MRFRaster")],Ue);const $e=Ue;var Ve=r(94793),Xe=r(9832);const Qe=(e,t)=>e.get(t)?.values,Ye=(e,t)=>e.get(t)?.values?.[0];let Ke=class extends ${constructor(){super(...arguments),this._files=null,this._headerInfo=null,this._bufferSize=1048576,this.datasetFormat="TIFF"}async open(e){await this.init();const t=e?(0,a.Wg)(e.signal):null,{data:r}=await this.request(this.url,{range:{from:0,to:this._bufferSize},responseType:"array-buffer",signal:t});if(!r)throw new o.Z("tiffraster:open","failed to open url "+this.url);this.datasetName=this.url.slice(this.url.lastIndexOf("/")+1);const{littleEndian:s,firstIFDPos:i,isBigTiff:n}=(0,Ve.cK)(r),l=[];await this._readIFDs(l,r,s,i,0,n?8:4,t);const{imageInfo:c,rasterInfo:u}=this._parseIFDs(l);if(this._headerInfo={littleEndian:s,isBigTiff:n,ifds:l,...c},this._set("rasterInfo",u),!c.isSupported)throw new o.Z("tiffraster:open","this tiff is not supported: "+c.message);if(!c.tileWidth)throw new o.Z("tiffraster:open","none-tiled tiff is not optimized for access, convert to COG and retry.");const{skipExtensions:h=[]}=this.ioConfig;if(!h.includes("aux.xml")){const t=await this._fetchAuxiliaryMetaData(e);null!=t&&this._processPAMInfo(t,u)}h.includes("vat.dbf")||1!==u.bandCount||"u8"!==u.pixelType||(u.attributeTable=await this._fetchAuxiliaryTable(e),(0,a.pC)(u.attributeTable)&&(u.keyProperties.DataType="thematic")),this.updateTileInfo()}async fetchRawTile(e,t,r,s={}){if(!this._headerInfo?.isSupported||this.isBlockOutside(e,t,r))return null;const i=this._getTileLocation(e,t,r);if(!i)return null;const{ranges:n,actualTileWidth:o,actualTileHeight:a,ifd:l}=i,c=n.map((e=>this.request(this.url,{range:e,responseType:"array-buffer",signal:s.signal}))),u=await Promise.all(c),h=u.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t)),f=1===u.length?u[0].data:new ArrayBuffer(h),d=[0],p=[0];if(u.length>1){const e=new Uint8Array(f);for(let t=0,r=0;t<u.length;t++){const s=u[t].data;e.set(new Uint8Array(s),r),d[t]=r,r+=s.byteLength,p[t]=s.byteLength}}const{blockWidth:m,blockHeight:g}=this.getBlockWidthHeight(e),y=await this.decodePixelBlock(f,{format:"tiff",customOptions:{headerInfo:this._headerInfo,ifd:l,offsets:d,sizes:p},width:m,height:g,planes:null,pixelType:null});let x,w,b;if(o!==m||a!==g){let e=y.mask;if(e)for(x=0;x<g;x++)if(b=x*m,x<a)for(w=o;w<m;w++)e[b+w]=0;else for(w=0;w<m;w++)e[b+w]=0;else for(e=new Uint8Array(m*g),y.mask=e,x=0;x<a;x++)for(b=x*m,w=0;w<o;w++)e[b+w]=1}return y}_parseIFDs(e){const t=(0,Ve.FI)(e),{width:r,height:s,tileWidth:i,tileHeight:n,planes:o,pixelType:a,compression:l,firstPyramidLevel:c,maximumPyramidLevel:u,pyramidBlockWidth:h,pyramidBlockHeight:f,tileBoundary:d,affine:p,metadata:m}=t;let g=Fe(t.extent.spatialReference?.wkt||t.extent.spatialReference?.wkid),y=!1;null==g&&(y=!0,g=new te.Z({wkid:3857}));const x=new G.Z({...t.extent,spatialReference:g}),w=new Z.Z(x?{x:x.xmin,y:x.ymax,spatialReference:g}:{x:0,y:0}),b=new O.Z({blockWidth:i,blockHeight:n,pyramidBlockWidth:h,pyramidBlockHeight:f,compression:l,origin:w,firstPyramidLevel:c,maximumPyramidLevel:u,blockBoundary:d}),I=new Z.Z({x:(x.xmax-x.xmin)/r,y:(x.ymax-x.ymin)/s,spatialReference:g}),_=m?{BandProperties:m.bandProperties,DataType:m.dataType}:{};let v=null;const S=Ye(e[0],"PHOTOMETRICINTERPRETATION"),C=Qe(e[0],"COLORMAP");if(3===S&&C?.length>3&&C.length%3==0){v=[];const e=C.length/3;for(let t=0;t<e;t++)v.push([t,C[t]>>>8,C[t+e]>>>8,C[t+2*e]>>>8])}const R=new he.Z({width:r,height:s,bandCount:o,pixelType:a,pixelSize:I,storageInfo:b,spatialReference:g,isPseudoSpatialReference:y,keyProperties:_,extent:x,colormap:v,statistics:m?m.statistics:null});return p?.length&&(R.nativeExtent=new G.Z({xmin:-.5,ymin:.5-s,xmax:r-.5,ymax:.5,spatialReference:g}),R.transform=new Pe.Z({polynomialOrder:1,forwardCoefficients:[p[2]+p[0]/2,p[5]-p[3]/2,p[0],p[3],-p[1],-p[4]]}),R.extent=R.transform.forwardTransform(R.nativeExtent),R.pixelSize=new Z.Z({x:(x.xmax-x.xmin)/r,y:(x.ymax-x.ymin)/s,spatialReference:g}),b.origin.x=-.5,b.origin.y=.5),{imageInfo:t,rasterInfo:R}}_processPAMInfo(e,t){if(t.statistics=e.statistics??t.statistics,t.histograms=e.histograms,e.histograms&&(0,a.Wi)(t.statistics)&&(t.statistics=(0,be.Oh)(e.histograms)),e.transform&&(0,a.Wi)(t.transform)){t.transform=e.transform,t.nativeExtent=t.extent;const r=t.transform.forwardTransform(t.nativeExtent);t.pixelSize=new Z.Z({x:(r.xmax-r.xmin)/t.width,y:(r.ymax-r.ymin)/t.height,spatialReference:t.spatialReference}),t.extent=r}t.spatialReference||(t.spatialReference=e.spatialReference)}async _readIFDs(e,t,r,s,i,n=4,o){if(!s)return null;(s>=t.byteLength||s<0)&&(t=(await this.request(this.url,{range:{from:s+i,to:s+i+this._bufferSize},responseType:"array-buffer",signal:o})).data,i=s+i,s=0);const a=await this._readIFD(t,r,s,i,Xe.Z.TIFF_TAGS,n,o);if(e.push(a.ifd),!a.nextIFD)return null;await this._readIFDs(e,t,r,a.nextIFD-i,i,n,o)}async _readIFD(e,t,r,s,i=Xe.Z.TIFF_TAGS,n=4,o){if(!e)return null;const l=(0,Ve.vr)(e,t,r,s,i,n);if(l.success){const r=[];if(l.ifd?.forEach((e=>{e.values||r.push(e)})),r.length>0){const i=r.map((e=>e.offlineOffsetSize)).filter(a.pC),n=Math.min.apply(null,i.map((e=>e[0])));if(Math.min.apply(null,i.map((e=>e[0]+e[1])))-n<=this._bufferSize){const{data:i}=await this.request(this.url,{range:{from:n,to:n+this._bufferSize},responseType:"array-buffer",signal:o});e=i,s=n,r.forEach((r=>(0,Ve.Dq)(e,t,r,s)))}}if(l.ifd?.has("GEOKEYDIRECTORY")){const r=l.ifd.get("GEOKEYDIRECTORY"),i=r?.values;if(i&&i.length>4){const n=i[0]+"."+i[1]+"."+i[2],a=await this._readIFD(e,t,r.valueOffset+6-s,s,Xe.Z.GEO_KEYS,2,o);r.data=a.ifd,r.data&&r.data.set("GEOTIFFVersion",{id:0,type:2,valueCount:1,valueOffset:null,values:[n]})}}return l}if(l.requiredBufferSize&&l.requiredBufferSize!==e.byteLength){const r=await this.request(this.url,{range:{from:s,to:s+l.requiredBufferSize+4},responseType:"array-buffer",signal:o});return(e=r.data).byteLength<l.requiredBufferSize?null:this._readIFD(e,t,0,s,Xe.Z.TIFF_TAGS,4,o)}}_getTileLocation(e,t,r){const{firstPyramidLevel:s,blockBoundary:i}=this.rasterInfo.storageInfo,n=0===e?0:e-(s-1),o=this._headerInfo?.ifds[n];if(!o)return null;const a=(0,Ve.If)(o,this._headerInfo),l=Qe(o,"TILEOFFSETS");if(void 0===l)return null;const c=Qe(o,"TILEBYTECOUNTS"),{minRow:u,minCol:h,maxRow:f,maxCol:d}=i[n];if(t>f||r>d||t<u||r<h)return null;const p=Ye(o,"IMAGEWIDTH"),m=Ye(o,"IMAGELENGTH"),g=Ye(o,"TILEWIDTH"),y=Ye(o,"TILELENGTH"),x=a?this.rasterInfo.bandCount:1,w=x*t*(d+1)+r,b=[{from:l[w],to:l[w+x-1]+c[w+x-1]-1}];if(a){let e=!0;for(let t=0;t<x;t++)if(l[w+t]+c[w+t]!==l[w+t+1]){e=!1;break}if(!e)for(let e=0;e<x;e++)b[e]={from:l[w+e],to:l[w+e]+c[w+e]-1}}const I=l[w],_=c[w];return null==I||null==_?null:{ranges:b,ifd:o,actualTileWidth:r===d&&p%g||g,actualTileHeight:t===f&&m%y||y}}async _fetchAuxiliaryMetaData(e){try{const{data:t}=await this.request(this.url+".aux.xml",{responseType:"xml",signal:e?.signal});return Ee(t)}catch{return null}}async _fetchAuxiliaryTable(e){try{const{data:t}=await this.request(this.url+".vat.dbf",{responseType:"array-buffer",signal:e?.signal}),r=pe.parse(t);return r?.recordSet?ge.default.fromJSON(r.recordSet):null}catch{return null}}};(0,s._)([(0,h.Cb)()],Ke.prototype,"_files",void 0),(0,s._)([(0,h.Cb)()],Ke.prototype,"_headerInfo",void 0),(0,s._)([(0,h.Cb)()],Ke.prototype,"_bufferSize",void 0),(0,s._)([(0,h.Cb)({type:String,json:{write:!0}})],Ke.prototype,"datasetFormat",void 0),Ke=(0,s._)([(0,g.j)("esri.layers.support.rasterDatasets.TIFFRaster")],Ke);const et=Ke,tt=new Map;tt.set("CRF",{desc:"Cloud Raster Format",constructor:we}),tt.set("MRF",{desc:"Meta Raster Format",constructor:$e}),tt.set("TIFF",{desc:"GeoTIFF",constructor:et}),tt.set("RasterTileServer",{desc:"Raster Tile Server",constructor:He}),tt.set("JPG",{desc:"JPG Raster Format",constructor:Ze}),tt.set("PNG",{desc:"PNG Raster Format",constructor:Ze}),tt.set("GIF",{desc:"GIF Raster Format",constructor:Ze}),tt.set("BMP",{desc:"BMP Raster Format",constructor:Ze});class rt{static get supportedFormats(){const e=new Set;return tt.forEach(((t,r)=>e.add(r))),e}static async open(e){const{url:t,ioConfig:r,sourceJSON:s}=e;let i=e.datasetFormat;null==i&&t.lastIndexOf(".")&&(i=t.slice(t.lastIndexOf(".")+1).toUpperCase()),"OVR"===i||"TIF"===i?i="TIFF":"JPG"!==i&&"JPEG"!==i&&"JFIF"!==i||(i="JPG"),t.toLowerCase().includes("/imageserver")&&!t.toLowerCase().includes("/wcsserver")&&(i="RasterTileServer");const n={url:t,sourceJSON:s,datasetFormat:i,ioConfig:r??{bandIds:null,sampling:null}};let a,l;if(i&&this.supportedFormats.has(i)){if("CRF"===i&&!r?.enableCRF)throw new o.Z("rasterfactory:open",`cannot open raster: ${t}`);return a=tt.get(i).constructor,l=new a(n),await l.open({signal:e.signal}),l}if(i)throw new o.Z("rasterfactory:open","not a supported format "+i);const c=Array.from(tt.keys());let u=0;const h=()=>(i=c[u++],i&&("CRF"!==i||r?.enableCRF)?(a=tt.get(i).constructor,l=new a(n),l.open({signal:e.signal}).then((()=>l)).catch((()=>h()))):null);return h()}static register(e,t,r){tt.has(e.toUpperCase())||tt.set(e.toUpperCase(),{desc:t,constructor:r})}}var st=r(32163);let it=class extends((0,x.h)((0,ae.M)((0,ie.q)((0,ne.I)((0,w.N)(se((0,le.n)((0,oe.Q)((0,l.R)(y.Z)))))))))){constructor(...e){super(...e),this.bandIds=null,this.interpolation=null,this.legendEnabled=!0,this.isReference=null,this.listMode="show",this.sourceJSON=null,this.version=null,this.title=null,this.type="imagery-tile",this.operationalLayerType="ArcGISTiledImageServiceLayer",this.popupEnabled=!0,this.popupTemplate=null,this.fields=null}normalizeCtorArgs(e,t){return"string"==typeof e?{url:e,...t}:e}load(e){const t=(0,a.pC)(e)?e.signal:null;return this.addResolvingPromise(this.loadFromPortal({supportedTypes:["Image Service"]},e).catch(c.r9).then((()=>this._openRaster(t)))),Promise.resolve(this)}get defaultPopupTemplate(){return this.createPopupTemplate()}get rasterFields(){let e=[new ce.Z({name:"Raster.ServicePixelValue",alias:"Pixel Value",domain:null,editable:!1,length:50,type:"string"})];const{rasterInfo:t}=this,{attributeTable:r}=t,s=(0,a.pC)(r)?r.fields:null;if(s){const t=s.filter((e=>"oid"!==e.type&&"value"!==e.name.toLowerCase())).map((e=>{const t=e.clone();return t.name="Raster."+e.name,t}));e=e.concat(t)}const{dataType:i,multidimensionalInfo:n}=t;if(("vector-magdir"===i||"vector-uv"===i)&&(0,a.pC)(n)){const t=n.variables[0].unit?.trim(),r="Magnitude"+(t?` (${t})`:"");e.push(new ce.Z({name:"Raster.Magnitude",alias:r,domain:null,editable:!1,type:"double"})),e.push(new ce.Z({name:"Raster.Direction",alias:"Direction ()",domain:null,editable:!1,type:"double"}))}return e}set renderer(e){this._set("renderer",e),this.updateRenderer()}readRenderer(e,t,r){const s=t&&t.layerDefinition&&t.layerDefinition.drawingInfo&&t.layerDefinition.drawingInfo.renderer,i=(0,n.ij)(s,r)||void 0;if(null!=i)return i}createPopupTemplate(e){return(0,st.eZ)({fields:this.rasterFields,title:this.title},e)}write(e,t){const{raster:r}=this;if(this.loaded?"RasterTileServer"===r.datasetFormat&&("Raster"===r.tileType||"Map"===r.tileType):this.url&&/\/ImageServer(\/|\/?$)/i.test(this.url))return super.write(e,t);if(t&&t.messages){const e=`${t.origin}/${t.layerContainerType||"operational-layers"}`;t.messages.push(new o.Z("layer:unsupported",`Layers (${this.title}, ${this.id}) of type '${this.declaredClass}' are not supported in the context of '${e}'`,{layer:this}))}return null}async _openRaster(e){if(this.raster)this.raster.rasterInfo||await this.raster.open(),this.url=this.raster.url;else{const t=await rt.open({url:this.url,sourceJSON:this.sourceJSON,ioConfig:{sampling:"closest",...this.ioConfig,customFetchParameters:this.customParameters},signal:e});if(this.rasterFunction){const e=(0,Q.Ue)(this.rasterFunction.toJSON(),{raster:t}),r=new X({rasterFunction:e});await r.open(),this.raster=r}else this.raster=t}const{rasterInfo:t}=this.raster;if(!t)throw new o.Z("imagery-tile-layer:load","cannot load resources on "+this.url);if(this.sourceJSON=this.sourceJSON||this.raster.sourceJSON,null!=this.sourceJSON){const e="Map"===this.raster.tileType&&null!=this.sourceJSON.minLOD&&null!=this.sourceJSON.maxLOD?this.sourceJSON:{...this.sourceJSON,minScale:0,maxScale:0};this.read(e,{origin:"service"})}null==this.title&&(this.title=this.raster.datasetName),"Map"===this.raster.tileType&&(this.popupEnabled=!1),this._configDefaultSettings(),this.addHandles((0,u.YP)((()=>this.customParameters),(e=>{this.raster.ioConfig.customFetchParameters=e})))}};(0,s._)([(0,h.Cb)({type:[d.z8],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],it.prototype,"bandIds",void 0),(0,s._)([(0,h.Cb)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,p.J)(ue.c)],it.prototype,"interpolation",void 0),(0,s._)([(0,h.Cb)({json:{write:!0}})],it.prototype,"multidimensionalDefinition",void 0),(0,s._)([(0,h.Cb)(S.rn)],it.prototype,"legendEnabled",void 0),(0,s._)([(0,h.Cb)({type:Boolean,json:{read:!1,write:{enabled:!0,overridePolicy:()=>({enabled:!1})}}})],it.prototype,"isReference",void 0),(0,s._)([(0,h.Cb)({type:["show","hide"]})],it.prototype,"listMode",void 0),(0,s._)([(0,h.Cb)({json:{read:!0,write:!0}})],it.prototype,"blendMode",void 0),(0,s._)([(0,h.Cb)()],it.prototype,"sourceJSON",void 0),(0,s._)([(0,h.Cb)({readOnly:!0,json:{origins:{service:{read:{source:"currentVersion"}}}}})],it.prototype,"version",void 0),(0,s._)([(0,h.Cb)()],it.prototype,"title",void 0),(0,s._)([(0,h.Cb)({readOnly:!0,json:{read:!1}})],it.prototype,"type",void 0),(0,s._)([(0,h.Cb)({type:["ArcGISTiledImageServiceLayer"]})],it.prototype,"operationalLayerType",void 0),(0,s._)([(0,h.Cb)({type:Boolean,value:!0,json:{read:{source:"disablePopup",reader:(e,t)=>!t.disablePopup},write:{target:"disablePopup",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}},writer(e,t,r){t[r]=!e}}}})],it.prototype,"popupEnabled",void 0),(0,s._)([(0,h.Cb)({type:i.Z,json:{read:{source:"popupInfo"},write:{target:"popupInfo",overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType}}}}})],it.prototype,"popupTemplate",void 0),(0,s._)([(0,h.Cb)({readOnly:!0})],it.prototype,"defaultPopupTemplate",null),(0,s._)([(0,h.Cb)({readOnly:!0,type:[ce.Z]})],it.prototype,"fields",void 0),(0,s._)([(0,h.Cb)({readOnly:!0,type:[ce.Z]})],it.prototype,"rasterFields",null),(0,s._)([(0,h.Cb)({types:n.dr,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:n.FK,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],it.prototype,"renderer",null),(0,s._)([(0,m.r)("renderer")],it.prototype,"readRenderer",null),it=(0,s._)([(0,g.j)("esri.layers.ImageryTileLayer")],it);const nt=it},74889:(e,t,r)=>{r.r(t),r.d(t,{default:()=>b});var s,i=r(43697),n=r(66577),o=r(38171),a=r(35454),l=r(96674),c=r(22974),u=r(70586),h=r(5600),f=(r(75215),r(71715)),d=r(52011),p=r(30556),m=r(82971),g=r(33955),y=r(1231);const x=new a.X({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let w=s=class extends l.wq{constructor(e){super(e),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(e,t){const r=m.Z.fromJSON(t.spatialReference),s=[];for(let t=0;t<e.length;t++){const i=e[t],n=o.Z.fromJSON(i),a=i.geometry&&i.geometry.spatialReference;(0,u.pC)(n.geometry)&&!a&&(n.geometry.spatialReference=r);const l=i.aggregateGeometries,c=n.aggregateGeometries;if(l&&(0,u.pC)(c))for(const e in c){const t=c[e],s=l[e]?.spatialReference;(0,u.pC)(t)&&!s&&(t.spatialReference=r)}s.push(n)}return s}writeGeometryType(e,t,r,s){if(e)return void x.write(e,t,r,s);const{features:i}=this;if(i)for(const e of i)if(e&&(0,u.pC)(e.geometry))return void x.write(e.geometry.type,t,r,s)}readQueryGeometry(e,t){if(!e)return null;const r=!!e.spatialReference,s=(0,g.im)(e);return s&&!r&&t.spatialReference&&(s.spatialReference=m.Z.fromJSON(t.spatialReference)),s}writeSpatialReference(e,t){if(e)return void(t.spatialReference=e.toJSON());const{features:r}=this;if(r)for(const e of r)if(e&&(0,u.pC)(e.geometry)&&e.geometry.spatialReference)return void(t.spatialReference=e.geometry.spatialReference.toJSON())}clone(){return new s(this.cloneProperties())}cloneProperties(){return(0,c.d9)({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(e){const t=this.write();if(t.features&&Array.isArray(e)&&e.length>0)for(let r=0;r<t.features.length;r++){const s=t.features[r];if(s.geometry){const t=e&&e[r];s.geometry=t&&t.toJSON()||s.geometry}}return t}quantize(e){const{scale:[t,r],translate:[s,i]}=e,n=this.features,o=this._getQuantizationFunction(this.geometryType,(e=>Math.round((e-s)/t)),(e=>Math.round((i-e)/r)));for(let e=0,t=n.length;e<t;e++)o?.((0,u.Wg)(n[e].geometry))||(n.splice(e,1),e--,t--);return this.transform=e,this}unquantize(){const{geometryType:e,features:t,transform:r}=this;if(!r)return this;const{translate:[s,i],scale:[n,o]}=r,a=this._getHydrationFunction(e,(e=>e*n+s),(e=>i-e*o));for(const{geometry:e}of t)(0,u.pC)(e)&&a&&a(e);return this.transform=null,this}_quantizePoints(e,t,r){let s,i;const n=[];for(let o=0,a=e.length;o<a;o++){const a=e[o];if(o>0){const e=t(a[0]),o=r(a[1]);e===s&&o===i||(n.push([e-s,o-i]),s=e,i=o)}else s=t(a[0]),i=r(a[1]),n.push([s,i])}return n.length>0?n:null}_getQuantizationFunction(e,t,r){return"point"===e?e=>(e.x=t(e.x),e.y=r(e.y),e):"polyline"===e||"polygon"===e?e=>{const s=(0,g.oU)(e)?e.rings:e.paths,i=[];for(let e=0,n=s.length;e<n;e++){const n=s[e],o=this._quantizePoints(n,t,r);o&&i.push(o)}return i.length>0?((0,g.oU)(e)?e.rings=i:e.paths=i,e):null}:"multipoint"===e?e=>{const s=this._quantizePoints(e.points,t,r);return s&&s.length>0?(e.points=s,e):null}:"extent"===e?e=>e:null}_getHydrationFunction(e,t,r){return"point"===e?e=>{e.x=t(e.x),e.y=r(e.y)}:"polyline"===e||"polygon"===e?e=>{const s=(0,g.oU)(e)?e.rings:e.paths;let i,n;for(let e=0,o=s.length;e<o;e++){const o=s[e];for(let e=0,s=o.length;e<s;e++){const s=o[e];e>0?(i+=s[0],n+=s[1]):(i=s[0],n=s[1]),s[0]=t(i),s[1]=r(n)}}}:"extent"===e?e=>{e.xmin=t(e.xmin),e.ymin=r(e.ymin),e.xmax=t(e.xmax),e.ymax=r(e.ymax)}:"multipoint"===e?e=>{const s=e.points;let i,n;for(let e=0,o=s.length;e<o;e++){const o=s[e];e>0?(i+=o[0],n+=o[1]):(i=o[0],n=o[1]),o[0]=t(i),o[1]=r(n)}}:null}};(0,i._)([(0,h.Cb)({type:String,json:{write:!0}})],w.prototype,"displayFieldName",void 0),(0,i._)([(0,h.Cb)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],w.prototype,"exceededTransferLimit",void 0),(0,i._)([(0,h.Cb)({type:[o.Z],json:{write:!0}})],w.prototype,"features",void 0),(0,i._)([(0,f.r)("features")],w.prototype,"readFeatures",null),(0,i._)([(0,h.Cb)({type:[y.Z],json:{write:!0}})],w.prototype,"fields",void 0),(0,i._)([(0,h.Cb)({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:x.read}}})],w.prototype,"geometryType",void 0),(0,i._)([(0,p.c)("geometryType")],w.prototype,"writeGeometryType",null),(0,i._)([(0,h.Cb)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],w.prototype,"hasM",void 0),(0,i._)([(0,h.Cb)({type:Boolean,json:{write:{overridePolicy:e=>({enabled:e})}}})],w.prototype,"hasZ",void 0),(0,i._)([(0,h.Cb)({types:n.qM,json:{write:!0}})],w.prototype,"queryGeometry",void 0),(0,i._)([(0,f.r)("queryGeometry")],w.prototype,"readQueryGeometry",null),(0,i._)([(0,h.Cb)({type:m.Z,json:{write:!0}})],w.prototype,"spatialReference",void 0),(0,i._)([(0,p.c)("spatialReference")],w.prototype,"writeSpatialReference",null),(0,i._)([(0,h.Cb)({json:{write:!0}})],w.prototype,"transform",void 0),w=s=(0,i._)([(0,d.j)("esri.rest.support.FeatureSet")],w),w.prototype.toJSON.isDefaultToJSON=!0;const b=w}}]);