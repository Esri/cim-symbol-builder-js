"use strict";(self.webpackChunkRemoteClient=self.webpackChunkRemoteClient||[]).push([[1761],{1761:(e,t,s)=>{s.r(t),s.d(t,{OperatorGeodesicBuffer:()=>q});var n=s(76061),i=s(55537),r=s(35368),o=s(96546),m=s(90237),a=s(26986),h=s(11878),c=s(32406),u=s(54573),l=s(31085);function _(e,t){const s=e.getGeometryType();return s===i.G.enumPoint?e:(0,i.e)(s)?function(e){if(function(e){for(let t=0,s=e.getPathCount();t<s;t++){const s=e.getPathSize(t);if(0===s)return!1;if(1===s){if(0===e.getSegmentCountPath(t))return!1;if(e.getSegmentType(e.getPathStart(t))===i.G.enumLine)return!1;if(!e.isClosedPath(t))return!1}}return!0}(e))return e;const t=e.createInstance();for(let s=0,n=e.getPathCount();s<n;s++){const n=e.getPathSize(s);if(0!==n){if(1===n){if(0===e.getSegmentCountPath(s))continue;if(e.getSegmentType(e.getPathStart(s))===i.G.enumLine)continue;if(!e.isClosedPath(s))continue}t.addPath(e,s,!0)}}return t}(e):s===i.G.enumMultiPoint||s===i.G.enumEnvelope?e:s===i.G.enumMultipatch?((0,i.k)("not implemented for multipatch"),e):e}var f=s(5247);class d{constructor(e){this.m_sr=null,this.m_gcs=null,this.m_transform=null,this.m_a=0,this.m_eSquared=0,this.m_rpu=0,this.m_radTolerance=0,this.m_q90=0,this.m_gcs90=0,this.m_gcs180=0,this.m_gcs360=0,this.m_gcs60=0,this.m_ellipticToGeodesicMaxRatio=0,this.m_curveType=0,this.m_bShapePreserving=!1,this.m_distance=0,this.m_absDistance=0,this.m_convergenceOffset=0,this.m_cornerStep=0,this.m_segmentStep=0,this.m_progressTracker=e}bufferPolygon(e){const t=new r.g,s=new I(this,e,t);return this.processGnomonicBufferPiecesCursor(!0,s)}bufferPolyline(e){const t=new I(this,e,null);return this.processGnomonicBufferPiecesCursor(!0,t)}bufferMultiPoint(e){const t=new G(this,e);return this.processGnomonicBufferPiecesCursor(!1,t)}bufferPoint(e){const t=e.getXY();t.scale(this.m_rpu);let s=new r.g;if(this.bufferPoint2D(t,!1,s)){const e=(0,r.t)(null,s,!0);s=(0,c.p)(s,e,!0,!0,-1,this.m_progressTracker,0,!1)}return s=(new a.g).foldInto360RangeGeodetic(s,this.m_gcs,2),s}processGnomonicBufferPiecesCursor(e,t){const s=t;let n=s.getGnomonic();const i=(0,a.j)((0,a.k)()),m=new a.S;i.queryPrecisionDescriptor(m),m.setTolerance(0,.001),(0,a.j)((0,a.k)(),void 0,m);let u=new a.L,_=(new o.O).executeMany(u,i,this.m_progressTracker,2);const f=(0,h.a)(6,!1),d=(0,h.m)(r.a,6);this.initializeGrid(f,d);const g=[null,null,null,null,null,null],p=[null,null,null,null,null,null],P=[null,null,null,null,null,null];let b,x,y;for(;null!==(b=s.next());){if(x=s.getGnomonic(),x!==n){if(null!==n){let t=_.next();if(u=null,_=null,null!=t){const s=(0,r.t)(i,t,!0),o=(0,r.k)(s);t=n.unproject(t,o,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,f,d,g,p,P)}}null!==x&&(u=new a.L,_=(new o.O).executeMany(u,i,this.m_progressTracker,2)),n=x}if(s.isRunningInGnomonic()){if(x.project(b),s.needsSimplify()){const e=(0,r.t)(null,b,!0);b=(0,c.p)(b,e,!0,!0,-1,this.m_progressTracker,0,!1)}u.tick(v(b)),_.tock()}else this.putInGridCursors(e,b,i,!0,f,d,g,p,P)}let w=!1;for(let e=0;e<6;e++)if(null!=P[e]){w=!0;break}if(w){let t=!1;const m=[null,null,null,null,null,null];if(e){const n=s.m_densified;if(s.m_densified=null,null!==n){const s=new h.T;s.scale(1/this.m_rpu,1/this.m_rpu),n.applyTransformation(s),this.m_distance>0?this.putInGridCursors(e,n,i,!1,f,d,g,p,P):(this.processInGrid(e,n,!1,f,d,g,m),t=!0)}}const b=new a.L,x=(new o.O).executeMany(b,this.m_gcs,this.m_progressTracker,2);if(null!==_){let t=_.next();u=null,_=null;const s=(0,r.t)(i,t,!0),o=(0,r.k)(s);t=n.unproject(t,o,this.m_progressTracker),this.putInGridCursors(e,t,i,!0,f,d,g,p,P)}for(let e=0;e<6;e++)if(null!=P[e]){let s=P[e].next();P[e]=null,p[e]=null,t&&null!==m[e]&&(s=(new l.O).execute(m[e],s,i,this.m_progressTracker));const n=(0,r.t)(i,s,!0),o=(0,r.k)(n);s=g[e].unproject(s,o,this.m_progressTracker),s=(new c.O).execute(s,this.m_gcs,!0,this.m_progressTracker),b.tick(v(s)),x.tock()}y=x.next()}else{let t,o=!1;if(e){let e=s.m_densified;if(s.m_densified=null,null!==e){const s=new h.T;s.scale(1/this.m_rpu,1/this.m_rpu),e.applyTransformation(s),x.project(e);const n=(0,r.t)(null,e,!0);e=(0,c.p)(e,n,!1,!0,-1,this.m_progressTracker,0,!1),this.m_distance>0?(u.tick(v(e)),_.tock()):(t=e,o=!0)}}let m=_.next();u=null,_=null,o&&(m=(new l.O).execute(t,m,i,this.m_progressTracker));const a=(0,r.t)(i,m,!0),f=(0,r.k)(a);y=n.unproject(m,f,this.m_progressTracker),y=(new c.O).execute(y,this.m_gcs,!0,this.m_progressTracker)}return y=(new a.g).foldInto360RangeGeodetic(y,this.m_gcs,2),y}putInGridCursors(e,t,s,n,i,r,m,h,c){const u=[null,null,null,null,null,null];this.processInGrid(e,t,n,i,r,m,u);for(let e=0;e<6;e++)null!==u[e]&&(null===h[e]&&(h[e]=new a.L,c[e]=(new o.O).executeMany(h[e],s,this.m_progressTracker,2)),h[e].tick(v(u[e])),c[e].tock())}processInGrid(e,t,s,n,i,o,m){const a=.01,l=this.insertGeodeticPointsAlongGrid(t,i,a);for(let e=0;e<6;e++){if(n[e])continue;const _=i[e].clone();_.inflateCoords(a,a);const f=(0,r.K)(t,_),d=(0,r.c)(null,f,!1).total();let g=(0,u.c)(l,_,d,Number.NaN,this.m_progressTracker);if(null!==g&&!g.isEmpty()){if(g===l&&(g=g.clone()),null===o[e]){const t=new h.P;e<3?t.setCoords(0,1):t.setCoords(0,-1);const s=new h.P;s.setAdd(i[e].getCenter(),t),o[e]=S(this.m_gcs,s)}o[e].project(g);const t=(0,r.t)(null,g,!0);g=(0,c.p)(g,t,s,!0,-1,this.m_progressTracker,0,!1),m[e]=g}}}insertGeodeticPointsAlongGrid(e,t,s){const n=r.a.construct(t[3].xmin,t[3].ymin,t[2].xmax,t[2].ymax),i=(0,a.l)(this.m_gcs,n,e,!0,this.m_progressTracker),o=new r.b,m=o.addGeometry(i);return(0,a.m)(o,m,this.m_gcs,0,2,!0,t[0].xmax+s),(0,a.m)(o,m,this.m_gcs,0,2,!0,t[1].xmax+s),(0,a.m)(o,m,this.m_gcs,0,2,!1,t[1].ymin+s),0!==s&&((0,a.m)(o,m,this.m_gcs,0,2,!0,t[0].xmax-s),(0,a.m)(o,m,this.m_gcs,0,2,!0,t[1].xmax-s),(0,a.m)(o,m,this.m_gcs,0,2,!1,t[1].ymin-s)),o.getGeometry(m)}initializeGrid(e,t){for(let t=0;t<6;t++)e[t]=!1;t[0].setCoords({xmin:-this.m_gcs180,ymin:0,xmax:-this.m_gcs60,ymax:this.m_gcs90}),t[1].setCoords({xmin:-this.m_gcs60,ymin:0,xmax:this.m_gcs60,ymax:this.m_gcs90}),t[2].setCoords({xmin:this.m_gcs60,ymin:0,xmax:this.m_gcs180,ymax:this.m_gcs90}),t[3].setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:-this.m_gcs60,ymax:0}),t[4].setCoords({xmin:-this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs60,ymax:0}),t[5].setCoords({xmin:this.m_gcs60,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:0})}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t,s,n,i,r){const o=e[0],m=e.at(-1),c=o.y<m.y?o.y:m.y,u=o.y>m.y?o.y:m.y,l=a.p.q(this.m_a,this.m_eSquared,c),_=a.p.q(this.m_a,this.m_eSquared,u);if(this.m_q90-(l+t+this.m_absDistance)>.001&&this.m_q90+(_-t-this.m_absDistance)>.001)return!1;const f=s-h.q,d=n+h.q,g=f-Math.PI,x=f+Math.PI,y=d+Math.PI,w=[Number.NaN],C=[Number.NaN],S=[Number.NaN],v=[Number.NaN];let D=!1;if(b(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,f,g,m,d,w,C),b(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,y,d,o,g,S,v),(d<w[0]&&w[0]<y||d<C[0]&&C[0]<y)&&(D=!0),D||(g<S[0]&&S[0]<f||g<v[0]&&v[0]<f)&&(D=!0),!D&&i)return!1;const I=[];for(let t=e.length-1;t>=0;t--)I.push(e[t]);r.setEmpty(),r.addPathPoint2D(null,0,!0);let G=0;G=p(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,e,f,d,i,G,r),G=P(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,m,d,y,this.m_cornerStep,i,G,r,w[0],C[0]),G=p(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,this.m_curveType,I,y,x,i,G,r),G=P(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,o,g,f,this.m_cornerStep,i,G,r,S[0],v[0]);let q=!1;return i||(q=this.checkAndPrepForPole(r)),D||q}bufferPoint2D(e,t,s){s.setEmpty(),s.addPathPoint2D(null,0,!0),P(this.m_a,this.m_eSquared,this.m_rpu,this.m_absDistance,e,-this.m_cornerStep,2*Math.PI,this.m_cornerStep,t,0,s);let n=!1;return t||(n=this.checkAndPrepForPole(s)),n}checkAndPrepForPole(e){const t=this.checkAndPrepForPoleTouch(e),s=this.checkAndPrepForPoleWrap(e);return t||s}checkAndPrepForPoleTouch(e){const t=new r.a;return e.queryEnvelope(t),!(!(0,a.P)(t.ymax,this.m_gcs90)&&!(0,a.P)(t.ymin,-this.m_gcs90)||(this.prepPoleTouch(e),0))}checkAndPrepForPoleWrap(e){const t=e.getXY(0),s=e.getXY(e.getPointCount()-1);return Math.abs(t.x-s.x)>this.m_gcs180?(this.prepSinglePoleWrap(e),!0):this.checkAndPrepForDoublePoleWrap(e)}checkAndPrepForDoublePoleWrap(e){return e.calculateArea2D()<0&&(this.prepDoublePoleWrap(e),!0)}prepPoleTouch(e){const t=new r.g;t.insertPath2D(-1,null,0,0,!0);const s=e.getPathStart(0),n=e.getPathEnd(0),i=n-s;let o=-1;for(o=s;o<n;o++){const t=e.getXY(o),s=(0,a.P)(t.y,this.m_gcs90),n=(0,a.P)(t.y,-this.m_gcs90);if(!s&&!n)break}let m=o,c=!1,u=Number.NaN;do{const n=e.getXY(m),r=(0,a.P)(n.y,this.m_gcs90),o=(0,a.P)(n.y,-this.m_gcs90),l=s+(m+1-s)%i;if(r||o){let s=h.P.construct(u,n.y);t.insertPoint2D(0,-1,s);const i=e.getXY(l),r=(0,a.P)(i.y,this.m_gcs90),o=(0,a.P)(i.y,-this.m_gcs90);r||o||(s=h.P.construct(i.x,n.y),c?t.setXY(t.getPointCount()-1,s):t.insertPoint2D(0,-1,s)),c=!0}else t.insertPoint2D(0,-1,n),u=n.x,c=!1;m=l}while(m!==o);e.setEmpty(),e.add(t,!1)}prepSinglePoleWrap(e){const t=new r.g,s=new r.g,n=new h.T,i=e.getXY(e.getPathStart(0)),o=e.getXY(e.getPathEnd(0)-1),m=this.m_gcs360,c=this.m_gcs180,l=new r.a;l.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const _=new r.a;e.queryEnvelope(_);const f=Math.ceil(_.width()/m);let d,g;i.x>o.x?(d=-m,g=this.m_gcs90):(d=m,g=-this.m_gcs90),n.setShiftCoords(d,0),t.addPath(e,0,!0),s.add(t,!1);const p=new r.P;for(let e=0;e<f;e++)s.applyTransformation(n),s.getPointByVal(0,p),t.lineToPoint(p),t.addSegmentsFromPath(s,0,0,s.getSegmentCount()-1,!1);const P=t.getXY(0),b=t.getXY(t.getPointCount()-1);P.y=g,b.y=g,t.lineTo(b);const x=new h.P;for(x.setCoordsPoint2D(b),x.x-=.5*d;Math.abs(x.x-P.x)>c;)t.lineTo(x),x.x-=.5*d;t.lineTo(P);const y=l.getCenterX(),w=new r.a;t.queryEnvelope(w);let C=0;const S=w.getCenter().x;S-y>c?C=-Math.ceil((S-y-c)/m):y-S>c&&(C=Math.ceil((y-S-c)/m)),0!==C&&(n.setShiftCoords(C*m,0),t.applyTransformation(n));const v=new r.b,D=v.addGeometry(t);(0,a.m)(v,D,this.m_gcs,0,2,!0,l.xmin),(0,a.m)(v,D,this.m_gcs,0,2,!0,l.xmax);const I=v.getGeometry(D),G=(0,r.K)(I,l);G.inflateCoords(0,1);const q=(0,r.c)(null,G,!0).total(),T=(0,u.c)(I,l,q,Number.NaN,this.m_progressTracker);e.setEmpty(),e.add(T,!1)}prepDoublePoleWrap(e){const t=this.m_gcs360,s=this.m_gcs180,n=new r.a;n.setCoords({xmin:-this.m_gcs180,ymin:-this.m_gcs90,xmax:this.m_gcs180,ymax:this.m_gcs90});const i=n.getCenter().x,o=new r.a;e.queryPathEnvelope(0,o);let m,c=0,l=o.getCenter().x;if(l-i>s?c=-Math.ceil((l-i-s)/t):i-l>s&&(c=Math.ceil((i-l-s)/t)),0!==c){const s=new h.T;s.setShiftCoords(c*t,0),e.getImpl().applyTransformationToPath(s,0),e.queryPathEnvelope(0,o),l=o.getCenter().x}const _=new r.a;n.containsExclusiveEnvelope(o)?(m=!1,_.setCoords({env2D:n})):(m=!0,_.setCoords({env2D:n}),_.xmin-=t,_.xmax+=t);let f=e.createInstance();f.addPathPoint2D(null,0,!0);const d=new h.P;if(d.setCoords(_.xmin,_.ymin),f.insertPoint2D(0,-1,d),d.setCoords(_.xmin,_.ymax),f.insertPoint2D(0,-1,d),d.setCoords(.5*(_.xmin+_.xmax),_.ymax),f.insertPoint2D(0,-1,d),d.setCoords(_.xmax,_.ymax),f.insertPoint2D(0,-1,d),d.setCoords(_.xmax,_.ymin),f.insertPoint2D(0,-1,d),d.setCoords(.5*(_.xmin+_.xmax),_.ymin),f.insertPoint2D(0,-1,d),m){f.addPath(e,0,!0);const s=new h.T;l<i?s.setShiftCoords(t,0):s.setShiftCoords(-t,0),e.getImpl().applyTransformationToPath(s,0),f.addPath(e,0,!0);const o=new r.b,m=o.addGeometry(f);(0,a.m)(o,m,this.m_gcs,0,2,!0,n.xmin),(0,a.m)(o,m,this.m_gcs,0,2,!0,n.xmax),f=o.getGeometry(m);const c=(0,r.K)(f,n);c.inflateCoords(0,1);const _=(0,r.c)(null,c,!0).total();f=(0,u.c)(f,n,_,Number.NaN,this.m_progressTracker)}else f.addPath(e,0,!0);e.setEmpty(),e.add(f,!1)}setMinCornerStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new h.P;s.setCoords(0,10*this.m_rpu);const n=0;let i=45*this.m_rpu;const r=(0,m.b)(e,new h.S(new a.o,new a.o),!1),o=(0,m.b)(e,new h.S(new a.o,new a.o),!1),c=(0,m.b)(e,new h.S(new a.o,new a.o),!1),u=(0,m.b)(e,new h.S(new a.o,new a.o),!1),l=new h.P,_=new h.P,f=new h.P,d=new h.P;for(a.q.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,n,r.at(0),r.at(1)),l.setCoords(r.at(0).val,r.at(1).val),a.q.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,i,o.at(0),o.at(1)),_.setCoords(o.at(0).val,o.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const r=.5*(n+i);a.q.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,r,c.at(0),c.at(1)),f.setCoords(c.at(0).val,c.at(1).val);const h=(0,m.b)(e,new a.o,!1),g=(0,m.b)(e,new a.o,!1);a.q.geodeticDistance(this.m_a,this.m_eSquared,l.x,l.y,_.x,_.y,h,g,null,2),a.q.geodeticCoordinate(this.m_a,this.m_eSquared,l.x,l.y,.5*h.val,g.val,u.at(0),u.at(1),2),d.setCoords(u.at(0).val,u.at(1).val);const p=(0,m.b)(e,new a.o,!1);if(a.q.geodeticDistance(this.m_a,this.m_eSquared,f.x,f.y,d.x,d.y,p,null,null,2),p.val<=this.m_convergenceOffset)break;i*=.9,a.q.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,i,o.at(0),o.at(1)),_.setCoords(o.at(0).val,o.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{(0,m.c)(e)}}const g=i-n,p=2*Math.PI/Math.ceil(2*Math.PI/g);this.m_cornerStep=p}catch(t){e.error=t,e.hasError=!0}finally{(0,m.c)(e)}}setMinSegmentStep(){const e={stack:[],error:void 0,hasError:!1};try{let t=Math.min(Math.PI*this.m_a-this.m_absDistance,this.m_absDistance);t=Math.min(t,.125*this.m_a*Math.PI);const s=new h.P,n=new h.P;s.setCoords(0,10*this.m_rpu),n.setCoords(10*this.m_rpu,10*this.m_rpu);const i=(0,m.b)(e,new a.o,!1),r=(0,m.b)(e,new a.o,!1),o=(0,m.b)(e,new a.o,!1);a.q.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,o,i,r,this.m_curveType);const c=(0,m.b)(e,new h.S(new a.o,new a.o),!1),u=(0,m.b)(e,new h.S(new a.o,new a.o),!1),l=new h.P,_=(0,m.b)(e,new a.o,!1),f=(0,m.b)(e,new h.S(new a.o,new a.o),!1),d=(0,m.b)(e,new h.S(new a.o,new a.o),!1),g=(0,m.b)(e,new h.S(new a.o,new a.o),!1),p=(0,m.b)(e,new h.S(new a.o,new a.o),!1),P=new h.P,b=new h.P,x=new h.P,y=new h.P,w=0;let C=1;const S=i.val,v=r.val,D=S-.5*Math.PI,I=v+.5*Math.PI,G=o.val;for(a.q.geodesicCoordinate(this.m_a,this.m_eSquared,s.x,s.y,t,D,f.at(0),f.at(1)),P.setCoords(f.at(0).val,f.at(1).val),a.q.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,t,I,d.at(0),d.at(1)),b.setCoords(d.at(0).val,d.at(1).val);;){const e={stack:[],error:void 0,hasError:!1};try{const i=.5*(w+C);a.q.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,i*G,S,c.at(0),c.at(1),this.m_curveType),l.setCoords(c.at(0).val,c.at(1).val),a.q.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,l.x,l.y,null,null,_,this.m_curveType);const r=_.val+.5*Math.PI;a.q.geodesicCoordinate(this.m_a,this.m_eSquared,l.x,l.y,t,r,g.at(0),g.at(1)),x.setCoords(g.at(0).val,g.at(1).val);const o=(0,m.b)(e,new a.o,!1),h=(0,m.b)(e,new a.o,!1);a.q.geodeticDistance(this.m_a,this.m_eSquared,P.x,P.y,b.x,b.y,o,h,null,2),a.q.geodeticCoordinate(this.m_a,this.m_eSquared,P.x,P.y,.5*o.val,h.val,p.at(0),p.at(1),2),y.setCoords(p.at(0).val,p.at(1).val);const f=(0,m.b)(e,new a.o,!1);if(a.q.geodeticDistance(this.m_a,this.m_eSquared,x.x,x.y,y.x,y.y,f,null,null,2),f.val<=this.m_convergenceOffset)break;{const e={stack:[],error:void 0,hasError:!1};try{C*=.9,a.q.geodeticCoordinate(this.m_a,this.m_eSquared,s.x,s.y,C*G,S,u.at(0),u.at(1),this.m_curveType),n.setCoords(u.at(0).val,u.at(1).val);const i=(0,m.b)(e,new a.o,!1);a.q.geodeticDistance(this.m_a,this.m_eSquared,s.x,s.y,n.x,n.y,null,null,i,this.m_curveType);const r=i.val+.5*Math.PI;a.q.geodesicCoordinate(this.m_a,this.m_eSquared,n.x,n.y,t,r,d.at(0),d.at(1)),b.setCoords(d.at(0).val,d.at(1).val)}catch(t){e.error=t,e.hasError=!0}finally{(0,m.c)(e)}}}catch(t){e.error=t,e.hasError=!0}finally{(0,m.c)(e)}}let q=C*G;q>1e5&&(q=1e5),this.m_segmentStep=q}catch(t){e.error=t,e.hasError=!0}finally{(0,m.c)(e)}}setConvergenceOffset(){let e;e=this.m_absDistance>5e4?100:this.m_absDistance>1e4?10:1,this.m_absDistance/e<500&&(e=this.m_absDistance/500),e<.01&&(e=.01),this.m_convergenceOffset=e}}function g(e,t,s,n,o,m,c){if(e.isEmpty())return new r.g({vd:e.getDescription()});let u=e;if((0,i.n)(u)){const e=10*t.getTolerance(0);u=(new f.O).execute(u,0,e,0,c,12e3)}const l=new d(c);l.m_sr=t,l.m_gcs=t.getGCS(),l.m_transform=(0,a.e)(t,l.m_gcs,null);const _=(0,a.s)();l.m_gcs.querySpheroidData(_);const g=new r.a;u.queryEnvelope(g),l.m_a=_.majorSemiAxis,l.m_eSquared=_.e2,l.m_rpu=l.m_gcs.getUnit().getUnitToBaseFactor(),l.m_gcs90=.5*Math.PI/l.m_rpu,l.m_gcs180=Math.PI/l.m_rpu,l.m_gcs360=2*Math.PI/l.m_rpu,l.m_gcs60=l.m_gcs360/6,l.m_q90=a.p.q90(l.m_a,l.m_eSquared),l.m_ellipticToGeodesicMaxRatio=.5*l.m_a*Math.PI/l.m_q90;const p=l.m_gcs.getTolerance(0);l.m_radTolerance=p*l.m_rpu,4===s?(l.m_curveType=2,l.m_bShapePreserving=!0):(l.m_curveType=s,l.m_bShapePreserving=!1),l.m_distance=n,l.m_absDistance=Math.abs(n),Number.isNaN(o)||o<=0?l.setConvergenceOffset():l.m_convergenceOffset=Math.max(o,.001),l.m_convergenceOffset/=m;let P,b=u.getGeometryType();if((0,i.d)(b)){const e=new r.h({vd:u.getDescription()});e.addSegment(u,!0),P=e,b=i.G.enumPolyline}else if(b===i.G.enumEnvelope){const e=u,t=new r.a;e.queryEnvelope(t);const s=(0,r.k)((0,r.c)(l.m_sr,g,!0));if(t.minDimension()<=s)if(0===t.maxDimension()){const t=new r.P({vd:u.getDescription()});e.getCenter(t),P=t,b=i.G.enumPoint}else{const t=new r.h({vd:u.getDescription()});t.addEnvelope(e,!1),P=t,b=i.G.enumPolyline}else{const t=new r.g({vd:u.getDescription()});t.addEnvelope(e,!1),P=t,b=i.G.enumPolygon}}else P=u;if(l.setMinCornerStep(),(0,i.f)(b)||l.setMinSegmentStep(),l.m_absDistance<=.5*l.m_convergenceOffset)return b!==i.G.enumPolygon?new r.g({vd:P.getDescription()}):l.m_bShapePreserving?P:(0,a.f)(P,l.m_sr,l.m_curveType,l.m_segmentStep,-1,c);if(l.m_distance<0&&b!==i.G.enumPolygon)return new r.g({vd:P.getDescription()});if(l.m_bShapePreserving&&(0,i.e)(b)){const e=(0,a.f)(P,t,4,Number.NaN,l.m_convergenceOffset,c);P=(new a.g).execute(e,l.m_transform,c)}else P=(new a.g).execute(P,l.m_transform,c);if(P=(0,a.h)(P,l.m_gcs),P.isEmpty())return new r.g({vd:P.getDescription()});!l.m_bShapePreserving&&(0,i.e)(b)&&(P=(0,a.n)(l.m_rpu,P)),P=function(e,t){const s=e.getGeometryType();let n;if(n=(0,i.e)(s)?e.getPathCount():s===i.G.enumMultiPoint?e.getPointCount():1,1===n)return e;const o=[],m=[];for(let a=0;a<n;a++){o.push(a);const n=new h.P;if((0,i.e)(s)){const t=new r.a;e.queryPathEnvelope(a,t),n.assign(t.getCenter())}else n.assign(e.getXY(a));const c=t.toGeohash(n);m.push(c)}o.sort(((e,t)=>m[e]<m[t]?-1:m[e]>m[t]?1:0));const a=e.createInstance();for(let t=0;t<n;t++){const n=o[t];(0,i.e)(s)?a.addPath(e,n,!0):a.addPoints(e,n,n+1)}return a}(P,l.m_gcs);let x=new r.g;switch(b){case i.G.enumPolygon:x=l.bufferPolygon(P);break;case i.G.enumPolyline:x=l.bufferPolyline(P);break;case i.G.enumMultiPoint:x=l.bufferMultiPoint(P);break;case i.G.enumPoint:x=l.bufferPoint(P);break;default:(0,i.o)("")}const y=(new a.g).execute(x,l.m_transform.getInverse(),c);return y.mergeVertexDescription(P.getDescription()),y}function p(e,t,s,n,i,r,o,c,u,l,_){const f={stack:[],error:void 0,hasError:!1};try{const d=new h.P;d.setNAN(),u||_.getPointCount()>0&&(d.setCoordsPoint2D(_.getXY(_.getPointCount()-1)),d.scale(s));const g=(0,m.b)(f,new a.o,!1),p=(0,m.b)(f,new h.S(new a.o,new a.o),!1),P=new h.P,b=new h.P,y=r.at(-1),w=1/s;for(let s=0;s<r.length;s++){const m=r[s];let h;0===s?h=o:s===r.length-1?h=c:(a.q.geodeticDistance(e,t,y.x,y.y,m.x,m.y,null,null,g,i),h=g.val-.5*Math.PI),a.q.geodesicCoordinate(e,t,m.x,m.y,n,h,p.at(0),p.at(1)),u?b.setCoords(p.at(0).val,p.at(1).val):(P.setCoords(p.at(0).val,p.at(1).val),l=x(m.x,P.x,d.x,l),b.setCoords(l+P.x,P.y),d.setCoordsPoint2D(b)),b.scale(w),_.insertPoint2D(0,-1,b)}return l}catch(e){f.error=e,f.hasError=!0}finally{(0,m.c)(f)}}function P(e,t,s,n,i,r,o,c,u,l,_,f=Number.NaN,d=Number.NaN){const g={stack:[],error:void 0,hasError:!1};try{if(o-r<c)return l;const p=(0,m.b)(g,new h.S(new a.o,new a.o),!1),P=new h.P,b=new h.P,y=new h.P;b.setNAN(),u||_.getPointCount()>0&&(b.setCoordsPoint2D(_.getXY(_.getPointCount()-1)),b.scale(s));let w=Math.ceil(r/c),C=w++*c;C===r&&(C=w++*c);let S=r;const v=1/s;for(;C<o+c&&(S<f&&f<C?(C=f,w--):S<d&&d<C&&(C=d,w--),!(C>=o));)a.q.geodesicCoordinate(e,t,i.x,i.y,n,C,p.at(0),p.at(1)),u?y.setCoords(p.at(0).val,p.at(1).val):(P.setCoords(p.at(0).val,p.at(1).val),l=x(i.x,P.x,b.x,l),y.setCoords(l+P.x,P.y),b.setCoordsPoint2D(y)),y.scale(v),_.insertPoint2D(0,-1,y),S=C,C=w++*c;return l}catch(e){g.error=e,g.hasError=!0}finally{(0,m.c)(g)}}function b(e,t,s,n,i,r,o,c,u,l,_){const f={stack:[],error:void 0,hasError:!1};try{const s=new h.P,d=new h.P,g=(0,m.b)(f,new h.S(new a.o,new a.o),!1);a.q.geodesicCoordinate(e,t,i.x,i.y,n,r,g.at(0),g.at(1)),s.setCoords(g.at(0).val,g.at(1).val),a.q.geodesicCoordinate(e,t,i.x,i.y,n,o,g.at(0),g.at(1)),d.setCoords(g.at(0).val,g.at(1).val);const p=(0,m.b)(f,new a.o,!1);for(a.q.geodeticDistance(e,t,c.x,c.y,s.x,s.y,null,p,null,0),l[0]=p.val,a.q.geodeticDistance(e,t,c.x,c.y,d.x,d.y,null,p,null,0),_[0]=p.val;l[0]<=_[0];)l[0]+=h.p;for(;l[0]>_[0];)l[0]-=h.p;for(;l[0]>=u;)l[0]-=h.p,_[0]-=h.p;for(;l[0]<u;)l[0]+=h.p,_[0]+=h.p}catch(e){f.error=e,f.hasError=!0}finally{(0,m.c)(f)}}function x(e,t,s,n){if(Number.isNaN(s)){for(;n+t-e>Math.PI;)n-=h.p;for(;e-(n+t)>Math.PI;)n+=h.p;return n}return n+t-s>Math.PI?n-=h.p:s-(n+t)>Math.PI&&(n+=h.p),n}function y(e,t,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const h=s[0],c=s.at(-1),u=(0,m.b)(o,new a.o,!1),l=(0,m.b)(o,new a.o,!1),_=(0,m.b)(o,new a.o,!1);a.q.greatEllipticDistance(e,t,i.x,i.y,h.x,h.y,u,null,null),a.q.greatEllipticDistance(e,t,i.x,i.y,c.x,c.y,l,null,null),a.q.greatEllipticDistance(e,t,h.x,h.y,c.x,c.y,_,null,null);let f=Math.min(u.val,l.val)+_.val,d=f+n;if(d<r)return!0;const g=(0,m.b)(o,new a.o,!1);f=Math.max(u.val,l.val);for(let n=1;n<s.length-1;n++){const r=s[n];a.q.greatEllipticDistance(e,t,i.x,i.y,r.x,r.y,g,null,null),g.val>f&&(f=g.val)}return d=f+n,d<r}catch(e){o.error=e,o.hasError=!0}finally{(0,m.c)(o)}}function w(e,t,s,n,i,r,o,m){let c;if(n.length%2==0){const e=n.length>>1,t=n[e],s=n[e-1];c=h.P.lerp(t,s,.5)}else c=n[n.length-1>>1].clone();const u=c.clone(),l=(0,a.t)(e,t,u,75/180*Math.PI);return!!y(e,t,n,i,u,l)&&(null!==r&&(r.setCoordsPoint2D(c),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(u),null!==m&&(m[0]=l),!0)}function C(e,t,s,n,i,r){const o={stack:[],error:void 0,hasError:!1};try{if(n>=r)return!1;const h=(0,m.b)(o,new a.o,!1);return a.q.greatEllipticDistance(e,t,i.x,i.y,s.x,s.y,h,null,null),h.val+n<r}catch(e){o.error=e,o.hasError=!0}finally{(0,m.c)(o)}}function S(e,t){return new a.G(e,t)}function v(e){return(0,r.i)(e,0)||(0,r.N)(e,0),e}class D{constructor(e){this.m_bRunningInGnomonic=!1,this.m_bNeedsSimplify=!1,this.m_gnomonic=null,this.m_gnomonicCenterRad=new h.P,this.m_minGnomonicRadius=Number.NaN,this.m_progressTracker=e}isRunningInGnomonic(){return this.m_bRunningInGnomonic}needsSimplify(){return this.m_bNeedsSimplify}getGnomonic(){return this.m_gnomonic}}class I extends D{constructor(e,t,s){super(e.m_progressTracker),this.m_segIter=null,this.m_bNextSegmentCannotJoin=!1,this.m_currentDensifiedDelta=[0],this.m_currentBufferedDelta=0,this.m_lastAzimuth=0,this.m_startAzimuth=[0],this.m_endAzimuth=[0],this.m_numWinds=0,this.m_debugCounter=0,this.m_bufferHelper=new r.g,this.m_densifiedPoints=[],this.m_bufferer=e,this.m_multiPath=t,this.m_densified=s,this.m_bNeedsSimplify=!0;const n=new r.a;this.m_multiPath.queryEnvelope(n);const i=n.getCenter(),o=i.clone();o.scale(this.m_bufferer.m_rpu),this.m_gnomonic=S(this.m_bufferer.m_gcs,i),this.m_gnomonicCenterRad=o.clone(),this.m_minGnomonicRadius=(0,a.t)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,o,75/180*Math.PI)}next(){let e;if(this.m_bNextSegmentCannotJoin)return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e;if(null===this.m_segIter){if(this.m_segIter=this.m_multiPath.getImpl().querySegmentIterator(),!this.m_segIter.nextPath())return null;null!==this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}if(!this.m_segIter.hasNextSegment()){if(!this.m_segIter.nextPath())return null;null!=this.m_densified&&this.m_densified.addPathPoint2D(null,0,!0)}let t=null;this.m_currentBufferedDelta=0,this.m_currentDensifiedDelta=[0],this.m_numWinds=0,this.m_lastAzimuth=Number.NaN,this.m_bNextSegmentCannotJoin=!1,this.m_densifiedPoints.length=0;let s=0;const n=new h.P,i=new h.P;for(;this.m_segIter.hasNextSegment()&&this.m_numWinds<16;){const e=this.m_segIter.nextSegment();if(n.setCoordsPoint2D(e.getStartXY()),i.setCoordsPoint2D(e.getEndXY()),n.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),(0,a.u)(n,i))n.x=i.x;else if((0,a.v)(n,i))i.x=n.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),r=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<r&&(e=this.m_multiPath.isClosedPath(s)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(s)?r:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),(0,a.v)(t,n)&&(n.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),(0,a.u)(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0;const o=(0,a.w)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,n,i,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta);if(0===s)this.m_bRunningInGnomonic=this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(this.m_densifiedPoints));else if(this.m_bRunningInGnomonic){if(!this.isSegmentBufferInCurrentGnomonic(this.m_densifiedPoints)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}}else if(w(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_densifiedPoints,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,null,null,null)){this.m_segIter.previousSegment(),this.m_segIter.previousSegment(),this.m_segIter.nextSegment();break}if(0===o||(0,a.x)(n,i)?(this.m_bufferHelper.setEmpty(),this.m_bufferer.bufferPoint2D(n,this.m_bRunningInGnomonic,this.m_bufferHelper),this.m_bNextSegmentCannotJoin=!0):(this.m_bufferHelper.setEmpty(),this.m_bNextSegmentCannotJoin=this.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(o,this.m_bufferHelper)),this.m_bNextSegmentCannotJoin){this.m_segIter.previousSegment(),this.m_segIter.hasPreviousSegment()?(this.m_segIter.previousSegment(),this.m_segIter.nextSegment()):this.m_segIter.resetToFirstSegment(),null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0);break}null!=this.m_densified&&this.m_densified.insertPointsFromPoints(this.m_densified.getPathCount()-1,-1,this.m_densifiedPoints,0,this.m_densifiedPoints.length-1,!0),null===t&&(t=new r.g,t.addPathPoint2D(null,0,!0)),this.addJoinAndBufferLeftSide(t),s++}if(this.m_currentDensifiedDelta=[0],s>0){const e=this.m_segIter.getStartPointIndex(),r=this.m_segIter.getPathIndex();for(;s>0;){if(this.m_segIter.previousSegment(),n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),i.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getEndPointIndex())),n.scale(this.m_bufferer.m_rpu),i.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic)if((0,a.u)(n,i))n.x=i.x;else if((0,a.v)(n,i))i.x=n.x;else{let e=-1,t=-1;const s=this.m_segIter.getPathIndex(),r=this.m_multiPath.getPathStart(s),o=this.m_multiPath.getPathEnd(s);if(e=this.m_segIter.getStartPointIndex()-1,t=this.m_segIter.getEndPointIndex()+1,e<r&&(e=this.m_multiPath.isClosedPath(s)?o-1:-1),t>o-1&&(t=this.m_multiPath.isClosedPath(s)?r:-1),-1!==e){const t=this.m_multiPath.getXY(e);t.scale(this.m_bufferer.m_rpu),(0,a.v)(t,n)&&(n.x=t.x)}if(-1!==t){const e=this.m_multiPath.getXY(t);e.scale(this.m_bufferer.m_rpu),(0,a.u)(i,e)&&(i.x=e.x)}}this.m_densifiedPoints.length=0,(0,a.w)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_curveType,i,n,this.m_bufferer.m_segmentStep,Number.NaN,this.m_bufferer.m_radTolerance,this.m_startAzimuth,this.m_endAzimuth,this.m_densifiedPoints,this.m_currentDensifiedDelta),this.addJoinAndBufferLeftSide(t),s--}return n.setCoordsPoint2D(this.m_multiPath.getXY(this.m_segIter.getStartPointIndex())),n.scale(this.m_bufferer.m_rpu),this.m_currentBufferedDelta=P(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,n,this.m_lastAzimuth+.5*Math.PI,this.m_lastAzimuth+1.5*Math.PI,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,t),this.m_segIter.resetToVertex(e,r),this.m_segIter.nextSegment(),t}return this.m_bNextSegmentCannotJoin=!1,this.m_segIter.nextSegment(),e=this.m_bufferHelper.clone(),e}isSegmentBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&y(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new h.P,s=new h.P,n=[0];return w(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=S(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(e,t){return this.m_bufferer.checkAndPrepSegmentForCrossingAzimuthsOrPoleWrap(this.m_densifiedPoints,e,this.m_startAzimuth[0],this.m_endAzimuth[0],this.m_bRunningInGnomonic,t)}addJoinAndBufferLeftSide(e){const t=this.m_densifiedPoints[0];let s=Number.NaN,n=this.m_startAzimuth[0]-h.q;const i=this.m_endAzimuth[0]+h.q;let r=!1;if(!Number.isNaN(this.m_lastAzimuth)){this.m_lastAzimuth>=this.m_startAzimuth[0]?(s=this.m_lastAzimuth+h.q,n=s+Math.PI-(this.m_lastAzimuth-this.m_startAzimuth[0])):(s=this.m_lastAzimuth+h.q,n=s+Math.PI-(h.p-(this.m_startAzimuth[0]-this.m_lastAzimuth))),r=!(this.m_lastAzimuth>=this.m_startAzimuth[0]&&this.m_lastAzimuth-this.m_startAzimuth[0]<=Math.PI||this.m_lastAzimuth<this.m_startAzimuth[0]&&this.m_startAzimuth[0]-this.m_lastAzimuth>=Math.PI);let i=!1;if(Math.abs(n-s)<=.5*this.m_bufferer.m_cornerStep&&(r||(i=!0)),i){if(e.removePointFromPath(0,e.getPointCount()-1),!this.m_bRunningInGnomonic){const t=new h.P;t.setCoordsPoint2D(e.getXY(e.getPointCount()-1)),t.scale(this.m_bufferer.m_rpu),t.x-this.m_currentBufferedDelta<-Math.PI?this.m_currentBufferedDelta-=h.p:t.x-this.m_currentBufferedDelta>Math.PI&&(this.m_currentBufferedDelta+=h.p)}n=.5*(n+s)}else if(r){const s=new h.P;s.setCoordsPoint2D(t),s.scale(1/this.m_bufferer.m_rpu),e.insertPoint2D(0,-1,s)}else P(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_densifiedPoints[0],s,n,this.m_bufferer.m_cornerStep,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e)}this.m_startAzimuth[0]!==this.m_lastAzimuth&&this.m_numWinds++,p(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,this.m_bufferer.m_absDistance,this.m_bufferer.m_curveType,this.m_densifiedPoints,n,i,this.m_bRunningInGnomonic,this.m_currentBufferedDelta,e),this.m_lastAzimuth=this.m_endAzimuth[0]}}class G extends D{constructor(e,t){super(e.m_progressTracker),this.m_pointIndex=-1,this.m_bufferer=e,this.m_multiPoint=t,this.m_bNeedsSimplify=!1;const s=new r.a;this.m_multiPoint.queryEnvelope(s);const n=s.getCenter(),i=n.clone();i.scale(this.m_bufferer.m_rpu),this.m_gnomonic=S(this.m_bufferer.m_gcs,n),this.m_gnomonicCenterRad=i.clone(),this.m_minGnomonicRadius=(0,a.t)(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,i,75/180*Math.PI)}next(){if(this.m_bNeedsSimplify=!1,++this.m_pointIndex===this.m_multiPoint.getPointCount())return null;const e=this.m_multiPoint.getXY(this.m_pointIndex);e.scale(this.m_bufferer.m_rpu),this.m_bRunningInGnomonic=this.isPointBufferInCurrentGnomonic(e),this.m_bRunningInGnomonic||(this.m_bRunningInGnomonic=this.tryUpdateGnomonic(e));const t=new r.g,s=this.m_bufferer.bufferPoint2D(e,this.m_bRunningInGnomonic,t);return this.m_bNeedsSimplify=s,t}isPointBufferInCurrentGnomonic(e){return null!==this.m_gnomonic&&C(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,this.m_gnomonicCenterRad,this.m_minGnomonicRadius)}tryUpdateGnomonic(e){const t=new h.P,s=new h.P,n=[0];return function(e,t,s,n,i,r,o,m){const h=(0,a.t)(e,t,n,75/180*Math.PI);return!!C(e,t,n,i,n,h)&&(null!==r&&(r.setCoordsPoint2D(n),r.scale(1/s)),null!==o&&o.setCoordsPoint2D(n),null!==m&&(m[0]=h),!0)}(this.m_bufferer.m_a,this.m_bufferer.m_eSquared,this.m_bufferer.m_rpu,e,this.m_bufferer.m_absDistance*this.m_bufferer.m_ellipticToGeodesicMaxRatio,t,s,n)?(this.m_gnomonicCenterRad.setCoordsPoint2D(s),this.m_minGnomonicRadius=n[0],this.m_gnomonic=S(this.m_bufferer.m_gcs,t),!0):(this.m_gnomonic=null,!1)}}class q{getOperatorType(){return 10110}supportsCurves(){return!0}accelerateGeometry(e,t,s){return!1}canAccelerateGeometry(e){return!1}executeMany(e,t,s,n,i,r,m,a){if(m){const m=new T(e,t,s,n,i,!1,r,a);return(new o.O).executeMany(m,t,a)}return new T(e,t,s,n,i,!1,r,a)}execute(e,t,s,r,o,m,a){const h=new n.S([e]),c=[r],u=this.executeMany(h,t,s,c,o,!1,m,a).next();return u||(0,i.a)("geodesic buffer null output"),u}}class T extends n.G{constructor(e,t,s,n,o,m,a,h){super(),this.m_currentUnionEnvelope2D=new r.a,this.m_index=-1,this.m_dindex=-1,this.m_progressTracker=h,m&&(0,i.k)(""),t||(0,i.t)(""),0===t.getCoordinateSystemType()&&(0,i.t)(""),this.m_inputGeoms=e,this.m_spatialReference=t,this.m_curveType=s,this.m_distances=n,this.m_convergenceOffset=o,this.m_bOutlineOnly=m,this.m_bUnion=a}next(){let e;for(;e=this.m_inputGeoms.next();)return(0,i.b)(e),this.m_index=this.m_inputGeoms.getGeometryID(),this.m_dindex+1<this.m_distances.length&&this.m_dindex++,this.geodesicBuffer(e,this.m_distances[this.m_dindex]);return null}getGeometryID(){return this.m_index}tock(){return!0}getRank(){return 1}geodesicBuffer(e,t){return function(e,t,s,n,r,o){n<Number.MAX_VALUE&&n>-Number.MAX_VALUE||(0,i.t)("Geodesic_bufferer.buffer - bad distance"),(0,i.b)(e);const m=_(e),a=m.getGeometryType();if((0,i.i)(a)){const e=m.getPointCount(),h=8e6;if(Math.abs(n)>h&&(e>50||a!==i.G.enumMultiPoint&&4===s&&e>2)){let e=m;const i=n>0?1:-1,a=7e6;let c=n,u=1;do{u++,c=(Math.abs(c)-a)*i}while(Math.abs(c)>h);c=n;for(let n=0;n<u-1;n++)e=g(e,t,s,a*i,r,u,o),c=(Math.abs(c)-a)*i;return e=g(e,t,s,c,r,u,o),e}}return g(m,t,s,n,r,1,o)}(e,this.m_spatialReference,this.m_curveType,t,this.m_convergenceOffset,this.m_progressTracker)}}}}]);